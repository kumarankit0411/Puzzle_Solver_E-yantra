
black_line_follower.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001ca  00800200  0000847a  0000850e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000847a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000be  008003ca  008003ca  000086d8  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  000086d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000079e  00000000  00000000  000086f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001be7  00000000  00000000  00008e96  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002be  00000000  00000000  0000aa7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000292a  00000000  00000000  0000ad3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000540  00000000  00000000  0000d668  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000008a9  00000000  00000000  0000dba8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 16 	jmp	0x2ce4	; 0x2ce4 <__ctors_end>
       4:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
       8:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
       c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      10:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      14:	0c 94 b9 29 	jmp	0x5372	; 0x5372 <__vector_5>
      18:	0c 94 8e 29 	jmp	0x531c	; 0x531c <__vector_6>
      1c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      20:	0c 94 74 29 	jmp	0x52e8	; 0x52e8 <__vector_8>
      24:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      28:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      2c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      30:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      34:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      38:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      3c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      40:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      44:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      48:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      4c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      50:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      54:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      58:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      5c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      60:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      64:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      68:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      6c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      70:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      74:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      78:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      7c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      80:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      84:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      88:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      8c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      90:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      94:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      98:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      9c:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      a0:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      a4:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      a8:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      ac:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      b0:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      b4:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      b8:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      bc:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      c0:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      c4:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      c8:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      cc:	0c 94 dc 26 	jmp	0x4db8	; 0x4db8 <__vector_51>
      d0:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      d4:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      d8:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      dc:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>
      e0:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__bad_interrupt>

000000e4 <Deposit>:
	...
     164:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     174:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
     184:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
     194:	00 00 30 80 01 00 00 00 00 00 f0 ff 01 00 00 00     ..0.............
     1a4:	00 00 e0 ff 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     1bc:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     1cc:	00 00 30 8c 01 00 00 00 00 00 30 8c 01 00 00 00     ..0.......0.....
     1dc:	00 00 30 8c 01 00 00 00 00 00 30 8c 01 00 00 00     ..0.......0.....
     1ec:	00 00 30 80 01 00 00 00 00 00 00 00 00 00 00 00     ..0.............
	...
     204:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     214:	00 00 30 06 00 00 00 00 00 00 30 06 00 00 00 00     ..0.......0.....
     224:	00 00 30 06 00 00 00 00 00 00 30 06 00 00 00 00     ..0.......0.....
     234:	00 00 f0 07 00 00 00 00 00 00 f0 03 00 00 00 00     ................
	...
     254:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     264:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
     274:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
     284:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
	...
     2a4:	00 00 f0 8f 01 00 00 00 00 00 f0 8f 01 00 00 00     ................
     2b4:	00 00 30 8c 01 00 00 00 00 00 30 8c 01 00 00 00     ..0.......0.....
     2c4:	00 00 30 8c 01 00 00 00 00 00 30 fc 01 00 00 00     ..0.......0.....
     2d4:	00 00 30 fc 01 00 00 00 00 00 00 00 00 00 00 00     ..0.............
	...
     2ec:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
     2fc:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     30c:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
	...
     32c:	00 00 30 00 00 00 00 00 00 00 30 00 00 00 00 00     ..0.......0.....
     33c:	00 00 30 00 00 00 00 00 00 00 30 00 00 00 00 00     ..0.......0.....
     34c:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     35c:	00 00 30 00 00 00 00 00 00 00 30 00 00 00 00 00     ..0.......0.....
     36c:	00 00 30 00 00 00 00 00 00 00 30 00 00 00 00 00     ..0.......0.....
	...
     38c:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     39c:	00 00 30 8c 01 00 00 00 00 00 30 8c 01 00 00 00     ..0.......0.....
     3ac:	00 00 30 8c 01 00 00 00 00 00 30 8c 01 00 00 00     ..0.......0.....
     3bc:	00 00 30 8c 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
	...
     3dc:	00 00 f0 ff 01 00 00 00 00 00 f0 ff 01 00 00 00     ................
     3ec:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
     3fc:	00 00 30 80 01 00 00 00 00 00 30 80 01 00 00 00     ..0.......0.....
     40c:	00 00 30 80 01 00 00 00 00 00 f0 ff 01 00 00 00     ..0.............
     41c:	00 00 e0 ff 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

000004e4 <font0>:
	...
     654:	00 ff ff ff ff ff 7f 00 00 ff ff ff ff ff 7f 00     ................
     664:	00 ff ff ff ff ff 7f 00 00 ff ff ff ff ff 7f 00     ................
     674:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     684:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     694:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     6a4:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     6b4:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     6c4:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     6d4:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     6e4:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     6f4:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     704:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     714:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     724:	00 0f 00 00 00 00 78 00 00 0f 00 00 00 00 78 00     ......x.......x.
     734:	00 ff ff ff ff ff 7f 00 00 ff ff ff ff ff 7f 00     ................
     744:	00 ff ff ff ff ff 7f 00 00 ff ff ff ff ff 7f 00     ................
	...

000008e4 <font1>:
	...
     a9c:	00 04 00 00 00 00 00 00 00 06 00 00 00 00 00 00     ................
     aac:	00 07 00 00 00 00 00 00 80 07 00 00 00 00 f0 00     ................
     abc:	80 07 00 00 00 00 f0 00 80 07 00 00 00 00 f0 00     ................
     acc:	80 07 00 00 00 00 f0 00 80 07 00 00 00 00 f0 00     ................
     adc:	80 07 00 00 00 00 f0 00 80 ff ff ff ff ff ff 00     ................
     aec:	80 ff ff ff ff ff ff 00 80 ff ff ff ff ff ff 00     ................
     afc:	80 ff ff ff ff ff ff 00 00 00 00 00 00 00 f0 00     ................
     b0c:	00 00 00 00 00 00 f0 00 00 00 00 00 00 00 f0 00     ................
     b1c:	00 00 00 00 00 00 f0 00 00 00 00 00 00 00 f0 00     ................
     b2c:	00 00 00 00 00 00 f0 00 00 00 00 00 00 00 00 00     ................
	...

00000ce4 <font2>:
	...
     e4c:	80 07 00 e0 ff ff 3f 00 80 07 00 e0 ff ff 3f 00     ......?.......?.
     e5c:	80 07 00 e0 ff ff 3f 00 80 07 00 e0 ff ff 3f 00     ......?.......?.
     e6c:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     e7c:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     e8c:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     e9c:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     eac:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     ebc:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     ecc:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     edc:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     eec:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     efc:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     f0c:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     f1c:	80 07 00 e0 01 00 3c 00 80 07 00 e0 01 00 3c 00     ......<.......<.
     f2c:	80 ff ff ff 01 00 3c 00 80 ff ff ff 01 00 3c 00     ......<.......<.
     f3c:	80 ff ff ff 01 00 3c 00 80 ff ff ff 01 00 3c 00     ......<.......<.
	...

000010e4 <font3>:
	...
    124c:	00 03 00 80 00 00 30 00 80 07 00 c0 01 00 78 00     ......0.......x.
    125c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    126c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    127c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    128c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    129c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    12ac:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    12bc:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    12cc:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    12dc:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    12ec:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    12fc:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    130c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    131c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    132c:	80 07 00 c0 01 00 78 00 80 07 00 c0 01 00 78 00     ......x.......x.
    133c:	80 ff ff ff ff ff 7f 00 80 ff ff 7f ff ff 7f 00     ................
    134c:	80 ff ff 3f fe ff 7f 00 80 ff ff 3f fe ff 7f 00     ...?.......?....
	...

000014e4 <font4>:
	...
    1644:	80 ff ff ff 03 00 00 00 80 ff ff ff 03 00 00 00     ................
    1654:	80 ff ff ff 03 00 00 00 80 ff ff ff 03 00 00 00     ................
    1664:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    1674:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    1684:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    1694:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    16a4:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    16b4:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    16c4:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    16d4:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    16e4:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    16f4:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    1704:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    1714:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    1724:	00 00 00 c0 03 00 00 00 00 00 00 c0 03 00 00 00     ................
    1734:	80 ff ff ff ff ff ff 01 80 ff ff ff ff ff ff 01     ................
    1744:	80 ff ff ff ff ff ff 01 80 ff ff ff ff ff ff 01     ................
	...

000018e4 <font5>:
	...
    1a5c:	00 ff ff ff 01 00 78 00 00 ff ff ff 01 00 78 00     ......x.......x.
    1a6c:	00 ff ff ff 01 00 78 00 00 ff ff ff 01 00 78 00     ......x.......x.
    1a7c:	00 ff ff ff 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1a8c:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1a9c:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1aac:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1abc:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1acc:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1adc:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1aec:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1afc:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1b0c:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1b1c:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1b2c:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1b3c:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 01 00 78 00     ......x.......x.
    1b4c:	00 0f 00 e0 01 00 78 00 00 0f 00 e0 ff ff 7f 00     ......x.........
    1b5c:	00 0f 00 e0 ff ff 7f 00 00 0f 00 e0 ff ff 7f 00     ................
    1b6c:	00 0f 00 e0 ff ff 7f 00 00 00 00 00 00 00 00 00     ................
	...

00001ce4 <font6>:
	...
    1e2c:	00 ff ff ff ff ff 3f 00 00 ff ff ff ff ff 3f 00     ......?.......?.
    1e3c:	00 ff ff ff ff ff 3f 00 00 ff ff ff ff ff 3f 00     ......?.......?.
    1e4c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1e5c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1e6c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1e7c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1e8c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1e9c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1eac:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1ebc:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1ecc:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1edc:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1eec:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1efc:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1f0c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 07 00 3c 00     ......<.......<.
    1f1c:	00 0f 00 80 07 00 3c 00 00 0f 00 80 0f 00 3e 00     ......<.......>.
    1f2c:	00 0f 00 80 1f 00 3f 00 00 0f 00 80 ff ff 3f 00     ......?.......?.
    1f3c:	00 0f 00 80 ff ff 3f 00 00 00 00 00 00 00 00 00     ......?.........
	...

000020e4 <font7>:
	...
    220c:	00 7f 00 00 00 00 00 00 00 7f 00 00 00 00 00 00     ................
    221c:	00 7f 00 00 00 00 00 00 00 7f 00 00 00 00 00 00     ................
    222c:	00 7f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    223c:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    224c:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    225c:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    226c:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    227c:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    228c:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    229c:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    22ac:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    22bc:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    22cc:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    22dc:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    22ec:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    22fc:	00 0f 00 00 00 00 00 00 00 0f 00 00 00 00 00 00     ................
    230c:	00 ff ff ff ff ff 0f 00 00 ff ff ff ff ff 0f 00     ................
    231c:	00 ff ff ff ff ff 0f 00 00 ff ff ff ff ff 0f 00     ................
	...

000024e4 <font8>:
	...
    2644:	80 ff ff 3f fe ff ff 01 80 ff ff 7f ff ff ff 01     ...?............
    2654:	80 ff ff ff ff ff ff 01 80 07 00 c0 01 00 e0 01     ................
    2664:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    2674:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    2684:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    2694:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    26a4:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    26b4:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    26c4:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    26d4:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    26e4:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    26f4:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    2704:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    2714:	80 07 00 c0 01 00 e0 01 80 07 00 c0 01 00 e0 01     ................
    2724:	80 07 00 c0 01 00 e0 01 80 ff ff ff ff ff ff 01     ................
    2734:	80 ff ff 7f ff ff ff 01 80 ff ff 3f fe ff ff 01     ...........?....
	...

000028e4 <font9>:
	...
    2a54:	00 ff ff 7f 00 00 78 00 00 ff ff 7f 00 00 78 00     ......x.......x.
    2a64:	00 ff ff 7f 00 00 78 00 00 ff ff 7f 00 00 78 00     ......x.......x.
    2a74:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2a84:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2a94:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2aa4:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2ab4:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2ac4:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2ad4:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2ae4:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2af4:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2b04:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2b14:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2b24:	00 0f 00 78 00 00 78 00 00 0f 00 78 00 00 78 00     ...x..x....x..x.
    2b34:	00 ff ff ff ff ff 7f 00 00 ff ff ff ff ff 7f 00     ................
    2b44:	00 ff ff ff ff ff 7f 00 00 ff ff ff ff ff 7f 00     ................
	...

00002ce4 <__ctors_end>:
    2ce4:	11 24       	eor	r1, r1
    2ce6:	1f be       	out	0x3f, r1	; 63
    2ce8:	cf ef       	ldi	r28, 0xFF	; 255
    2cea:	d1 e2       	ldi	r29, 0x21	; 33
    2cec:	de bf       	out	0x3e, r29	; 62
    2cee:	cd bf       	out	0x3d, r28	; 61
    2cf0:	00 e0       	ldi	r16, 0x00	; 0
    2cf2:	0c bf       	out	0x3c, r16	; 60

00002cf4 <__do_copy_data>:
    2cf4:	13 e0       	ldi	r17, 0x03	; 3
    2cf6:	a0 e0       	ldi	r26, 0x00	; 0
    2cf8:	b2 e0       	ldi	r27, 0x02	; 2
    2cfa:	ea e7       	ldi	r30, 0x7A	; 122
    2cfc:	f4 e8       	ldi	r31, 0x84	; 132
    2cfe:	00 e0       	ldi	r16, 0x00	; 0
    2d00:	0b bf       	out	0x3b, r16	; 59
    2d02:	02 c0       	rjmp	.+4      	; 0x2d08 <__do_copy_data+0x14>
    2d04:	07 90       	elpm	r0, Z+
    2d06:	0d 92       	st	X+, r0
    2d08:	aa 3c       	cpi	r26, 0xCA	; 202
    2d0a:	b1 07       	cpc	r27, r17
    2d0c:	d9 f7       	brne	.-10     	; 0x2d04 <__do_copy_data+0x10>

00002d0e <__do_clear_bss>:
    2d0e:	14 e0       	ldi	r17, 0x04	; 4
    2d10:	aa ec       	ldi	r26, 0xCA	; 202
    2d12:	b3 e0       	ldi	r27, 0x03	; 3
    2d14:	01 c0       	rjmp	.+2      	; 0x2d18 <.do_clear_bss_start>

00002d16 <.do_clear_bss_loop>:
    2d16:	1d 92       	st	X+, r1

00002d18 <.do_clear_bss_start>:
    2d18:	a8 38       	cpi	r26, 0x88	; 136
    2d1a:	b1 07       	cpc	r27, r17
    2d1c:	e1 f7       	brne	.-8      	; 0x2d16 <.do_clear_bss_loop>
    2d1e:	0e 94 0f 3b 	call	0x761e	; 0x761e <main>
    2d22:	0c 94 3b 42 	jmp	0x8476	; 0x8476 <_exit>

00002d26 <__bad_interrupt>:
    2d26:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002d2a <GLCD_Init>:

 * description  :This function is used to initialize the GLCD.
                 
**************************************************************************************************/
void GLCD_Init()
{
    2d2a:	df 93       	push	r29
    2d2c:	cf 93       	push	r28
    2d2e:	cd b7       	in	r28, 0x3d	; 61
    2d30:	de b7       	in	r29, 0x3e	; 62
    2d32:	2e 97       	sbiw	r28, 0x0e	; 14
    2d34:	0f b6       	in	r0, 0x3f	; 63
    2d36:	f8 94       	cli
    2d38:	de bf       	out	0x3e, r29	; 62
    2d3a:	0f be       	out	0x3f, r0	; 63
    2d3c:	cd bf       	out	0x3d, r28	; 61
	M_GlcdControlBusDirection = C_PortOutput_U8; /* Configure the data bus and Control bus as Output */
    2d3e:	ea e2       	ldi	r30, 0x2A	; 42
    2d40:	f0 e0       	ldi	r31, 0x00	; 0
    2d42:	8f ef       	ldi	r24, 0xFF	; 255
    2d44:	80 83       	st	Z, r24
    M_GlcdDataBusDirection = C_PortOutput_U8;
    2d46:	e4 e0       	ldi	r30, 0x04	; 4
    2d48:	f1 e0       	ldi	r31, 0x01	; 1
    2d4a:	8f ef       	ldi	r24, 0xFF	; 255
    2d4c:	80 83       	st	Z, r24
	M_GlcdControlBusDirection1 = C_PortOutput_U8;
    2d4e:	ea e0       	ldi	r30, 0x0A	; 10
    2d50:	f1 e0       	ldi	r31, 0x01	; 1
    2d52:	8f ef       	ldi	r24, 0xFF	; 255
    2d54:	80 83       	st	Z, r24


    /* Select the Page0/Page1 and Enable the GLCD */
    glcd_SelectPage0();
    2d56:	0e 94 2a 1c 	call	0x3854	; 0x3854 <glcd_SelectPage0>
    glcd_CmdWrite(0x3F);
    2d5a:	8f e3       	ldi	r24, 0x3F	; 63
    2d5c:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>
    glcd_SelectPage1();
    2d60:	0e 94 3f 1c 	call	0x387e	; 0x387e <glcd_SelectPage1>
    glcd_CmdWrite(0x3F);
    2d64:	8f e3       	ldi	r24, 0x3F	; 63
    2d66:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>
    2d6a:	80 e0       	ldi	r24, 0x00	; 0
    2d6c:	90 e0       	ldi	r25, 0x00	; 0
    2d6e:	a0 e2       	ldi	r26, 0x20	; 32
    2d70:	b1 e4       	ldi	r27, 0x41	; 65
    2d72:	8b 87       	std	Y+11, r24	; 0x0b
    2d74:	9c 87       	std	Y+12, r25	; 0x0c
    2d76:	ad 87       	std	Y+13, r26	; 0x0d
    2d78:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d7a:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d7c:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d80:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d82:	26 e6       	ldi	r18, 0x66	; 102
    2d84:	36 e6       	ldi	r19, 0x66	; 102
    2d86:	46 e6       	ldi	r20, 0x66	; 102
    2d88:	55 e4       	ldi	r21, 0x45	; 69
    2d8a:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    2d8e:	dc 01       	movw	r26, r24
    2d90:	cb 01       	movw	r24, r22
    2d92:	8f 83       	std	Y+7, r24	; 0x07
    2d94:	98 87       	std	Y+8, r25	; 0x08
    2d96:	a9 87       	std	Y+9, r26	; 0x09
    2d98:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2d9a:	6f 81       	ldd	r22, Y+7	; 0x07
    2d9c:	78 85       	ldd	r23, Y+8	; 0x08
    2d9e:	89 85       	ldd	r24, Y+9	; 0x09
    2da0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2da2:	20 e0       	ldi	r18, 0x00	; 0
    2da4:	30 e0       	ldi	r19, 0x00	; 0
    2da6:	40 e8       	ldi	r20, 0x80	; 128
    2da8:	5f e3       	ldi	r21, 0x3F	; 63
    2daa:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    2dae:	88 23       	and	r24, r24
    2db0:	2c f4       	brge	.+10     	; 0x2dbc <GLCD_Init+0x92>
		__ticks = 1;
    2db2:	81 e0       	ldi	r24, 0x01	; 1
    2db4:	90 e0       	ldi	r25, 0x00	; 0
    2db6:	9e 83       	std	Y+6, r25	; 0x06
    2db8:	8d 83       	std	Y+5, r24	; 0x05
    2dba:	3f c0       	rjmp	.+126    	; 0x2e3a <GLCD_Init+0x110>
	else if (__tmp > 65535)
    2dbc:	6f 81       	ldd	r22, Y+7	; 0x07
    2dbe:	78 85       	ldd	r23, Y+8	; 0x08
    2dc0:	89 85       	ldd	r24, Y+9	; 0x09
    2dc2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dc4:	20 e0       	ldi	r18, 0x00	; 0
    2dc6:	3f ef       	ldi	r19, 0xFF	; 255
    2dc8:	4f e7       	ldi	r20, 0x7F	; 127
    2dca:	57 e4       	ldi	r21, 0x47	; 71
    2dcc:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    2dd0:	18 16       	cp	r1, r24
    2dd2:	4c f5       	brge	.+82     	; 0x2e26 <GLCD_Init+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2dd4:	6b 85       	ldd	r22, Y+11	; 0x0b
    2dd6:	7c 85       	ldd	r23, Y+12	; 0x0c
    2dd8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2dda:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ddc:	20 e0       	ldi	r18, 0x00	; 0
    2dde:	30 e0       	ldi	r19, 0x00	; 0
    2de0:	40 e2       	ldi	r20, 0x20	; 32
    2de2:	51 e4       	ldi	r21, 0x41	; 65
    2de4:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    2de8:	dc 01       	movw	r26, r24
    2dea:	cb 01       	movw	r24, r22
    2dec:	bc 01       	movw	r22, r24
    2dee:	cd 01       	movw	r24, r26
    2df0:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    2df4:	dc 01       	movw	r26, r24
    2df6:	cb 01       	movw	r24, r22
    2df8:	9e 83       	std	Y+6, r25	; 0x06
    2dfa:	8d 83       	std	Y+5, r24	; 0x05
    2dfc:	0f c0       	rjmp	.+30     	; 0x2e1c <GLCD_Init+0xf2>
    2dfe:	80 e7       	ldi	r24, 0x70	; 112
    2e00:	91 e0       	ldi	r25, 0x01	; 1
    2e02:	9c 83       	std	Y+4, r25	; 0x04
    2e04:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2e06:	8b 81       	ldd	r24, Y+3	; 0x03
    2e08:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0a:	01 97       	sbiw	r24, 0x01	; 1
    2e0c:	f1 f7       	brne	.-4      	; 0x2e0a <GLCD_Init+0xe0>
    2e0e:	9c 83       	std	Y+4, r25	; 0x04
    2e10:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e12:	8d 81       	ldd	r24, Y+5	; 0x05
    2e14:	9e 81       	ldd	r25, Y+6	; 0x06
    2e16:	01 97       	sbiw	r24, 0x01	; 1
    2e18:	9e 83       	std	Y+6, r25	; 0x06
    2e1a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    2e1e:	9e 81       	ldd	r25, Y+6	; 0x06
    2e20:	00 97       	sbiw	r24, 0x00	; 0
    2e22:	69 f7       	brne	.-38     	; 0x2dfe <GLCD_Init+0xd4>
    2e24:	14 c0       	rjmp	.+40     	; 0x2e4e <GLCD_Init+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e26:	6f 81       	ldd	r22, Y+7	; 0x07
    2e28:	78 85       	ldd	r23, Y+8	; 0x08
    2e2a:	89 85       	ldd	r24, Y+9	; 0x09
    2e2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e2e:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    2e32:	dc 01       	movw	r26, r24
    2e34:	cb 01       	movw	r24, r22
    2e36:	9e 83       	std	Y+6, r25	; 0x06
    2e38:	8d 83       	std	Y+5, r24	; 0x05
    2e3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e3e:	9a 83       	std	Y+2, r25	; 0x02
    2e40:	89 83       	std	Y+1, r24	; 0x01
    2e42:	89 81       	ldd	r24, Y+1	; 0x01
    2e44:	9a 81       	ldd	r25, Y+2	; 0x02
    2e46:	01 97       	sbiw	r24, 0x01	; 1
    2e48:	f1 f7       	brne	.-4      	; 0x2e46 <GLCD_Init+0x11c>
    2e4a:	9a 83       	std	Y+2, r25	; 0x02
    2e4c:	89 83       	std	Y+1, r24	; 0x01
    DELAY_ms(10);

    /* Select the Page0/Page1 and Enable the GLCD */
    glcd_SelectPage0();
    2e4e:	0e 94 2a 1c 	call	0x3854	; 0x3854 <glcd_SelectPage0>
    glcd_CmdWrite(0xc0);
    2e52:	80 ec       	ldi	r24, 0xC0	; 192
    2e54:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>
    glcd_SelectPage1();
    2e58:	0e 94 3f 1c 	call	0x387e	; 0x387e <glcd_SelectPage1>
    glcd_CmdWrite(0xc0);
    2e5c:	80 ec       	ldi	r24, 0xC0	; 192
    2e5e:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>

   /* Clear the complete LCD and move the cursor to beginning of page0*/
    GLCD_Clear();
    2e62:	0e 94 3c 17 	call	0x2e78	; 0x2e78 <GLCD_Clear>
}
    2e66:	2e 96       	adiw	r28, 0x0e	; 14
    2e68:	0f b6       	in	r0, 0x3f	; 63
    2e6a:	f8 94       	cli
    2e6c:	de bf       	out	0x3e, r29	; 62
    2e6e:	0f be       	out	0x3f, r0	; 63
    2e70:	cd bf       	out	0x3d, r28	; 61
    2e72:	cf 91       	pop	r28
    2e74:	df 91       	pop	r29
    2e76:	08 95       	ret

00002e78 <GLCD_Clear>:
 * Return value    : none

 * description  :This function clears the LCD and moves the cursor to beginning of first line on page0
 ***************************************************************************************************/
void GLCD_Clear()
{
    2e78:	df 93       	push	r29
    2e7a:	cf 93       	push	r28
    2e7c:	00 d0       	rcall	.+0      	; 0x2e7e <GLCD_Clear+0x6>
    2e7e:	cd b7       	in	r28, 0x3d	; 61
    2e80:	de b7       	in	r29, 0x3e	; 62
    uint8_t line,cursor,inversion;

    inversion = GLCD.Invertdisplay;
    2e82:	80 91 fb 03 	lds	r24, 0x03FB
    2e86:	89 83       	std	Y+1, r24	; 0x01
	GLCD.Invertdisplay = 0x00;
    2e88:	10 92 fb 03 	sts	0x03FB, r1
	
    for(line=0;line<8;line++)  /* loop through all the 8lines to clear the display */
    2e8c:	1b 82       	std	Y+3, r1	; 0x03
    2e8e:	17 c0       	rjmp	.+46     	; 0x2ebe <GLCD_Clear+0x46>
    {
         GLCD_GoToLine(line);  /* Go to beginning of the specified line on page0 */
    2e90:	8b 81       	ldd	r24, Y+3	; 0x03
    2e92:	0e 94 ed 17 	call	0x2fda	; 0x2fda <GLCD_GoToLine>
        
        for(cursor=0;cursor<128;cursor++) /* Clear all the 128 pixels of selected line */
    2e96:	1a 82       	std	Y+2, r1	; 0x02
    2e98:	0c c0       	rjmp	.+24     	; 0x2eb2 <GLCD_Clear+0x3a>
        {
            if(cursor==64)  /* Has the cursor reached end of page0 */
    2e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e9c:	80 34       	cpi	r24, 0x40	; 64
    2e9e:	19 f4       	brne	.+6      	; 0x2ea6 <GLCD_Clear+0x2e>
            {
                GLCD_GoToPage(1); /*  then set it to beginning of page1 */
    2ea0:	81 e0       	ldi	r24, 0x01	; 1
    2ea2:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <GLCD_GoToPage>
                
            }
            glcd_DataWrite(0x00); /* Clear each pixel by displaying blank */
    2ea6:	80 e0       	ldi	r24, 0x00	; 0
    2ea8:	0e 94 71 19 	call	0x32e2	; 0x32e2 <glcd_DataWrite>
	
    for(line=0;line<8;line++)  /* loop through all the 8lines to clear the display */
    {
         GLCD_GoToLine(line);  /* Go to beginning of the specified line on page0 */
        
        for(cursor=0;cursor<128;cursor++) /* Clear all the 128 pixels of selected line */
    2eac:	8a 81       	ldd	r24, Y+2	; 0x02
    2eae:	8f 5f       	subi	r24, 0xFF	; 255
    2eb0:	8a 83       	std	Y+2, r24	; 0x02
    2eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb4:	88 23       	and	r24, r24
    2eb6:	8c f7       	brge	.-30     	; 0x2e9a <GLCD_Clear+0x22>
    uint8_t line,cursor,inversion;

    inversion = GLCD.Invertdisplay;
	GLCD.Invertdisplay = 0x00;
	
    for(line=0;line<8;line++)  /* loop through all the 8lines to clear the display */
    2eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eba:	8f 5f       	subi	r24, 0xFF	; 255
    2ebc:	8b 83       	std	Y+3, r24	; 0x03
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	88 30       	cpi	r24, 0x08	; 8
    2ec2:	30 f3       	brcs	.-52     	; 0x2e90 <GLCD_Clear+0x18>
            }
            glcd_DataWrite(0x00); /* Clear each pixel by displaying blank */
        }
    }
	
	GLCD.Invertdisplay = inversion;
    2ec4:	89 81       	ldd	r24, Y+1	; 0x01
    2ec6:	80 93 fb 03 	sts	0x03FB, r24

    GLCD_GoToLine(0);
    2eca:	80 e0       	ldi	r24, 0x00	; 0
    2ecc:	0e 94 ed 17 	call	0x2fda	; 0x2fda <GLCD_GoToLine>
}
    2ed0:	0f 90       	pop	r0
    2ed2:	0f 90       	pop	r0
    2ed4:	0f 90       	pop	r0
    2ed6:	cf 91       	pop	r28
    2ed8:	df 91       	pop	r29
    2eda:	08 95       	ret

00002edc <GLCD_SetCursor>:
                   Note:If the Input(Line/Char number) are out of range 
                        then no action will be taken
 ***************************************************************************************************/
 /* TODO: change the var names, Add logic for page handling */
void GLCD_SetCursor(uint8_t pageNumber,uint8_t lineNumber,uint8_t CursorPosition)
{
    2edc:	df 93       	push	r29
    2ede:	cf 93       	push	r28
    2ee0:	00 d0       	rcall	.+0      	; 0x2ee2 <GLCD_SetCursor+0x6>
    2ee2:	cd b7       	in	r28, 0x3d	; 61
    2ee4:	de b7       	in	r29, 0x3e	; 62
    2ee6:	89 83       	std	Y+1, r24	; 0x01
    2ee8:	6a 83       	std	Y+2, r22	; 0x02
    2eea:	4b 83       	std	Y+3, r20	; 0x03
    if(    ((pageNumber == 0x00)   || (pageNumber == 0x01))
    2eec:	89 81       	ldd	r24, Y+1	; 0x01
    2eee:	88 23       	and	r24, r24
    2ef0:	19 f0       	breq	.+6      	; 0x2ef8 <GLCD_SetCursor+0x1c>
    2ef2:	89 81       	ldd	r24, Y+1	; 0x01
    2ef4:	81 30       	cpi	r24, 0x01	; 1
    2ef6:	09 f5       	brne	.+66     	; 0x2f3a <GLCD_SetCursor+0x5e>
    2ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    2efa:	88 30       	cpi	r24, 0x08	; 8
    2efc:	f0 f4       	brcc	.+60     	; 0x2f3a <GLCD_SetCursor+0x5e>
    2efe:	8b 81       	ldd	r24, Y+3	; 0x03
    2f00:	80 34       	cpi	r24, 0x40	; 64
    2f02:	d8 f4       	brcc	.+54     	; 0x2f3a <GLCD_SetCursor+0x5e>
	    && ((lineNumber >=0x00)    && (lineNumber <= C_GlcdLastLine_U8))
	    && ((CursorPosition>=0x00) && (CursorPosition <= 63)) )
	  {
	    if(pageNumber==0x00)  /* Check for page number and set accordingly */
    2f04:	89 81       	ldd	r24, Y+1	; 0x01
    2f06:	88 23       	and	r24, r24
    2f08:	19 f4       	brne	.+6      	; 0x2f10 <GLCD_SetCursor+0x34>
         {
           glcd_SelectPage0();
    2f0a:	0e 94 2a 1c 	call	0x3854	; 0x3854 <glcd_SelectPage0>
    2f0e:	02 c0       	rjmp	.+4      	; 0x2f14 <GLCD_SetCursor+0x38>
         }
        else
	     {
            glcd_SelectPage1();
    2f10:	0e 94 3f 1c 	call	0x387e	; 0x387e <glcd_SelectPage1>
	      }	 

        GLCD.PageNum = pageNumber; /* Keep the track of page selected */
    2f14:	89 81       	ldd	r24, Y+1	; 0x01
    2f16:	80 93 f8 03 	sts	0x03F8, r24
        GLCD.LineNum=lineNumber | C_FirstLineNumberAddress_U8; /* Select the specified line number */
    2f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f1c:	88 6b       	ori	r24, 0xB8	; 184
    2f1e:	80 93 f9 03 	sts	0x03F9, r24
        GLCD.CursorPos=CursorPosition |0x40; /* Select the specified cursor position */
    2f22:	8b 81       	ldd	r24, Y+3	; 0x03
    2f24:	80 64       	ori	r24, 0x40	; 64
    2f26:	80 93 fa 03 	sts	0x03FA, r24
        glcd_CmdWrite(GLCD.CursorPos); /* Command the LCD to move to specified page,line,cursor*/
    2f2a:	80 91 fa 03 	lds	r24, 0x03FA
    2f2e:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>
        glcd_CmdWrite(GLCD.LineNum);
    2f32:	80 91 f9 03 	lds	r24, 0x03F9
    2f36:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>
	}
}
    2f3a:	0f 90       	pop	r0
    2f3c:	0f 90       	pop	r0
    2f3e:	0f 90       	pop	r0
    2f40:	cf 91       	pop	r28
    2f42:	df 91       	pop	r29
    2f44:	08 95       	ret

00002f46 <GLCD_GetCursor>:




void GLCD_GetCursor(uint8_t *page_ptr,uint8_t *line_ptr,uint8_t *cursor_ptr)
{
    2f46:	df 93       	push	r29
    2f48:	cf 93       	push	r28
    2f4a:	00 d0       	rcall	.+0      	; 0x2f4c <GLCD_GetCursor+0x6>
    2f4c:	00 d0       	rcall	.+0      	; 0x2f4e <GLCD_GetCursor+0x8>
    2f4e:	cd b7       	in	r28, 0x3d	; 61
    2f50:	de b7       	in	r29, 0x3e	; 62
    2f52:	9a 83       	std	Y+2, r25	; 0x02
    2f54:	89 83       	std	Y+1, r24	; 0x01
    2f56:	7c 83       	std	Y+4, r23	; 0x04
    2f58:	6b 83       	std	Y+3, r22	; 0x03
    2f5a:	5e 83       	std	Y+6, r21	; 0x06
    2f5c:	4d 83       	std	Y+5, r20	; 0x05

    *page_ptr=GLCD.PageNum;
    2f5e:	80 91 f8 03 	lds	r24, 0x03F8
    2f62:	e9 81       	ldd	r30, Y+1	; 0x01
    2f64:	fa 81       	ldd	r31, Y+2	; 0x02
    2f66:	80 83       	st	Z, r24
    *line_ptr=GLCD.LineNum;
    2f68:	80 91 f9 03 	lds	r24, 0x03F9
    2f6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f70:	80 83       	st	Z, r24
    *cursor_ptr=GLCD.CursorPos;
    2f72:	80 91 fa 03 	lds	r24, 0x03FA
    2f76:	ed 81       	ldd	r30, Y+5	; 0x05
    2f78:	fe 81       	ldd	r31, Y+6	; 0x06
    2f7a:	80 83       	st	Z, r24
}
    2f7c:	26 96       	adiw	r28, 0x06	; 6
    2f7e:	0f b6       	in	r0, 0x3f	; 63
    2f80:	f8 94       	cli
    2f82:	de bf       	out	0x3e, r29	; 62
    2f84:	0f be       	out	0x3f, r0	; 63
    2f86:	cd bf       	out	0x3d, r28	; 61
    2f88:	cf 91       	pop	r28
    2f8a:	df 91       	pop	r29
    2f8c:	08 95       	ret

00002f8e <GLCD_GoToPage>:

     Note: The line numbers run from 1 to Maxlines,
 ***************************************************************************************************/
 /* TODO: change the desp and variable name */
void GLCD_GoToPage(uint8_t pageNumber)
{
    2f8e:	df 93       	push	r29
    2f90:	cf 93       	push	r28
    2f92:	0f 92       	push	r0
    2f94:	cd b7       	in	r28, 0x3d	; 61
    2f96:	de b7       	in	r29, 0x3e	; 62
    2f98:	89 83       	std	Y+1, r24	; 0x01

    if((pageNumber==0) || (pageNumber ==1))
    2f9a:	89 81       	ldd	r24, Y+1	; 0x01
    2f9c:	88 23       	and	r24, r24
    2f9e:	19 f0       	breq	.+6      	; 0x2fa6 <GLCD_GoToPage+0x18>
    2fa0:	89 81       	ldd	r24, Y+1	; 0x01
    2fa2:	81 30       	cpi	r24, 0x01	; 1
    2fa4:	b1 f4       	brne	.+44     	; 0x2fd2 <GLCD_GoToPage+0x44>
    { /* for 128/64 GLCD only page 0&1 are supported.
        Select the specified page and move the cursor accordingly */
        if(pageNumber == 0)
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	88 23       	and	r24, r24
    2faa:	19 f4       	brne	.+6      	; 0x2fb2 <GLCD_GoToPage+0x24>
        {

            glcd_SelectPage0();
    2fac:	0e 94 2a 1c 	call	0x3854	; 0x3854 <glcd_SelectPage0>
    2fb0:	02 c0       	rjmp	.+4      	; 0x2fb6 <GLCD_GoToPage+0x28>
        }
        else
        {
            glcd_SelectPage1();
    2fb2:	0e 94 3f 1c 	call	0x387e	; 0x387e <glcd_SelectPage1>
        }
        GLCD.PageNum=pageNumber;
    2fb6:	89 81       	ldd	r24, Y+1	; 0x01
    2fb8:	80 93 f8 03 	sts	0x03F8, r24
        GLCD.CursorPos=0x40;
    2fbc:	80 e4       	ldi	r24, 0x40	; 64
    2fbe:	80 93 fa 03 	sts	0x03FA, r24
        glcd_CmdWrite(GLCD.LineNum);
    2fc2:	80 91 f9 03 	lds	r24, 0x03F9
    2fc6:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>
        glcd_CmdWrite(GLCD.CursorPos);
    2fca:	80 91 fa 03 	lds	r24, 0x03FA
    2fce:	0e 94 7d 18 	call	0x30fa	; 0x30fa <glcd_CmdWrite>
    }
}
    2fd2:	0f 90       	pop	r0
    2fd4:	cf 91       	pop	r28
    2fd6:	df 91       	pop	r29
    2fd8:	08 95       	ret

00002fda <GLCD_GoToLine>:

     Note: The line numbers run from 0 to Maxlines-1, For 128x64 the line numbers will be 0-7
***************************************************************************************************/
/* Todo: All constants for the magic numbers */
void  GLCD_GoToLine(uint8_t var_lineNumber_u8)
{
    2fda:	df 93       	push	r29
    2fdc:	cf 93       	push	r28
    2fde:	0f 92       	push	r0
    2fe0:	cd b7       	in	r28, 0x3d	; 61
    2fe2:	de b7       	in	r29, 0x3e	; 62
    2fe4:	89 83       	std	Y+1, r24	; 0x01
    if(var_lineNumber_u8 <= C_GlcdLastLine_U8)
    2fe6:	89 81       	ldd	r24, Y+1	; 0x01
    2fe8:	88 30       	cpi	r24, 0x08	; 8
    2fea:	38 f4       	brcc	.+14     	; 0x2ffa <GLCD_GoToLine+0x20>
    {   /* If the line number is within range
         then move it to specified line on page0 and keep track*/
        GLCD.LineNum = var_lineNumber_u8+C_FirstLineNumberAddress_U8;
    2fec:	89 81       	ldd	r24, Y+1	; 0x01
    2fee:	88 54       	subi	r24, 0x48	; 72
    2ff0:	80 93 f9 03 	sts	0x03F9, r24
        GLCD_GoToPage(0);
    2ff4:	80 e0       	ldi	r24, 0x00	; 0
    2ff6:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <GLCD_GoToPage>
    }
}
    2ffa:	0f 90       	pop	r0
    2ffc:	cf 91       	pop	r28
    2ffe:	df 91       	pop	r29
    3000:	08 95       	ret

00003002 <GLCD_GoToNextLine>:
 * description  :This function moves the Cursor to beginning of the next line.
        If the cursor is on last line and NextLine command is issued then 
        it will move the cursor to first line.
 ***************************************************************************************************/
void  GLCD_GoToNextLine()
{
    3002:	df 93       	push	r29
    3004:	cf 93       	push	r28
    3006:	cd b7       	in	r28, 0x3d	; 61
    3008:	de b7       	in	r29, 0x3e	; 62
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    GLCD.LineNum++;
    300a:	80 91 f9 03 	lds	r24, 0x03F9
    300e:	8f 5f       	subi	r24, 0xFF	; 255
    3010:	80 93 f9 03 	sts	0x03F9, r24
    if(GLCD.LineNum > C_LastLineNumberAddress_U8)
    3014:	80 91 f9 03 	lds	r24, 0x03F9
    3018:	80 3c       	cpi	r24, 0xC0	; 192
    301a:	18 f0       	brcs	.+6      	; 0x3022 <GLCD_GoToNextLine+0x20>
      GLCD.LineNum = C_FirstLineNumberAddress_U8;
    301c:	88 eb       	ldi	r24, 0xB8	; 184
    301e:	80 93 f9 03 	sts	0x03F9, r24
    GLCD_GoToPage(0); /* Finally move it to next line on page0 */
    3022:	80 e0       	ldi	r24, 0x00	; 0
    3024:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <GLCD_GoToPage>
}
    3028:	cf 91       	pop	r28
    302a:	df 91       	pop	r29
    302c:	08 95       	ret

0000302e <GLCD_EnableDisplayInversion>:




void GLCD_EnableDisplayInversion()
{
    302e:	df 93       	push	r29
    3030:	cf 93       	push	r28
    3032:	cd b7       	in	r28, 0x3d	; 61
    3034:	de b7       	in	r29, 0x3e	; 62
	GLCD.Invertdisplay = 0xff;
    3036:	8f ef       	ldi	r24, 0xFF	; 255
    3038:	80 93 fb 03 	sts	0x03FB, r24
}
    303c:	cf 91       	pop	r28
    303e:	df 91       	pop	r29
    3040:	08 95       	ret

00003042 <GLCD_DisableDisplayInversion>:



void GLCD_DisableDisplayInversion()
{
    3042:	df 93       	push	r29
    3044:	cf 93       	push	r28
    3046:	cd b7       	in	r28, 0x3d	; 61
    3048:	de b7       	in	r29, 0x3e	; 62
	GLCD.Invertdisplay = 0x00;
    304a:	10 92 fb 03 	sts	0x03FB, r1
}
    304e:	cf 91       	pop	r28
    3050:	df 91       	pop	r29
    3052:	08 95       	ret

00003054 <GLCD_DisplayChar>:
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
 /* Add the comments for decoding the character, Even offset handling*/
void GLCD_DisplayChar(uint8_t var_lcdData_u8)
{
    3054:	df 93       	push	r29
    3056:	cf 93       	push	r28
    3058:	00 d0       	rcall	.+0      	; 0x305a <GLCD_DisplayChar+0x6>
    305a:	0f 92       	push	r0
    305c:	cd b7       	in	r28, 0x3d	; 61
    305e:	de b7       	in	r29, 0x3e	; 62
    3060:	8c 83       	std	Y+4, r24	; 0x04
    uint8_t dat;
	const uint8_t *ptr;

    if(((GLCD.PageNum == 0x01) && (GLCD.CursorPos>=0x7c)) || (var_lcdData_u8=='\n'))
    3062:	80 91 f8 03 	lds	r24, 0x03F8
    3066:	81 30       	cpi	r24, 0x01	; 1
    3068:	21 f4       	brne	.+8      	; 0x3072 <GLCD_DisplayChar+0x1e>
    306a:	80 91 fa 03 	lds	r24, 0x03FA
    306e:	8c 37       	cpi	r24, 0x7C	; 124
    3070:	18 f4       	brcc	.+6      	; 0x3078 <GLCD_DisplayChar+0x24>
    3072:	8c 81       	ldd	r24, Y+4	; 0x04
    3074:	8a 30       	cpi	r24, 0x0A	; 10
    3076:	11 f4       	brne	.+4      	; 0x307c <GLCD_DisplayChar+0x28>
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        GLCD_GoToNextLine();
    3078:	0e 94 01 18 	call	0x3002	; 0x3002 <GLCD_GoToNextLine>
    }
       if(var_lcdData_u8!='\n') /* TODO */
    307c:	8c 81       	ldd	r24, Y+4	; 0x04
    307e:	8a 30       	cpi	r24, 0x0A	; 10
    3080:	b9 f0       	breq	.+46     	; 0x30b0 <GLCD_DisplayChar+0x5c>
    {
        //ptr= &ARR_GlcdFont_U8[var_lcdData_u8]; /* Get the address of the Character pattern from LookUp */
        while(1)
        {
            if((GLCD.PageNum == 0x00) && (GLCD.CursorPos==0x80))
    3082:	80 91 f8 03 	lds	r24, 0x03F8
    3086:	88 23       	and	r24, r24
    3088:	39 f4       	brne	.+14     	; 0x3098 <GLCD_DisplayChar+0x44>
    308a:	80 91 fa 03 	lds	r24, 0x03FA
    308e:	80 38       	cpi	r24, 0x80	; 128
    3090:	19 f4       	brne	.+6      	; 0x3098 <GLCD_DisplayChar+0x44>
            {
                /* If the cursor has reached to end of line on page0
                     Then Move the cursor to Page1 */
                GLCD_GoToPage(1);
    3092:	81 e0       	ldi	r24, 0x01	; 1
    3094:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <GLCD_GoToPage>
            }

           // dat= pgm_read_byte(ptr++);/* Get the data to be displayed for LookUptable*/

            if(dat==0xff) /* Exit the loop if End of char is encountered */
    3098:	8b 81       	ldd	r24, Y+3	; 0x03
    309a:	8f 3f       	cpi	r24, 0xFF	; 255
    309c:	49 f0       	breq	.+18     	; 0x30b0 <GLCD_DisplayChar+0x5c>
                break;

            glcd_DataWrite(dat); /* Display the data and keep track of cursor */
    309e:	8b 81       	ldd	r24, Y+3	; 0x03
    30a0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <glcd_DataWrite>
            GLCD.CursorPos++;
    30a4:	80 91 fa 03 	lds	r24, 0x03FA
    30a8:	8f 5f       	subi	r24, 0xFF	; 255
    30aa:	80 93 fa 03 	sts	0x03FA, r24
    30ae:	e9 cf       	rjmp	.-46     	; 0x3082 <GLCD_DisplayChar+0x2e>
        }
    }
}
    30b0:	0f 90       	pop	r0
    30b2:	0f 90       	pop	r0
    30b4:	0f 90       	pop	r0
    30b6:	0f 90       	pop	r0
    30b8:	cf 91       	pop	r28
    30ba:	df 91       	pop	r29
    30bc:	08 95       	ret

000030be <GLCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_GLCD_DisplayString==1)
void GLCD_DisplayString(char *ptr_stringPointer_u8)
{
    30be:	df 93       	push	r29
    30c0:	cf 93       	push	r28
    30c2:	0f 92       	push	r0
    30c4:	0f 92       	push	r0
    30c6:	cd b7       	in	r28, 0x3d	; 61
    30c8:	de b7       	in	r29, 0x3e	; 62
    30ca:	9a 83       	std	Y+2, r25	; 0x02
    30cc:	89 83       	std	Y+1, r24	; 0x01
    30ce:	0b c0       	rjmp	.+22     	; 0x30e6 <GLCD_DisplayString+0x28>
    while((*ptr_stringPointer_u8)!=0)
        GLCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
    30d0:	e9 81       	ldd	r30, Y+1	; 0x01
    30d2:	fa 81       	ldd	r31, Y+2	; 0x02
    30d4:	20 81       	ld	r18, Z
    30d6:	89 81       	ldd	r24, Y+1	; 0x01
    30d8:	9a 81       	ldd	r25, Y+2	; 0x02
    30da:	01 96       	adiw	r24, 0x01	; 1
    30dc:	9a 83       	std	Y+2, r25	; 0x02
    30de:	89 83       	std	Y+1, r24	; 0x01
    30e0:	82 2f       	mov	r24, r18
    30e2:	0e 94 2a 18 	call	0x3054	; 0x3054 <GLCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_GLCD_DisplayString==1)
void GLCD_DisplayString(char *ptr_stringPointer_u8)
{
    while((*ptr_stringPointer_u8)!=0)
    30e6:	e9 81       	ldd	r30, Y+1	; 0x01
    30e8:	fa 81       	ldd	r31, Y+2	; 0x02
    30ea:	80 81       	ld	r24, Z
    30ec:	88 23       	and	r24, r24
    30ee:	81 f7       	brne	.-32     	; 0x30d0 <GLCD_DisplayString+0x12>
        GLCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
    30f0:	0f 90       	pop	r0
    30f2:	0f 90       	pop	r0
    30f4:	cf 91       	pop	r28
    30f6:	df 91       	pop	r29
    30f8:	08 95       	ret

000030fa <glcd_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behavior is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
static void glcd_CmdWrite( uint8_t var_cmd_u8)
{
    30fa:	df 93       	push	r29
    30fc:	cf 93       	push	r28
    30fe:	cd b7       	in	r28, 0x3d	; 61
    3100:	de b7       	in	r29, 0x3e	; 62
    3102:	69 97       	sbiw	r28, 0x19	; 25
    3104:	0f b6       	in	r0, 0x3f	; 63
    3106:	f8 94       	cli
    3108:	de bf       	out	0x3e, r29	; 62
    310a:	0f be       	out	0x3f, r0	; 63
    310c:	cd bf       	out	0x3d, r28	; 61
    310e:	89 8f       	std	Y+25, r24	; 0x19
    glcd_BusyCheck();
    3110:	0e 94 65 1a 	call	0x34ca	; 0x34ca <glcd_BusyCheck>
    M_GlcdDataBus = var_cmd_u8;
    3114:	e5 e0       	ldi	r30, 0x05	; 5
    3116:	f1 e0       	ldi	r31, 0x01	; 1
    3118:	89 8d       	ldd	r24, Y+25	; 0x19
    311a:	80 83       	st	Z, r24
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RS);           // Select the Command Register by pulling RS LOW
    311c:	ab e2       	ldi	r26, 0x2B	; 43
    311e:	b0 e0       	ldi	r27, 0x00	; 0
    3120:	eb e2       	ldi	r30, 0x2B	; 43
    3122:	f0 e0       	ldi	r31, 0x00	; 0
    3124:	80 81       	ld	r24, Z
    3126:	8f 7d       	andi	r24, 0xDF	; 223
    3128:	8c 93       	st	X, r24
#ifdef GLCD_RW
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RW);           // Select the Write Operation  by pulling RW LOW
    312a:	ab e2       	ldi	r26, 0x2B	; 43
    312c:	b0 e0       	ldi	r27, 0x00	; 0
    312e:	eb e2       	ldi	r30, 0x2B	; 43
    3130:	f0 e0       	ldi	r31, 0x00	; 0
    3132:	80 81       	ld	r24, Z
    3134:	8f 7b       	andi	r24, 0xBF	; 191
    3136:	8c 93       	st	X, r24
#endif
    M_GlcdSetBit(M_GlcdControlBus,GLCD_EN);             // Send a High-to-Low Pulse at Enable Pin
    3138:	ab e2       	ldi	r26, 0x2B	; 43
    313a:	b0 e0       	ldi	r27, 0x00	; 0
    313c:	eb e2       	ldi	r30, 0x2B	; 43
    313e:	f0 e0       	ldi	r31, 0x00	; 0
    3140:	80 81       	ld	r24, Z
    3142:	80 68       	ori	r24, 0x80	; 128
    3144:	8c 93       	st	X, r24
    3146:	80 e0       	ldi	r24, 0x00	; 0
    3148:	90 e0       	ldi	r25, 0x00	; 0
    314a:	a0 e0       	ldi	r26, 0x00	; 0
    314c:	b0 e4       	ldi	r27, 0x40	; 64
    314e:	8d 8b       	std	Y+21, r24	; 0x15
    3150:	9e 8b       	std	Y+22, r25	; 0x16
    3152:	af 8b       	std	Y+23, r26	; 0x17
    3154:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3156:	6d 89       	ldd	r22, Y+21	; 0x15
    3158:	7e 89       	ldd	r23, Y+22	; 0x16
    315a:	8f 89       	ldd	r24, Y+23	; 0x17
    315c:	98 8d       	ldd	r25, Y+24	; 0x18
    315e:	22 e5       	ldi	r18, 0x52	; 82
    3160:	39 e4       	ldi	r19, 0x49	; 73
    3162:	4d e9       	ldi	r20, 0x9D	; 157
    3164:	50 e4       	ldi	r21, 0x40	; 64
    3166:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    316a:	dc 01       	movw	r26, r24
    316c:	cb 01       	movw	r24, r22
    316e:	89 8b       	std	Y+17, r24	; 0x11
    3170:	9a 8b       	std	Y+18, r25	; 0x12
    3172:	ab 8b       	std	Y+19, r26	; 0x13
    3174:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    3176:	69 89       	ldd	r22, Y+17	; 0x11
    3178:	7a 89       	ldd	r23, Y+18	; 0x12
    317a:	8b 89       	ldd	r24, Y+19	; 0x13
    317c:	9c 89       	ldd	r25, Y+20	; 0x14
    317e:	20 e0       	ldi	r18, 0x00	; 0
    3180:	30 e0       	ldi	r19, 0x00	; 0
    3182:	40 e8       	ldi	r20, 0x80	; 128
    3184:	5f e3       	ldi	r21, 0x3F	; 63
    3186:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    318a:	88 23       	and	r24, r24
    318c:	1c f4       	brge	.+6      	; 0x3194 <glcd_CmdWrite+0x9a>
		__ticks = 1;
    318e:	81 e0       	ldi	r24, 0x01	; 1
    3190:	88 8b       	std	Y+16, r24	; 0x10
    3192:	91 c0       	rjmp	.+290    	; 0x32b6 <glcd_CmdWrite+0x1bc>
	else if (__tmp > 255)
    3194:	69 89       	ldd	r22, Y+17	; 0x11
    3196:	7a 89       	ldd	r23, Y+18	; 0x12
    3198:	8b 89       	ldd	r24, Y+19	; 0x13
    319a:	9c 89       	ldd	r25, Y+20	; 0x14
    319c:	20 e0       	ldi	r18, 0x00	; 0
    319e:	30 e0       	ldi	r19, 0x00	; 0
    31a0:	4f e7       	ldi	r20, 0x7F	; 127
    31a2:	53 e4       	ldi	r21, 0x43	; 67
    31a4:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    31a8:	18 16       	cp	r1, r24
    31aa:	0c f0       	brlt	.+2      	; 0x31ae <glcd_CmdWrite+0xb4>
    31ac:	7b c0       	rjmp	.+246    	; 0x32a4 <glcd_CmdWrite+0x1aa>
	{
		_delay_ms(__us / 1000.0);
    31ae:	6d 89       	ldd	r22, Y+21	; 0x15
    31b0:	7e 89       	ldd	r23, Y+22	; 0x16
    31b2:	8f 89       	ldd	r24, Y+23	; 0x17
    31b4:	98 8d       	ldd	r25, Y+24	; 0x18
    31b6:	20 e0       	ldi	r18, 0x00	; 0
    31b8:	30 e0       	ldi	r19, 0x00	; 0
    31ba:	4a e7       	ldi	r20, 0x7A	; 122
    31bc:	54 e4       	ldi	r21, 0x44	; 68
    31be:	0e 94 f2 3d 	call	0x7be4	; 0x7be4 <__divsf3>
    31c2:	dc 01       	movw	r26, r24
    31c4:	cb 01       	movw	r24, r22
    31c6:	8c 87       	std	Y+12, r24	; 0x0c
    31c8:	9d 87       	std	Y+13, r25	; 0x0d
    31ca:	ae 87       	std	Y+14, r26	; 0x0e
    31cc:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    31ce:	6c 85       	ldd	r22, Y+12	; 0x0c
    31d0:	7d 85       	ldd	r23, Y+13	; 0x0d
    31d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    31d4:	9f 85       	ldd	r25, Y+15	; 0x0f
    31d6:	26 e6       	ldi	r18, 0x66	; 102
    31d8:	36 e6       	ldi	r19, 0x66	; 102
    31da:	46 e6       	ldi	r20, 0x66	; 102
    31dc:	55 e4       	ldi	r21, 0x45	; 69
    31de:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    31e2:	dc 01       	movw	r26, r24
    31e4:	cb 01       	movw	r24, r22
    31e6:	88 87       	std	Y+8, r24	; 0x08
    31e8:	99 87       	std	Y+9, r25	; 0x09
    31ea:	aa 87       	std	Y+10, r26	; 0x0a
    31ec:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    31ee:	68 85       	ldd	r22, Y+8	; 0x08
    31f0:	79 85       	ldd	r23, Y+9	; 0x09
    31f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    31f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    31f6:	20 e0       	ldi	r18, 0x00	; 0
    31f8:	30 e0       	ldi	r19, 0x00	; 0
    31fa:	40 e8       	ldi	r20, 0x80	; 128
    31fc:	5f e3       	ldi	r21, 0x3F	; 63
    31fe:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3202:	88 23       	and	r24, r24
    3204:	2c f4       	brge	.+10     	; 0x3210 <glcd_CmdWrite+0x116>
		__ticks = 1;
    3206:	81 e0       	ldi	r24, 0x01	; 1
    3208:	90 e0       	ldi	r25, 0x00	; 0
    320a:	9f 83       	std	Y+7, r25	; 0x07
    320c:	8e 83       	std	Y+6, r24	; 0x06
    320e:	3f c0       	rjmp	.+126    	; 0x328e <glcd_CmdWrite+0x194>
	else if (__tmp > 65535)
    3210:	68 85       	ldd	r22, Y+8	; 0x08
    3212:	79 85       	ldd	r23, Y+9	; 0x09
    3214:	8a 85       	ldd	r24, Y+10	; 0x0a
    3216:	9b 85       	ldd	r25, Y+11	; 0x0b
    3218:	20 e0       	ldi	r18, 0x00	; 0
    321a:	3f ef       	ldi	r19, 0xFF	; 255
    321c:	4f e7       	ldi	r20, 0x7F	; 127
    321e:	57 e4       	ldi	r21, 0x47	; 71
    3220:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3224:	18 16       	cp	r1, r24
    3226:	4c f5       	brge	.+82     	; 0x327a <glcd_CmdWrite+0x180>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3228:	6c 85       	ldd	r22, Y+12	; 0x0c
    322a:	7d 85       	ldd	r23, Y+13	; 0x0d
    322c:	8e 85       	ldd	r24, Y+14	; 0x0e
    322e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3230:	20 e0       	ldi	r18, 0x00	; 0
    3232:	30 e0       	ldi	r19, 0x00	; 0
    3234:	40 e2       	ldi	r20, 0x20	; 32
    3236:	51 e4       	ldi	r21, 0x41	; 65
    3238:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    323c:	dc 01       	movw	r26, r24
    323e:	cb 01       	movw	r24, r22
    3240:	bc 01       	movw	r22, r24
    3242:	cd 01       	movw	r24, r26
    3244:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3248:	dc 01       	movw	r26, r24
    324a:	cb 01       	movw	r24, r22
    324c:	9f 83       	std	Y+7, r25	; 0x07
    324e:	8e 83       	std	Y+6, r24	; 0x06
    3250:	0f c0       	rjmp	.+30     	; 0x3270 <glcd_CmdWrite+0x176>
    3252:	80 e7       	ldi	r24, 0x70	; 112
    3254:	91 e0       	ldi	r25, 0x01	; 1
    3256:	9d 83       	std	Y+5, r25	; 0x05
    3258:	8c 83       	std	Y+4, r24	; 0x04
    325a:	8c 81       	ldd	r24, Y+4	; 0x04
    325c:	9d 81       	ldd	r25, Y+5	; 0x05
    325e:	01 97       	sbiw	r24, 0x01	; 1
    3260:	f1 f7       	brne	.-4      	; 0x325e <glcd_CmdWrite+0x164>
    3262:	9d 83       	std	Y+5, r25	; 0x05
    3264:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3266:	8e 81       	ldd	r24, Y+6	; 0x06
    3268:	9f 81       	ldd	r25, Y+7	; 0x07
    326a:	01 97       	sbiw	r24, 0x01	; 1
    326c:	9f 83       	std	Y+7, r25	; 0x07
    326e:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3270:	8e 81       	ldd	r24, Y+6	; 0x06
    3272:	9f 81       	ldd	r25, Y+7	; 0x07
    3274:	00 97       	sbiw	r24, 0x00	; 0
    3276:	69 f7       	brne	.-38     	; 0x3252 <glcd_CmdWrite+0x158>
    3278:	24 c0       	rjmp	.+72     	; 0x32c2 <glcd_CmdWrite+0x1c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    327a:	68 85       	ldd	r22, Y+8	; 0x08
    327c:	79 85       	ldd	r23, Y+9	; 0x09
    327e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3280:	9b 85       	ldd	r25, Y+11	; 0x0b
    3282:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3286:	dc 01       	movw	r26, r24
    3288:	cb 01       	movw	r24, r22
    328a:	9f 83       	std	Y+7, r25	; 0x07
    328c:	8e 83       	std	Y+6, r24	; 0x06
    328e:	8e 81       	ldd	r24, Y+6	; 0x06
    3290:	9f 81       	ldd	r25, Y+7	; 0x07
    3292:	9b 83       	std	Y+3, r25	; 0x03
    3294:	8a 83       	std	Y+2, r24	; 0x02
    3296:	8a 81       	ldd	r24, Y+2	; 0x02
    3298:	9b 81       	ldd	r25, Y+3	; 0x03
    329a:	01 97       	sbiw	r24, 0x01	; 1
    329c:	f1 f7       	brne	.-4      	; 0x329a <glcd_CmdWrite+0x1a0>
    329e:	9b 83       	std	Y+3, r25	; 0x03
    32a0:	8a 83       	std	Y+2, r24	; 0x02
    32a2:	0f c0       	rjmp	.+30     	; 0x32c2 <glcd_CmdWrite+0x1c8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    32a4:	69 89       	ldd	r22, Y+17	; 0x11
    32a6:	7a 89       	ldd	r23, Y+18	; 0x12
    32a8:	8b 89       	ldd	r24, Y+19	; 0x13
    32aa:	9c 89       	ldd	r25, Y+20	; 0x14
    32ac:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    32b0:	dc 01       	movw	r26, r24
    32b2:	cb 01       	movw	r24, r22
    32b4:	88 8b       	std	Y+16, r24	; 0x10
    32b6:	88 89       	ldd	r24, Y+16	; 0x10
    32b8:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    32ba:	89 81       	ldd	r24, Y+1	; 0x01
    32bc:	8a 95       	dec	r24
    32be:	f1 f7       	brne	.-4      	; 0x32bc <glcd_CmdWrite+0x1c2>
    32c0:	89 83       	std	Y+1, r24	; 0x01
    DELAY_us(2);
    M_GlcdClearBit(M_GlcdControlBus,GLCD_EN);
    32c2:	ab e2       	ldi	r26, 0x2B	; 43
    32c4:	b0 e0       	ldi	r27, 0x00	; 0
    32c6:	eb e2       	ldi	r30, 0x2B	; 43
    32c8:	f0 e0       	ldi	r31, 0x00	; 0
    32ca:	80 81       	ld	r24, Z
    32cc:	8f 77       	andi	r24, 0x7F	; 127
    32ce:	8c 93       	st	X, r24
}
    32d0:	69 96       	adiw	r28, 0x19	; 25
    32d2:	0f b6       	in	r0, 0x3f	; 63
    32d4:	f8 94       	cli
    32d6:	de bf       	out	0x3e, r29	; 62
    32d8:	0f be       	out	0x3f, r0	; 63
    32da:	cd bf       	out	0x3d, r28	; 61
    32dc:	cf 91       	pop	r28
    32de:	df 91       	pop	r29
    32e0:	08 95       	ret

000032e2 <glcd_DataWrite>:
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void glcd_DataWrite( uint8_t var_data_u8)
{
    32e2:	df 93       	push	r29
    32e4:	cf 93       	push	r28
    32e6:	cd b7       	in	r28, 0x3d	; 61
    32e8:	de b7       	in	r29, 0x3e	; 62
    32ea:	69 97       	sbiw	r28, 0x19	; 25
    32ec:	0f b6       	in	r0, 0x3f	; 63
    32ee:	f8 94       	cli
    32f0:	de bf       	out	0x3e, r29	; 62
    32f2:	0f be       	out	0x3f, r0	; 63
    32f4:	cd bf       	out	0x3d, r28	; 61
    32f6:	89 8f       	std	Y+25, r24	; 0x19
    glcd_BusyCheck();
    32f8:	0e 94 65 1a 	call	0x34ca	; 0x34ca <glcd_BusyCheck>
    M_GlcdDataBus = var_data_u8 ;
    32fc:	e5 e0       	ldi	r30, 0x05	; 5
    32fe:	f1 e0       	ldi	r31, 0x01	; 1
    3300:	89 8d       	ldd	r24, Y+25	; 0x19
    3302:	80 83       	st	Z, r24
    M_GlcdSetBit(M_GlcdControlBus,GLCD_RS);           // Select the Data Register by pulling RS High
    3304:	ab e2       	ldi	r26, 0x2B	; 43
    3306:	b0 e0       	ldi	r27, 0x00	; 0
    3308:	eb e2       	ldi	r30, 0x2B	; 43
    330a:	f0 e0       	ldi	r31, 0x00	; 0
    330c:	80 81       	ld	r24, Z
    330e:	80 62       	ori	r24, 0x20	; 32
    3310:	8c 93       	st	X, r24
#ifdef GLCD_RW
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RW);           // Select the Write Operation  by pulling RW LOW
    3312:	ab e2       	ldi	r26, 0x2B	; 43
    3314:	b0 e0       	ldi	r27, 0x00	; 0
    3316:	eb e2       	ldi	r30, 0x2B	; 43
    3318:	f0 e0       	ldi	r31, 0x00	; 0
    331a:	80 81       	ld	r24, Z
    331c:	8f 7b       	andi	r24, 0xBF	; 191
    331e:	8c 93       	st	X, r24
#endif
    M_GlcdSetBit(M_GlcdControlBus,GLCD_EN);             // Send a High-to-Low Pulse at Enable Pin
    3320:	ab e2       	ldi	r26, 0x2B	; 43
    3322:	b0 e0       	ldi	r27, 0x00	; 0
    3324:	eb e2       	ldi	r30, 0x2B	; 43
    3326:	f0 e0       	ldi	r31, 0x00	; 0
    3328:	80 81       	ld	r24, Z
    332a:	80 68       	ori	r24, 0x80	; 128
    332c:	8c 93       	st	X, r24
    332e:	80 e0       	ldi	r24, 0x00	; 0
    3330:	90 e0       	ldi	r25, 0x00	; 0
    3332:	a0 e0       	ldi	r26, 0x00	; 0
    3334:	b0 e4       	ldi	r27, 0x40	; 64
    3336:	8d 8b       	std	Y+21, r24	; 0x15
    3338:	9e 8b       	std	Y+22, r25	; 0x16
    333a:	af 8b       	std	Y+23, r26	; 0x17
    333c:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    333e:	6d 89       	ldd	r22, Y+21	; 0x15
    3340:	7e 89       	ldd	r23, Y+22	; 0x16
    3342:	8f 89       	ldd	r24, Y+23	; 0x17
    3344:	98 8d       	ldd	r25, Y+24	; 0x18
    3346:	22 e5       	ldi	r18, 0x52	; 82
    3348:	39 e4       	ldi	r19, 0x49	; 73
    334a:	4d e9       	ldi	r20, 0x9D	; 157
    334c:	50 e4       	ldi	r21, 0x40	; 64
    334e:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3352:	dc 01       	movw	r26, r24
    3354:	cb 01       	movw	r24, r22
    3356:	89 8b       	std	Y+17, r24	; 0x11
    3358:	9a 8b       	std	Y+18, r25	; 0x12
    335a:	ab 8b       	std	Y+19, r26	; 0x13
    335c:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    335e:	69 89       	ldd	r22, Y+17	; 0x11
    3360:	7a 89       	ldd	r23, Y+18	; 0x12
    3362:	8b 89       	ldd	r24, Y+19	; 0x13
    3364:	9c 89       	ldd	r25, Y+20	; 0x14
    3366:	20 e0       	ldi	r18, 0x00	; 0
    3368:	30 e0       	ldi	r19, 0x00	; 0
    336a:	40 e8       	ldi	r20, 0x80	; 128
    336c:	5f e3       	ldi	r21, 0x3F	; 63
    336e:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3372:	88 23       	and	r24, r24
    3374:	1c f4       	brge	.+6      	; 0x337c <glcd_DataWrite+0x9a>
		__ticks = 1;
    3376:	81 e0       	ldi	r24, 0x01	; 1
    3378:	88 8b       	std	Y+16, r24	; 0x10
    337a:	91 c0       	rjmp	.+290    	; 0x349e <glcd_DataWrite+0x1bc>
	else if (__tmp > 255)
    337c:	69 89       	ldd	r22, Y+17	; 0x11
    337e:	7a 89       	ldd	r23, Y+18	; 0x12
    3380:	8b 89       	ldd	r24, Y+19	; 0x13
    3382:	9c 89       	ldd	r25, Y+20	; 0x14
    3384:	20 e0       	ldi	r18, 0x00	; 0
    3386:	30 e0       	ldi	r19, 0x00	; 0
    3388:	4f e7       	ldi	r20, 0x7F	; 127
    338a:	53 e4       	ldi	r21, 0x43	; 67
    338c:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3390:	18 16       	cp	r1, r24
    3392:	0c f0       	brlt	.+2      	; 0x3396 <glcd_DataWrite+0xb4>
    3394:	7b c0       	rjmp	.+246    	; 0x348c <glcd_DataWrite+0x1aa>
	{
		_delay_ms(__us / 1000.0);
    3396:	6d 89       	ldd	r22, Y+21	; 0x15
    3398:	7e 89       	ldd	r23, Y+22	; 0x16
    339a:	8f 89       	ldd	r24, Y+23	; 0x17
    339c:	98 8d       	ldd	r25, Y+24	; 0x18
    339e:	20 e0       	ldi	r18, 0x00	; 0
    33a0:	30 e0       	ldi	r19, 0x00	; 0
    33a2:	4a e7       	ldi	r20, 0x7A	; 122
    33a4:	54 e4       	ldi	r21, 0x44	; 68
    33a6:	0e 94 f2 3d 	call	0x7be4	; 0x7be4 <__divsf3>
    33aa:	dc 01       	movw	r26, r24
    33ac:	cb 01       	movw	r24, r22
    33ae:	8c 87       	std	Y+12, r24	; 0x0c
    33b0:	9d 87       	std	Y+13, r25	; 0x0d
    33b2:	ae 87       	std	Y+14, r26	; 0x0e
    33b4:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    33b6:	6c 85       	ldd	r22, Y+12	; 0x0c
    33b8:	7d 85       	ldd	r23, Y+13	; 0x0d
    33ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    33bc:	9f 85       	ldd	r25, Y+15	; 0x0f
    33be:	26 e6       	ldi	r18, 0x66	; 102
    33c0:	36 e6       	ldi	r19, 0x66	; 102
    33c2:	46 e6       	ldi	r20, 0x66	; 102
    33c4:	55 e4       	ldi	r21, 0x45	; 69
    33c6:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    33ca:	dc 01       	movw	r26, r24
    33cc:	cb 01       	movw	r24, r22
    33ce:	88 87       	std	Y+8, r24	; 0x08
    33d0:	99 87       	std	Y+9, r25	; 0x09
    33d2:	aa 87       	std	Y+10, r26	; 0x0a
    33d4:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    33d6:	68 85       	ldd	r22, Y+8	; 0x08
    33d8:	79 85       	ldd	r23, Y+9	; 0x09
    33da:	8a 85       	ldd	r24, Y+10	; 0x0a
    33dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    33de:	20 e0       	ldi	r18, 0x00	; 0
    33e0:	30 e0       	ldi	r19, 0x00	; 0
    33e2:	40 e8       	ldi	r20, 0x80	; 128
    33e4:	5f e3       	ldi	r21, 0x3F	; 63
    33e6:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    33ea:	88 23       	and	r24, r24
    33ec:	2c f4       	brge	.+10     	; 0x33f8 <glcd_DataWrite+0x116>
		__ticks = 1;
    33ee:	81 e0       	ldi	r24, 0x01	; 1
    33f0:	90 e0       	ldi	r25, 0x00	; 0
    33f2:	9f 83       	std	Y+7, r25	; 0x07
    33f4:	8e 83       	std	Y+6, r24	; 0x06
    33f6:	3f c0       	rjmp	.+126    	; 0x3476 <glcd_DataWrite+0x194>
	else if (__tmp > 65535)
    33f8:	68 85       	ldd	r22, Y+8	; 0x08
    33fa:	79 85       	ldd	r23, Y+9	; 0x09
    33fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    33fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    3400:	20 e0       	ldi	r18, 0x00	; 0
    3402:	3f ef       	ldi	r19, 0xFF	; 255
    3404:	4f e7       	ldi	r20, 0x7F	; 127
    3406:	57 e4       	ldi	r21, 0x47	; 71
    3408:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    340c:	18 16       	cp	r1, r24
    340e:	4c f5       	brge	.+82     	; 0x3462 <glcd_DataWrite+0x180>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3410:	6c 85       	ldd	r22, Y+12	; 0x0c
    3412:	7d 85       	ldd	r23, Y+13	; 0x0d
    3414:	8e 85       	ldd	r24, Y+14	; 0x0e
    3416:	9f 85       	ldd	r25, Y+15	; 0x0f
    3418:	20 e0       	ldi	r18, 0x00	; 0
    341a:	30 e0       	ldi	r19, 0x00	; 0
    341c:	40 e2       	ldi	r20, 0x20	; 32
    341e:	51 e4       	ldi	r21, 0x41	; 65
    3420:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3424:	dc 01       	movw	r26, r24
    3426:	cb 01       	movw	r24, r22
    3428:	bc 01       	movw	r22, r24
    342a:	cd 01       	movw	r24, r26
    342c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3430:	dc 01       	movw	r26, r24
    3432:	cb 01       	movw	r24, r22
    3434:	9f 83       	std	Y+7, r25	; 0x07
    3436:	8e 83       	std	Y+6, r24	; 0x06
    3438:	0f c0       	rjmp	.+30     	; 0x3458 <glcd_DataWrite+0x176>
    343a:	80 e7       	ldi	r24, 0x70	; 112
    343c:	91 e0       	ldi	r25, 0x01	; 1
    343e:	9d 83       	std	Y+5, r25	; 0x05
    3440:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3442:	8c 81       	ldd	r24, Y+4	; 0x04
    3444:	9d 81       	ldd	r25, Y+5	; 0x05
    3446:	01 97       	sbiw	r24, 0x01	; 1
    3448:	f1 f7       	brne	.-4      	; 0x3446 <glcd_DataWrite+0x164>
    344a:	9d 83       	std	Y+5, r25	; 0x05
    344c:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    344e:	8e 81       	ldd	r24, Y+6	; 0x06
    3450:	9f 81       	ldd	r25, Y+7	; 0x07
    3452:	01 97       	sbiw	r24, 0x01	; 1
    3454:	9f 83       	std	Y+7, r25	; 0x07
    3456:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3458:	8e 81       	ldd	r24, Y+6	; 0x06
    345a:	9f 81       	ldd	r25, Y+7	; 0x07
    345c:	00 97       	sbiw	r24, 0x00	; 0
    345e:	69 f7       	brne	.-38     	; 0x343a <glcd_DataWrite+0x158>
    3460:	24 c0       	rjmp	.+72     	; 0x34aa <glcd_DataWrite+0x1c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3462:	68 85       	ldd	r22, Y+8	; 0x08
    3464:	79 85       	ldd	r23, Y+9	; 0x09
    3466:	8a 85       	ldd	r24, Y+10	; 0x0a
    3468:	9b 85       	ldd	r25, Y+11	; 0x0b
    346a:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    346e:	dc 01       	movw	r26, r24
    3470:	cb 01       	movw	r24, r22
    3472:	9f 83       	std	Y+7, r25	; 0x07
    3474:	8e 83       	std	Y+6, r24	; 0x06
    3476:	8e 81       	ldd	r24, Y+6	; 0x06
    3478:	9f 81       	ldd	r25, Y+7	; 0x07
    347a:	9b 83       	std	Y+3, r25	; 0x03
    347c:	8a 83       	std	Y+2, r24	; 0x02
    347e:	8a 81       	ldd	r24, Y+2	; 0x02
    3480:	9b 81       	ldd	r25, Y+3	; 0x03
    3482:	01 97       	sbiw	r24, 0x01	; 1
    3484:	f1 f7       	brne	.-4      	; 0x3482 <glcd_DataWrite+0x1a0>
    3486:	9b 83       	std	Y+3, r25	; 0x03
    3488:	8a 83       	std	Y+2, r24	; 0x02
    348a:	0f c0       	rjmp	.+30     	; 0x34aa <glcd_DataWrite+0x1c8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    348c:	69 89       	ldd	r22, Y+17	; 0x11
    348e:	7a 89       	ldd	r23, Y+18	; 0x12
    3490:	8b 89       	ldd	r24, Y+19	; 0x13
    3492:	9c 89       	ldd	r25, Y+20	; 0x14
    3494:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3498:	dc 01       	movw	r26, r24
    349a:	cb 01       	movw	r24, r22
    349c:	88 8b       	std	Y+16, r24	; 0x10
    349e:	88 89       	ldd	r24, Y+16	; 0x10
    34a0:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    34a2:	89 81       	ldd	r24, Y+1	; 0x01
    34a4:	8a 95       	dec	r24
    34a6:	f1 f7       	brne	.-4      	; 0x34a4 <glcd_DataWrite+0x1c2>
    34a8:	89 83       	std	Y+1, r24	; 0x01
    DELAY_us(2);
    M_GlcdClearBit(M_GlcdControlBus,GLCD_EN);
    34aa:	ab e2       	ldi	r26, 0x2B	; 43
    34ac:	b0 e0       	ldi	r27, 0x00	; 0
    34ae:	eb e2       	ldi	r30, 0x2B	; 43
    34b0:	f0 e0       	ldi	r31, 0x00	; 0
    34b2:	80 81       	ld	r24, Z
    34b4:	8f 77       	andi	r24, 0x7F	; 127
    34b6:	8c 93       	st	X, r24
}
    34b8:	69 96       	adiw	r28, 0x19	; 25
    34ba:	0f b6       	in	r0, 0x3f	; 63
    34bc:	f8 94       	cli
    34be:	de bf       	out	0x3e, r29	; 62
    34c0:	0f be       	out	0x3f, r0	; 63
    34c2:	cd bf       	out	0x3d, r28	; 61
    34c4:	cf 91       	pop	r28
    34c6:	df 91       	pop	r29
    34c8:	08 95       	ret

000034ca <glcd_BusyCheck>:
 * description : This functions is used check whether LCD is busy.
                 It waits till the LCD is busy by polling the LCD busy flag.
                 After completing the previous operation, LCDs clears its internal busy flag.
 *************************************************************************************************/
static void glcd_BusyCheck()
{
    34ca:	df 93       	push	r29
    34cc:	cf 93       	push	r28
    34ce:	cd b7       	in	r28, 0x3d	; 61
    34d0:	de b7       	in	r29, 0x3e	; 62
    34d2:	e1 97       	sbiw	r28, 0x31	; 49
    34d4:	0f b6       	in	r0, 0x3f	; 63
    34d6:	f8 94       	cli
    34d8:	de bf       	out	0x3e, r29	; 62
    34da:	0f be       	out	0x3f, r0	; 63
    34dc:	cd bf       	out	0x3d, r28	; 61
    uint8_t busyflag;
    
#ifdef GLCD_RW                    //Perform Busy check if GLCD_RW pin is used

    util_UpdateBit(M_GlcdDataBusDirection,GLCD_D7,C_PinInput_U8); // Configure busy pin as input
    34de:	a4 e0       	ldi	r26, 0x04	; 4
    34e0:	b1 e0       	ldi	r27, 0x01	; 1
    34e2:	e4 e0       	ldi	r30, 0x04	; 4
    34e4:	f1 e0       	ldi	r31, 0x01	; 1
    34e6:	80 81       	ld	r24, Z
    34e8:	8f 77       	andi	r24, 0x7F	; 127
    34ea:	8c 93       	st	X, r24
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RS);           // Select the Command Register by pulling RS LOW
    34ec:	ab e2       	ldi	r26, 0x2B	; 43
    34ee:	b0 e0       	ldi	r27, 0x00	; 0
    34f0:	eb e2       	ldi	r30, 0x2B	; 43
    34f2:	f0 e0       	ldi	r31, 0x00	; 0
    34f4:	80 81       	ld	r24, Z
    34f6:	8f 7d       	andi	r24, 0xDF	; 223
    34f8:	8c 93       	st	X, r24
    M_GlcdSetBit(M_GlcdControlBus,GLCD_RW);             // Select the Read Operation for busy flag by setting RW
    34fa:	ab e2       	ldi	r26, 0x2B	; 43
    34fc:	b0 e0       	ldi	r27, 0x00	; 0
    34fe:	eb e2       	ldi	r30, 0x2B	; 43
    3500:	f0 e0       	ldi	r31, 0x00	; 0
    3502:	80 81       	ld	r24, Z
    3504:	80 64       	ori	r24, 0x40	; 64
    3506:	8c 93       	st	X, r24
    do
    {
        M_GlcdClearBit(M_GlcdControlBus,GLCD_EN);             // Send a High-to-Low Pulse at Enable Pin
    3508:	ab e2       	ldi	r26, 0x2B	; 43
    350a:	b0 e0       	ldi	r27, 0x00	; 0
    350c:	eb e2       	ldi	r30, 0x2B	; 43
    350e:	f0 e0       	ldi	r31, 0x00	; 0
    3510:	80 81       	ld	r24, Z
    3512:	8f 77       	andi	r24, 0x7F	; 127
    3514:	8c 93       	st	X, r24
    3516:	80 e0       	ldi	r24, 0x00	; 0
    3518:	90 e0       	ldi	r25, 0x00	; 0
    351a:	a0 e0       	ldi	r26, 0x00	; 0
    351c:	b0 e4       	ldi	r27, 0x40	; 64
    351e:	8d a7       	std	Y+45, r24	; 0x2d
    3520:	9e a7       	std	Y+46, r25	; 0x2e
    3522:	af a7       	std	Y+47, r26	; 0x2f
    3524:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3526:	6d a5       	ldd	r22, Y+45	; 0x2d
    3528:	7e a5       	ldd	r23, Y+46	; 0x2e
    352a:	8f a5       	ldd	r24, Y+47	; 0x2f
    352c:	98 a9       	ldd	r25, Y+48	; 0x30
    352e:	22 e5       	ldi	r18, 0x52	; 82
    3530:	39 e4       	ldi	r19, 0x49	; 73
    3532:	4d e9       	ldi	r20, 0x9D	; 157
    3534:	50 e4       	ldi	r21, 0x40	; 64
    3536:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    353a:	dc 01       	movw	r26, r24
    353c:	cb 01       	movw	r24, r22
    353e:	89 a7       	std	Y+41, r24	; 0x29
    3540:	9a a7       	std	Y+42, r25	; 0x2a
    3542:	ab a7       	std	Y+43, r26	; 0x2b
    3544:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    3546:	69 a5       	ldd	r22, Y+41	; 0x29
    3548:	7a a5       	ldd	r23, Y+42	; 0x2a
    354a:	8b a5       	ldd	r24, Y+43	; 0x2b
    354c:	9c a5       	ldd	r25, Y+44	; 0x2c
    354e:	20 e0       	ldi	r18, 0x00	; 0
    3550:	30 e0       	ldi	r19, 0x00	; 0
    3552:	40 e8       	ldi	r20, 0x80	; 128
    3554:	5f e3       	ldi	r21, 0x3F	; 63
    3556:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    355a:	88 23       	and	r24, r24
    355c:	1c f4       	brge	.+6      	; 0x3564 <glcd_BusyCheck+0x9a>
		__ticks = 1;
    355e:	81 e0       	ldi	r24, 0x01	; 1
    3560:	88 a7       	std	Y+40, r24	; 0x28
    3562:	91 c0       	rjmp	.+290    	; 0x3686 <glcd_BusyCheck+0x1bc>
	else if (__tmp > 255)
    3564:	69 a5       	ldd	r22, Y+41	; 0x29
    3566:	7a a5       	ldd	r23, Y+42	; 0x2a
    3568:	8b a5       	ldd	r24, Y+43	; 0x2b
    356a:	9c a5       	ldd	r25, Y+44	; 0x2c
    356c:	20 e0       	ldi	r18, 0x00	; 0
    356e:	30 e0       	ldi	r19, 0x00	; 0
    3570:	4f e7       	ldi	r20, 0x7F	; 127
    3572:	53 e4       	ldi	r21, 0x43	; 67
    3574:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3578:	18 16       	cp	r1, r24
    357a:	0c f0       	brlt	.+2      	; 0x357e <glcd_BusyCheck+0xb4>
    357c:	7b c0       	rjmp	.+246    	; 0x3674 <glcd_BusyCheck+0x1aa>
	{
		_delay_ms(__us / 1000.0);
    357e:	6d a5       	ldd	r22, Y+45	; 0x2d
    3580:	7e a5       	ldd	r23, Y+46	; 0x2e
    3582:	8f a5       	ldd	r24, Y+47	; 0x2f
    3584:	98 a9       	ldd	r25, Y+48	; 0x30
    3586:	20 e0       	ldi	r18, 0x00	; 0
    3588:	30 e0       	ldi	r19, 0x00	; 0
    358a:	4a e7       	ldi	r20, 0x7A	; 122
    358c:	54 e4       	ldi	r21, 0x44	; 68
    358e:	0e 94 f2 3d 	call	0x7be4	; 0x7be4 <__divsf3>
    3592:	dc 01       	movw	r26, r24
    3594:	cb 01       	movw	r24, r22
    3596:	8c a3       	std	Y+36, r24	; 0x24
    3598:	9d a3       	std	Y+37, r25	; 0x25
    359a:	ae a3       	std	Y+38, r26	; 0x26
    359c:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    359e:	6c a1       	ldd	r22, Y+36	; 0x24
    35a0:	7d a1       	ldd	r23, Y+37	; 0x25
    35a2:	8e a1       	ldd	r24, Y+38	; 0x26
    35a4:	9f a1       	ldd	r25, Y+39	; 0x27
    35a6:	26 e6       	ldi	r18, 0x66	; 102
    35a8:	36 e6       	ldi	r19, 0x66	; 102
    35aa:	46 e6       	ldi	r20, 0x66	; 102
    35ac:	55 e4       	ldi	r21, 0x45	; 69
    35ae:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    35b2:	dc 01       	movw	r26, r24
    35b4:	cb 01       	movw	r24, r22
    35b6:	88 a3       	std	Y+32, r24	; 0x20
    35b8:	99 a3       	std	Y+33, r25	; 0x21
    35ba:	aa a3       	std	Y+34, r26	; 0x22
    35bc:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    35be:	68 a1       	ldd	r22, Y+32	; 0x20
    35c0:	79 a1       	ldd	r23, Y+33	; 0x21
    35c2:	8a a1       	ldd	r24, Y+34	; 0x22
    35c4:	9b a1       	ldd	r25, Y+35	; 0x23
    35c6:	20 e0       	ldi	r18, 0x00	; 0
    35c8:	30 e0       	ldi	r19, 0x00	; 0
    35ca:	40 e8       	ldi	r20, 0x80	; 128
    35cc:	5f e3       	ldi	r21, 0x3F	; 63
    35ce:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    35d2:	88 23       	and	r24, r24
    35d4:	2c f4       	brge	.+10     	; 0x35e0 <glcd_BusyCheck+0x116>
		__ticks = 1;
    35d6:	81 e0       	ldi	r24, 0x01	; 1
    35d8:	90 e0       	ldi	r25, 0x00	; 0
    35da:	9f 8f       	std	Y+31, r25	; 0x1f
    35dc:	8e 8f       	std	Y+30, r24	; 0x1e
    35de:	3f c0       	rjmp	.+126    	; 0x365e <glcd_BusyCheck+0x194>
	else if (__tmp > 65535)
    35e0:	68 a1       	ldd	r22, Y+32	; 0x20
    35e2:	79 a1       	ldd	r23, Y+33	; 0x21
    35e4:	8a a1       	ldd	r24, Y+34	; 0x22
    35e6:	9b a1       	ldd	r25, Y+35	; 0x23
    35e8:	20 e0       	ldi	r18, 0x00	; 0
    35ea:	3f ef       	ldi	r19, 0xFF	; 255
    35ec:	4f e7       	ldi	r20, 0x7F	; 127
    35ee:	57 e4       	ldi	r21, 0x47	; 71
    35f0:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    35f4:	18 16       	cp	r1, r24
    35f6:	4c f5       	brge	.+82     	; 0x364a <glcd_BusyCheck+0x180>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    35f8:	6c a1       	ldd	r22, Y+36	; 0x24
    35fa:	7d a1       	ldd	r23, Y+37	; 0x25
    35fc:	8e a1       	ldd	r24, Y+38	; 0x26
    35fe:	9f a1       	ldd	r25, Y+39	; 0x27
    3600:	20 e0       	ldi	r18, 0x00	; 0
    3602:	30 e0       	ldi	r19, 0x00	; 0
    3604:	40 e2       	ldi	r20, 0x20	; 32
    3606:	51 e4       	ldi	r21, 0x41	; 65
    3608:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    360c:	dc 01       	movw	r26, r24
    360e:	cb 01       	movw	r24, r22
    3610:	bc 01       	movw	r22, r24
    3612:	cd 01       	movw	r24, r26
    3614:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3618:	dc 01       	movw	r26, r24
    361a:	cb 01       	movw	r24, r22
    361c:	9f 8f       	std	Y+31, r25	; 0x1f
    361e:	8e 8f       	std	Y+30, r24	; 0x1e
    3620:	0f c0       	rjmp	.+30     	; 0x3640 <glcd_BusyCheck+0x176>
    3622:	80 e7       	ldi	r24, 0x70	; 112
    3624:	91 e0       	ldi	r25, 0x01	; 1
    3626:	9d 8f       	std	Y+29, r25	; 0x1d
    3628:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    362a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    362c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    362e:	01 97       	sbiw	r24, 0x01	; 1
    3630:	f1 f7       	brne	.-4      	; 0x362e <glcd_BusyCheck+0x164>
    3632:	9d 8f       	std	Y+29, r25	; 0x1d
    3634:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3636:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3638:	9f 8d       	ldd	r25, Y+31	; 0x1f
    363a:	01 97       	sbiw	r24, 0x01	; 1
    363c:	9f 8f       	std	Y+31, r25	; 0x1f
    363e:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3640:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3642:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3644:	00 97       	sbiw	r24, 0x00	; 0
    3646:	69 f7       	brne	.-38     	; 0x3622 <glcd_BusyCheck+0x158>
    3648:	24 c0       	rjmp	.+72     	; 0x3692 <glcd_BusyCheck+0x1c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    364a:	68 a1       	ldd	r22, Y+32	; 0x20
    364c:	79 a1       	ldd	r23, Y+33	; 0x21
    364e:	8a a1       	ldd	r24, Y+34	; 0x22
    3650:	9b a1       	ldd	r25, Y+35	; 0x23
    3652:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3656:	dc 01       	movw	r26, r24
    3658:	cb 01       	movw	r24, r22
    365a:	9f 8f       	std	Y+31, r25	; 0x1f
    365c:	8e 8f       	std	Y+30, r24	; 0x1e
    365e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3660:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3662:	9b 8f       	std	Y+27, r25	; 0x1b
    3664:	8a 8f       	std	Y+26, r24	; 0x1a
    3666:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3668:	9b 8d       	ldd	r25, Y+27	; 0x1b
    366a:	01 97       	sbiw	r24, 0x01	; 1
    366c:	f1 f7       	brne	.-4      	; 0x366a <glcd_BusyCheck+0x1a0>
    366e:	9b 8f       	std	Y+27, r25	; 0x1b
    3670:	8a 8f       	std	Y+26, r24	; 0x1a
    3672:	0f c0       	rjmp	.+30     	; 0x3692 <glcd_BusyCheck+0x1c8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3674:	69 a5       	ldd	r22, Y+41	; 0x29
    3676:	7a a5       	ldd	r23, Y+42	; 0x2a
    3678:	8b a5       	ldd	r24, Y+43	; 0x2b
    367a:	9c a5       	ldd	r25, Y+44	; 0x2c
    367c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3680:	dc 01       	movw	r26, r24
    3682:	cb 01       	movw	r24, r22
    3684:	88 a7       	std	Y+40, r24	; 0x28
    3686:	88 a5       	ldd	r24, Y+40	; 0x28
    3688:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    368a:	89 8d       	ldd	r24, Y+25	; 0x19
    368c:	8a 95       	dec	r24
    368e:	f1 f7       	brne	.-4      	; 0x368c <glcd_BusyCheck+0x1c2>
    3690:	89 8f       	std	Y+25, r24	; 0x19
        DELAY_us(2);    
        M_GlcdSetBit(M_GlcdControlBus,GLCD_EN);
    3692:	ab e2       	ldi	r26, 0x2B	; 43
    3694:	b0 e0       	ldi	r27, 0x00	; 0
    3696:	eb e2       	ldi	r30, 0x2B	; 43
    3698:	f0 e0       	ldi	r31, 0x00	; 0
    369a:	80 81       	ld	r24, Z
    369c:	80 68       	ori	r24, 0x80	; 128
    369e:	8c 93       	st	X, r24
    36a0:	80 e0       	ldi	r24, 0x00	; 0
    36a2:	90 e0       	ldi	r25, 0x00	; 0
    36a4:	a0 e0       	ldi	r26, 0x00	; 0
    36a6:	b0 e4       	ldi	r27, 0x40	; 64
    36a8:	8d 8b       	std	Y+21, r24	; 0x15
    36aa:	9e 8b       	std	Y+22, r25	; 0x16
    36ac:	af 8b       	std	Y+23, r26	; 0x17
    36ae:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    36b0:	6d 89       	ldd	r22, Y+21	; 0x15
    36b2:	7e 89       	ldd	r23, Y+22	; 0x16
    36b4:	8f 89       	ldd	r24, Y+23	; 0x17
    36b6:	98 8d       	ldd	r25, Y+24	; 0x18
    36b8:	22 e5       	ldi	r18, 0x52	; 82
    36ba:	39 e4       	ldi	r19, 0x49	; 73
    36bc:	4d e9       	ldi	r20, 0x9D	; 157
    36be:	50 e4       	ldi	r21, 0x40	; 64
    36c0:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    36c4:	dc 01       	movw	r26, r24
    36c6:	cb 01       	movw	r24, r22
    36c8:	89 8b       	std	Y+17, r24	; 0x11
    36ca:	9a 8b       	std	Y+18, r25	; 0x12
    36cc:	ab 8b       	std	Y+19, r26	; 0x13
    36ce:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    36d0:	69 89       	ldd	r22, Y+17	; 0x11
    36d2:	7a 89       	ldd	r23, Y+18	; 0x12
    36d4:	8b 89       	ldd	r24, Y+19	; 0x13
    36d6:	9c 89       	ldd	r25, Y+20	; 0x14
    36d8:	20 e0       	ldi	r18, 0x00	; 0
    36da:	30 e0       	ldi	r19, 0x00	; 0
    36dc:	40 e8       	ldi	r20, 0x80	; 128
    36de:	5f e3       	ldi	r21, 0x3F	; 63
    36e0:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    36e4:	88 23       	and	r24, r24
    36e6:	1c f4       	brge	.+6      	; 0x36ee <glcd_BusyCheck+0x224>
		__ticks = 1;
    36e8:	81 e0       	ldi	r24, 0x01	; 1
    36ea:	88 8b       	std	Y+16, r24	; 0x10
    36ec:	91 c0       	rjmp	.+290    	; 0x3810 <glcd_BusyCheck+0x346>
	else if (__tmp > 255)
    36ee:	69 89       	ldd	r22, Y+17	; 0x11
    36f0:	7a 89       	ldd	r23, Y+18	; 0x12
    36f2:	8b 89       	ldd	r24, Y+19	; 0x13
    36f4:	9c 89       	ldd	r25, Y+20	; 0x14
    36f6:	20 e0       	ldi	r18, 0x00	; 0
    36f8:	30 e0       	ldi	r19, 0x00	; 0
    36fa:	4f e7       	ldi	r20, 0x7F	; 127
    36fc:	53 e4       	ldi	r21, 0x43	; 67
    36fe:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3702:	18 16       	cp	r1, r24
    3704:	0c f0       	brlt	.+2      	; 0x3708 <glcd_BusyCheck+0x23e>
    3706:	7b c0       	rjmp	.+246    	; 0x37fe <glcd_BusyCheck+0x334>
	{
		_delay_ms(__us / 1000.0);
    3708:	6d 89       	ldd	r22, Y+21	; 0x15
    370a:	7e 89       	ldd	r23, Y+22	; 0x16
    370c:	8f 89       	ldd	r24, Y+23	; 0x17
    370e:	98 8d       	ldd	r25, Y+24	; 0x18
    3710:	20 e0       	ldi	r18, 0x00	; 0
    3712:	30 e0       	ldi	r19, 0x00	; 0
    3714:	4a e7       	ldi	r20, 0x7A	; 122
    3716:	54 e4       	ldi	r21, 0x44	; 68
    3718:	0e 94 f2 3d 	call	0x7be4	; 0x7be4 <__divsf3>
    371c:	dc 01       	movw	r26, r24
    371e:	cb 01       	movw	r24, r22
    3720:	8c 87       	std	Y+12, r24	; 0x0c
    3722:	9d 87       	std	Y+13, r25	; 0x0d
    3724:	ae 87       	std	Y+14, r26	; 0x0e
    3726:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3728:	6c 85       	ldd	r22, Y+12	; 0x0c
    372a:	7d 85       	ldd	r23, Y+13	; 0x0d
    372c:	8e 85       	ldd	r24, Y+14	; 0x0e
    372e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3730:	26 e6       	ldi	r18, 0x66	; 102
    3732:	36 e6       	ldi	r19, 0x66	; 102
    3734:	46 e6       	ldi	r20, 0x66	; 102
    3736:	55 e4       	ldi	r21, 0x45	; 69
    3738:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    373c:	dc 01       	movw	r26, r24
    373e:	cb 01       	movw	r24, r22
    3740:	88 87       	std	Y+8, r24	; 0x08
    3742:	99 87       	std	Y+9, r25	; 0x09
    3744:	aa 87       	std	Y+10, r26	; 0x0a
    3746:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    3748:	68 85       	ldd	r22, Y+8	; 0x08
    374a:	79 85       	ldd	r23, Y+9	; 0x09
    374c:	8a 85       	ldd	r24, Y+10	; 0x0a
    374e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3750:	20 e0       	ldi	r18, 0x00	; 0
    3752:	30 e0       	ldi	r19, 0x00	; 0
    3754:	40 e8       	ldi	r20, 0x80	; 128
    3756:	5f e3       	ldi	r21, 0x3F	; 63
    3758:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    375c:	88 23       	and	r24, r24
    375e:	2c f4       	brge	.+10     	; 0x376a <glcd_BusyCheck+0x2a0>
		__ticks = 1;
    3760:	81 e0       	ldi	r24, 0x01	; 1
    3762:	90 e0       	ldi	r25, 0x00	; 0
    3764:	9f 83       	std	Y+7, r25	; 0x07
    3766:	8e 83       	std	Y+6, r24	; 0x06
    3768:	3f c0       	rjmp	.+126    	; 0x37e8 <glcd_BusyCheck+0x31e>
	else if (__tmp > 65535)
    376a:	68 85       	ldd	r22, Y+8	; 0x08
    376c:	79 85       	ldd	r23, Y+9	; 0x09
    376e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3770:	9b 85       	ldd	r25, Y+11	; 0x0b
    3772:	20 e0       	ldi	r18, 0x00	; 0
    3774:	3f ef       	ldi	r19, 0xFF	; 255
    3776:	4f e7       	ldi	r20, 0x7F	; 127
    3778:	57 e4       	ldi	r21, 0x47	; 71
    377a:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    377e:	18 16       	cp	r1, r24
    3780:	4c f5       	brge	.+82     	; 0x37d4 <glcd_BusyCheck+0x30a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3782:	6c 85       	ldd	r22, Y+12	; 0x0c
    3784:	7d 85       	ldd	r23, Y+13	; 0x0d
    3786:	8e 85       	ldd	r24, Y+14	; 0x0e
    3788:	9f 85       	ldd	r25, Y+15	; 0x0f
    378a:	20 e0       	ldi	r18, 0x00	; 0
    378c:	30 e0       	ldi	r19, 0x00	; 0
    378e:	40 e2       	ldi	r20, 0x20	; 32
    3790:	51 e4       	ldi	r21, 0x41	; 65
    3792:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3796:	dc 01       	movw	r26, r24
    3798:	cb 01       	movw	r24, r22
    379a:	bc 01       	movw	r22, r24
    379c:	cd 01       	movw	r24, r26
    379e:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    37a2:	dc 01       	movw	r26, r24
    37a4:	cb 01       	movw	r24, r22
    37a6:	9f 83       	std	Y+7, r25	; 0x07
    37a8:	8e 83       	std	Y+6, r24	; 0x06
    37aa:	0f c0       	rjmp	.+30     	; 0x37ca <glcd_BusyCheck+0x300>
    37ac:	80 e7       	ldi	r24, 0x70	; 112
    37ae:	91 e0       	ldi	r25, 0x01	; 1
    37b0:	9d 83       	std	Y+5, r25	; 0x05
    37b2:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    37b4:	8c 81       	ldd	r24, Y+4	; 0x04
    37b6:	9d 81       	ldd	r25, Y+5	; 0x05
    37b8:	01 97       	sbiw	r24, 0x01	; 1
    37ba:	f1 f7       	brne	.-4      	; 0x37b8 <glcd_BusyCheck+0x2ee>
    37bc:	9d 83       	std	Y+5, r25	; 0x05
    37be:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    37c0:	8e 81       	ldd	r24, Y+6	; 0x06
    37c2:	9f 81       	ldd	r25, Y+7	; 0x07
    37c4:	01 97       	sbiw	r24, 0x01	; 1
    37c6:	9f 83       	std	Y+7, r25	; 0x07
    37c8:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37ca:	8e 81       	ldd	r24, Y+6	; 0x06
    37cc:	9f 81       	ldd	r25, Y+7	; 0x07
    37ce:	00 97       	sbiw	r24, 0x00	; 0
    37d0:	69 f7       	brne	.-38     	; 0x37ac <glcd_BusyCheck+0x2e2>
    37d2:	24 c0       	rjmp	.+72     	; 0x381c <glcd_BusyCheck+0x352>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    37d4:	68 85       	ldd	r22, Y+8	; 0x08
    37d6:	79 85       	ldd	r23, Y+9	; 0x09
    37d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    37da:	9b 85       	ldd	r25, Y+11	; 0x0b
    37dc:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    37e0:	dc 01       	movw	r26, r24
    37e2:	cb 01       	movw	r24, r22
    37e4:	9f 83       	std	Y+7, r25	; 0x07
    37e6:	8e 83       	std	Y+6, r24	; 0x06
    37e8:	8e 81       	ldd	r24, Y+6	; 0x06
    37ea:	9f 81       	ldd	r25, Y+7	; 0x07
    37ec:	9b 83       	std	Y+3, r25	; 0x03
    37ee:	8a 83       	std	Y+2, r24	; 0x02
    37f0:	8a 81       	ldd	r24, Y+2	; 0x02
    37f2:	9b 81       	ldd	r25, Y+3	; 0x03
    37f4:	01 97       	sbiw	r24, 0x01	; 1
    37f6:	f1 f7       	brne	.-4      	; 0x37f4 <glcd_BusyCheck+0x32a>
    37f8:	9b 83       	std	Y+3, r25	; 0x03
    37fa:	8a 83       	std	Y+2, r24	; 0x02
    37fc:	0f c0       	rjmp	.+30     	; 0x381c <glcd_BusyCheck+0x352>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    37fe:	69 89       	ldd	r22, Y+17	; 0x11
    3800:	7a 89       	ldd	r23, Y+18	; 0x12
    3802:	8b 89       	ldd	r24, Y+19	; 0x13
    3804:	9c 89       	ldd	r25, Y+20	; 0x14
    3806:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    380a:	dc 01       	movw	r26, r24
    380c:	cb 01       	movw	r24, r22
    380e:	88 8b       	std	Y+16, r24	; 0x10
    3810:	88 89       	ldd	r24, Y+16	; 0x10
    3812:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3814:	89 81       	ldd	r24, Y+1	; 0x01
    3816:	8a 95       	dec	r24
    3818:	f1 f7       	brne	.-4      	; 0x3816 <glcd_BusyCheck+0x34c>
    381a:	89 83       	std	Y+1, r24	; 0x01
        DELAY_us(2);
        busyflag = util_GetBitStatus(M_GlcdDataBusInput,GLCD_D7);
    381c:	e3 e0       	ldi	r30, 0x03	; 3
    381e:	f1 e0       	ldi	r31, 0x01	; 1
    3820:	80 81       	ld	r24, Z
    3822:	19 aa       	std	Y+49, r1	; 0x31
    3824:	88 23       	and	r24, r24
    3826:	14 f4       	brge	.+4      	; 0x382c <glcd_BusyCheck+0x362>
    3828:	81 e0       	ldi	r24, 0x01	; 1
    382a:	89 ab       	std	Y+49, r24	; 0x31
    }while(busyflag);
    382c:	89 a9       	ldd	r24, Y+49	; 0x31
    382e:	88 23       	and	r24, r24
    3830:	09 f0       	breq	.+2      	; 0x3834 <glcd_BusyCheck+0x36a>
    3832:	6a ce       	rjmp	.-812    	; 0x3508 <glcd_BusyCheck+0x3e>

    util_UpdateBit(M_GlcdDataBusDirection,GLCD_D7,C_PinOutput_U8);
    3834:	a4 e0       	ldi	r26, 0x04	; 4
    3836:	b1 e0       	ldi	r27, 0x01	; 1
    3838:	e4 e0       	ldi	r30, 0x04	; 4
    383a:	f1 e0       	ldi	r31, 0x01	; 1
    383c:	80 81       	ld	r24, Z
    383e:	80 68       	ori	r24, 0x80	; 128
    3840:	8c 93       	st	X, r24
#else
    /* Busy flag cannot be read as GLCD_RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
#endif
}
    3842:	e1 96       	adiw	r28, 0x31	; 49
    3844:	0f b6       	in	r0, 0x3f	; 63
    3846:	f8 94       	cli
    3848:	de bf       	out	0x3e, r29	; 62
    384a:	0f be       	out	0x3f, r0	; 63
    384c:	cd bf       	out	0x3d, r28	; 61
    384e:	cf 91       	pop	r28
    3850:	df 91       	pop	r29
    3852:	08 95       	ret

00003854 <glcd_SelectPage0>:


static void glcd_SelectPage0() 
 { 
    3854:	df 93       	push	r29
    3856:	cf 93       	push	r28
    3858:	cd b7       	in	r28, 0x3d	; 61
    385a:	de b7       	in	r29, 0x3e	; 62
   M_GlcdSetBit(M_GlcdControlBus1,GLCD_CS1); 
    385c:	ab e0       	ldi	r26, 0x0B	; 11
    385e:	b1 e0       	ldi	r27, 0x01	; 1
    3860:	eb e0       	ldi	r30, 0x0B	; 11
    3862:	f1 e0       	ldi	r31, 0x01	; 1
    3864:	80 81       	ld	r24, Z
    3866:	81 60       	ori	r24, 0x01	; 1
    3868:	8c 93       	st	X, r24
   M_GlcdClearBit(M_GlcdControlBus1,GLCD_CS2); 
    386a:	ab e0       	ldi	r26, 0x0B	; 11
    386c:	b1 e0       	ldi	r27, 0x01	; 1
    386e:	eb e0       	ldi	r30, 0x0B	; 11
    3870:	f1 e0       	ldi	r31, 0x01	; 1
    3872:	80 81       	ld	r24, Z
    3874:	8d 7f       	andi	r24, 0xFD	; 253
    3876:	8c 93       	st	X, r24
 }
    3878:	cf 91       	pop	r28
    387a:	df 91       	pop	r29
    387c:	08 95       	ret

0000387e <glcd_SelectPage1>:

static void glcd_SelectPage1() 
 {
    387e:	df 93       	push	r29
    3880:	cf 93       	push	r28
    3882:	cd b7       	in	r28, 0x3d	; 61
    3884:	de b7       	in	r29, 0x3e	; 62
   M_GlcdSetBit(M_GlcdControlBus1,GLCD_CS2);  
    3886:	ab e0       	ldi	r26, 0x0B	; 11
    3888:	b1 e0       	ldi	r27, 0x01	; 1
    388a:	eb e0       	ldi	r30, 0x0B	; 11
    388c:	f1 e0       	ldi	r31, 0x01	; 1
    388e:	80 81       	ld	r24, Z
    3890:	82 60       	ori	r24, 0x02	; 2
    3892:	8c 93       	st	X, r24
   M_GlcdClearBit(M_GlcdControlBus1,GLCD_CS1); 
    3894:	ab e0       	ldi	r26, 0x0B	; 11
    3896:	b1 e0       	ldi	r27, 0x01	; 1
    3898:	eb e0       	ldi	r30, 0x0B	; 11
    389a:	f1 e0       	ldi	r31, 0x01	; 1
    389c:	80 81       	ld	r24, Z
    389e:	8e 7f       	andi	r24, 0xFE	; 254
    38a0:	8c 93       	st	X, r24
 }
    38a2:	cf 91       	pop	r28
    38a4:	df 91       	pop	r29
    38a6:	08 95       	ret

000038a8 <lcd_set_4bit>:
int i;


/*****Function to Reset LCD*****/
void lcd_set_4bit()
{
    38a8:	0f 93       	push	r16
    38aa:	1f 93       	push	r17
    38ac:	df 93       	push	r29
    38ae:	cf 93       	push	r28
    38b0:	cd b7       	in	r28, 0x3d	; 61
    38b2:	de b7       	in	r29, 0x3e	; 62
    38b4:	c0 57       	subi	r28, 0x70	; 112
    38b6:	d0 40       	sbci	r29, 0x00	; 0
    38b8:	0f b6       	in	r0, 0x3f	; 63
    38ba:	f8 94       	cli
    38bc:	de bf       	out	0x3e, r29	; 62
    38be:	0f be       	out	0x3f, r0	; 63
    38c0:	cd bf       	out	0x3d, r28	; 61
    38c2:	fe 01       	movw	r30, r28
    38c4:	e3 59       	subi	r30, 0x93	; 147
    38c6:	ff 4f       	sbci	r31, 0xFF	; 255
    38c8:	80 e0       	ldi	r24, 0x00	; 0
    38ca:	90 e0       	ldi	r25, 0x00	; 0
    38cc:	a0 e8       	ldi	r26, 0x80	; 128
    38ce:	bf e3       	ldi	r27, 0x3F	; 63
    38d0:	80 83       	st	Z, r24
    38d2:	91 83       	std	Z+1, r25	; 0x01
    38d4:	a2 83       	std	Z+2, r26	; 0x02
    38d6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    38d8:	8e 01       	movw	r16, r28
    38da:	07 59       	subi	r16, 0x97	; 151
    38dc:	1f 4f       	sbci	r17, 0xFF	; 255
    38de:	fe 01       	movw	r30, r28
    38e0:	e3 59       	subi	r30, 0x93	; 147
    38e2:	ff 4f       	sbci	r31, 0xFF	; 255
    38e4:	60 81       	ld	r22, Z
    38e6:	71 81       	ldd	r23, Z+1	; 0x01
    38e8:	82 81       	ldd	r24, Z+2	; 0x02
    38ea:	93 81       	ldd	r25, Z+3	; 0x03
    38ec:	26 e6       	ldi	r18, 0x66	; 102
    38ee:	36 e6       	ldi	r19, 0x66	; 102
    38f0:	46 e6       	ldi	r20, 0x66	; 102
    38f2:	55 e4       	ldi	r21, 0x45	; 69
    38f4:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    38f8:	dc 01       	movw	r26, r24
    38fa:	cb 01       	movw	r24, r22
    38fc:	f8 01       	movw	r30, r16
    38fe:	80 83       	st	Z, r24
    3900:	91 83       	std	Z+1, r25	; 0x01
    3902:	a2 83       	std	Z+2, r26	; 0x02
    3904:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3906:	fe 01       	movw	r30, r28
    3908:	e7 59       	subi	r30, 0x97	; 151
    390a:	ff 4f       	sbci	r31, 0xFF	; 255
    390c:	60 81       	ld	r22, Z
    390e:	71 81       	ldd	r23, Z+1	; 0x01
    3910:	82 81       	ldd	r24, Z+2	; 0x02
    3912:	93 81       	ldd	r25, Z+3	; 0x03
    3914:	20 e0       	ldi	r18, 0x00	; 0
    3916:	30 e0       	ldi	r19, 0x00	; 0
    3918:	40 e8       	ldi	r20, 0x80	; 128
    391a:	5f e3       	ldi	r21, 0x3F	; 63
    391c:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3920:	88 23       	and	r24, r24
    3922:	44 f4       	brge	.+16     	; 0x3934 <lcd_set_4bit+0x8c>
		__ticks = 1;
    3924:	fe 01       	movw	r30, r28
    3926:	e9 59       	subi	r30, 0x99	; 153
    3928:	ff 4f       	sbci	r31, 0xFF	; 255
    392a:	81 e0       	ldi	r24, 0x01	; 1
    392c:	90 e0       	ldi	r25, 0x00	; 0
    392e:	91 83       	std	Z+1, r25	; 0x01
    3930:	80 83       	st	Z, r24
    3932:	64 c0       	rjmp	.+200    	; 0x39fc <lcd_set_4bit+0x154>
	else if (__tmp > 65535)
    3934:	fe 01       	movw	r30, r28
    3936:	e7 59       	subi	r30, 0x97	; 151
    3938:	ff 4f       	sbci	r31, 0xFF	; 255
    393a:	60 81       	ld	r22, Z
    393c:	71 81       	ldd	r23, Z+1	; 0x01
    393e:	82 81       	ldd	r24, Z+2	; 0x02
    3940:	93 81       	ldd	r25, Z+3	; 0x03
    3942:	20 e0       	ldi	r18, 0x00	; 0
    3944:	3f ef       	ldi	r19, 0xFF	; 255
    3946:	4f e7       	ldi	r20, 0x7F	; 127
    3948:	57 e4       	ldi	r21, 0x47	; 71
    394a:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    394e:	18 16       	cp	r1, r24
    3950:	0c f0       	brlt	.+2      	; 0x3954 <lcd_set_4bit+0xac>
    3952:	43 c0       	rjmp	.+134    	; 0x39da <lcd_set_4bit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3954:	fe 01       	movw	r30, r28
    3956:	e3 59       	subi	r30, 0x93	; 147
    3958:	ff 4f       	sbci	r31, 0xFF	; 255
    395a:	60 81       	ld	r22, Z
    395c:	71 81       	ldd	r23, Z+1	; 0x01
    395e:	82 81       	ldd	r24, Z+2	; 0x02
    3960:	93 81       	ldd	r25, Z+3	; 0x03
    3962:	20 e0       	ldi	r18, 0x00	; 0
    3964:	30 e0       	ldi	r19, 0x00	; 0
    3966:	40 e2       	ldi	r20, 0x20	; 32
    3968:	51 e4       	ldi	r21, 0x41	; 65
    396a:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    396e:	dc 01       	movw	r26, r24
    3970:	cb 01       	movw	r24, r22
    3972:	8e 01       	movw	r16, r28
    3974:	09 59       	subi	r16, 0x99	; 153
    3976:	1f 4f       	sbci	r17, 0xFF	; 255
    3978:	bc 01       	movw	r22, r24
    397a:	cd 01       	movw	r24, r26
    397c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3980:	dc 01       	movw	r26, r24
    3982:	cb 01       	movw	r24, r22
    3984:	f8 01       	movw	r30, r16
    3986:	91 83       	std	Z+1, r25	; 0x01
    3988:	80 83       	st	Z, r24
    398a:	1f c0       	rjmp	.+62     	; 0x39ca <lcd_set_4bit+0x122>
    398c:	fe 01       	movw	r30, r28
    398e:	eb 59       	subi	r30, 0x9B	; 155
    3990:	ff 4f       	sbci	r31, 0xFF	; 255
    3992:	80 e7       	ldi	r24, 0x70	; 112
    3994:	91 e0       	ldi	r25, 0x01	; 1
    3996:	91 83       	std	Z+1, r25	; 0x01
    3998:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    399a:	fe 01       	movw	r30, r28
    399c:	eb 59       	subi	r30, 0x9B	; 155
    399e:	ff 4f       	sbci	r31, 0xFF	; 255
    39a0:	80 81       	ld	r24, Z
    39a2:	91 81       	ldd	r25, Z+1	; 0x01
    39a4:	01 97       	sbiw	r24, 0x01	; 1
    39a6:	f1 f7       	brne	.-4      	; 0x39a4 <lcd_set_4bit+0xfc>
    39a8:	fe 01       	movw	r30, r28
    39aa:	eb 59       	subi	r30, 0x9B	; 155
    39ac:	ff 4f       	sbci	r31, 0xFF	; 255
    39ae:	91 83       	std	Z+1, r25	; 0x01
    39b0:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39b2:	de 01       	movw	r26, r28
    39b4:	a9 59       	subi	r26, 0x99	; 153
    39b6:	bf 4f       	sbci	r27, 0xFF	; 255
    39b8:	fe 01       	movw	r30, r28
    39ba:	e9 59       	subi	r30, 0x99	; 153
    39bc:	ff 4f       	sbci	r31, 0xFF	; 255
    39be:	80 81       	ld	r24, Z
    39c0:	91 81       	ldd	r25, Z+1	; 0x01
    39c2:	01 97       	sbiw	r24, 0x01	; 1
    39c4:	11 96       	adiw	r26, 0x01	; 1
    39c6:	9c 93       	st	X, r25
    39c8:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39ca:	fe 01       	movw	r30, r28
    39cc:	e9 59       	subi	r30, 0x99	; 153
    39ce:	ff 4f       	sbci	r31, 0xFF	; 255
    39d0:	80 81       	ld	r24, Z
    39d2:	91 81       	ldd	r25, Z+1	; 0x01
    39d4:	00 97       	sbiw	r24, 0x00	; 0
    39d6:	d1 f6       	brne	.-76     	; 0x398c <lcd_set_4bit+0xe4>
    39d8:	27 c0       	rjmp	.+78     	; 0x3a28 <lcd_set_4bit+0x180>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    39da:	8e 01       	movw	r16, r28
    39dc:	09 59       	subi	r16, 0x99	; 153
    39de:	1f 4f       	sbci	r17, 0xFF	; 255
    39e0:	fe 01       	movw	r30, r28
    39e2:	e7 59       	subi	r30, 0x97	; 151
    39e4:	ff 4f       	sbci	r31, 0xFF	; 255
    39e6:	60 81       	ld	r22, Z
    39e8:	71 81       	ldd	r23, Z+1	; 0x01
    39ea:	82 81       	ldd	r24, Z+2	; 0x02
    39ec:	93 81       	ldd	r25, Z+3	; 0x03
    39ee:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    39f2:	dc 01       	movw	r26, r24
    39f4:	cb 01       	movw	r24, r22
    39f6:	f8 01       	movw	r30, r16
    39f8:	91 83       	std	Z+1, r25	; 0x01
    39fa:	80 83       	st	Z, r24
    39fc:	de 01       	movw	r26, r28
    39fe:	ad 59       	subi	r26, 0x9D	; 157
    3a00:	bf 4f       	sbci	r27, 0xFF	; 255
    3a02:	fe 01       	movw	r30, r28
    3a04:	e9 59       	subi	r30, 0x99	; 153
    3a06:	ff 4f       	sbci	r31, 0xFF	; 255
    3a08:	80 81       	ld	r24, Z
    3a0a:	91 81       	ldd	r25, Z+1	; 0x01
    3a0c:	8d 93       	st	X+, r24
    3a0e:	9c 93       	st	X, r25
    3a10:	fe 01       	movw	r30, r28
    3a12:	ed 59       	subi	r30, 0x9D	; 157
    3a14:	ff 4f       	sbci	r31, 0xFF	; 255
    3a16:	80 81       	ld	r24, Z
    3a18:	91 81       	ldd	r25, Z+1	; 0x01
    3a1a:	01 97       	sbiw	r24, 0x01	; 1
    3a1c:	f1 f7       	brne	.-4      	; 0x3a1a <lcd_set_4bit+0x172>
    3a1e:	fe 01       	movw	r30, r28
    3a20:	ed 59       	subi	r30, 0x9D	; 157
    3a22:	ff 4f       	sbci	r31, 0xFF	; 255
    3a24:	91 83       	std	Z+1, r25	; 0x01
    3a26:	80 83       	st	Z, r24
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
    3a28:	a8 e2       	ldi	r26, 0x28	; 40
    3a2a:	b0 e0       	ldi	r27, 0x00	; 0
    3a2c:	e8 e2       	ldi	r30, 0x28	; 40
    3a2e:	f0 e0       	ldi	r31, 0x00	; 0
    3a30:	80 81       	ld	r24, Z
    3a32:	8e 7f       	andi	r24, 0xFE	; 254
    3a34:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
    3a36:	a8 e2       	ldi	r26, 0x28	; 40
    3a38:	b0 e0       	ldi	r27, 0x00	; 0
    3a3a:	e8 e2       	ldi	r30, 0x28	; 40
    3a3c:	f0 e0       	ldi	r31, 0x00	; 0
    3a3e:	80 81       	ld	r24, Z
    3a40:	8d 7f       	andi	r24, 0xFD	; 253
    3a42:	8c 93       	st	X, r24
	lcd_port = 0x30;				//Sending 3
    3a44:	e8 e2       	ldi	r30, 0x28	; 40
    3a46:	f0 e0       	ldi	r31, 0x00	; 0
    3a48:	80 e3       	ldi	r24, 0x30	; 48
    3a4a:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
    3a4c:	a8 e2       	ldi	r26, 0x28	; 40
    3a4e:	b0 e0       	ldi	r27, 0x00	; 0
    3a50:	e8 e2       	ldi	r30, 0x28	; 40
    3a52:	f0 e0       	ldi	r31, 0x00	; 0
    3a54:	80 81       	ld	r24, Z
    3a56:	84 60       	ori	r24, 0x04	; 4
    3a58:	8c 93       	st	X, r24
    3a5a:	fe 01       	movw	r30, r28
    3a5c:	e1 5a       	subi	r30, 0xA1	; 161
    3a5e:	ff 4f       	sbci	r31, 0xFF	; 255
    3a60:	80 e0       	ldi	r24, 0x00	; 0
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	a0 ea       	ldi	r26, 0xA0	; 160
    3a66:	b0 e4       	ldi	r27, 0x40	; 64
    3a68:	80 83       	st	Z, r24
    3a6a:	91 83       	std	Z+1, r25	; 0x01
    3a6c:	a2 83       	std	Z+2, r26	; 0x02
    3a6e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3a70:	8e 01       	movw	r16, r28
    3a72:	05 5a       	subi	r16, 0xA5	; 165
    3a74:	1f 4f       	sbci	r17, 0xFF	; 255
    3a76:	fe 01       	movw	r30, r28
    3a78:	e1 5a       	subi	r30, 0xA1	; 161
    3a7a:	ff 4f       	sbci	r31, 0xFF	; 255
    3a7c:	60 81       	ld	r22, Z
    3a7e:	71 81       	ldd	r23, Z+1	; 0x01
    3a80:	82 81       	ldd	r24, Z+2	; 0x02
    3a82:	93 81       	ldd	r25, Z+3	; 0x03
    3a84:	26 e6       	ldi	r18, 0x66	; 102
    3a86:	36 e6       	ldi	r19, 0x66	; 102
    3a88:	46 e6       	ldi	r20, 0x66	; 102
    3a8a:	55 e4       	ldi	r21, 0x45	; 69
    3a8c:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3a90:	dc 01       	movw	r26, r24
    3a92:	cb 01       	movw	r24, r22
    3a94:	f8 01       	movw	r30, r16
    3a96:	80 83       	st	Z, r24
    3a98:	91 83       	std	Z+1, r25	; 0x01
    3a9a:	a2 83       	std	Z+2, r26	; 0x02
    3a9c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3a9e:	fe 01       	movw	r30, r28
    3aa0:	e5 5a       	subi	r30, 0xA5	; 165
    3aa2:	ff 4f       	sbci	r31, 0xFF	; 255
    3aa4:	60 81       	ld	r22, Z
    3aa6:	71 81       	ldd	r23, Z+1	; 0x01
    3aa8:	82 81       	ldd	r24, Z+2	; 0x02
    3aaa:	93 81       	ldd	r25, Z+3	; 0x03
    3aac:	20 e0       	ldi	r18, 0x00	; 0
    3aae:	30 e0       	ldi	r19, 0x00	; 0
    3ab0:	40 e8       	ldi	r20, 0x80	; 128
    3ab2:	5f e3       	ldi	r21, 0x3F	; 63
    3ab4:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3ab8:	88 23       	and	r24, r24
    3aba:	44 f4       	brge	.+16     	; 0x3acc <lcd_set_4bit+0x224>
		__ticks = 1;
    3abc:	fe 01       	movw	r30, r28
    3abe:	e7 5a       	subi	r30, 0xA7	; 167
    3ac0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ac2:	81 e0       	ldi	r24, 0x01	; 1
    3ac4:	90 e0       	ldi	r25, 0x00	; 0
    3ac6:	91 83       	std	Z+1, r25	; 0x01
    3ac8:	80 83       	st	Z, r24
    3aca:	64 c0       	rjmp	.+200    	; 0x3b94 <lcd_set_4bit+0x2ec>
	else if (__tmp > 65535)
    3acc:	fe 01       	movw	r30, r28
    3ace:	e5 5a       	subi	r30, 0xA5	; 165
    3ad0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ad2:	60 81       	ld	r22, Z
    3ad4:	71 81       	ldd	r23, Z+1	; 0x01
    3ad6:	82 81       	ldd	r24, Z+2	; 0x02
    3ad8:	93 81       	ldd	r25, Z+3	; 0x03
    3ada:	20 e0       	ldi	r18, 0x00	; 0
    3adc:	3f ef       	ldi	r19, 0xFF	; 255
    3ade:	4f e7       	ldi	r20, 0x7F	; 127
    3ae0:	57 e4       	ldi	r21, 0x47	; 71
    3ae2:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3ae6:	18 16       	cp	r1, r24
    3ae8:	0c f0       	brlt	.+2      	; 0x3aec <lcd_set_4bit+0x244>
    3aea:	43 c0       	rjmp	.+134    	; 0x3b72 <lcd_set_4bit+0x2ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3aec:	fe 01       	movw	r30, r28
    3aee:	e1 5a       	subi	r30, 0xA1	; 161
    3af0:	ff 4f       	sbci	r31, 0xFF	; 255
    3af2:	60 81       	ld	r22, Z
    3af4:	71 81       	ldd	r23, Z+1	; 0x01
    3af6:	82 81       	ldd	r24, Z+2	; 0x02
    3af8:	93 81       	ldd	r25, Z+3	; 0x03
    3afa:	20 e0       	ldi	r18, 0x00	; 0
    3afc:	30 e0       	ldi	r19, 0x00	; 0
    3afe:	40 e2       	ldi	r20, 0x20	; 32
    3b00:	51 e4       	ldi	r21, 0x41	; 65
    3b02:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3b06:	dc 01       	movw	r26, r24
    3b08:	cb 01       	movw	r24, r22
    3b0a:	8e 01       	movw	r16, r28
    3b0c:	07 5a       	subi	r16, 0xA7	; 167
    3b0e:	1f 4f       	sbci	r17, 0xFF	; 255
    3b10:	bc 01       	movw	r22, r24
    3b12:	cd 01       	movw	r24, r26
    3b14:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3b18:	dc 01       	movw	r26, r24
    3b1a:	cb 01       	movw	r24, r22
    3b1c:	f8 01       	movw	r30, r16
    3b1e:	91 83       	std	Z+1, r25	; 0x01
    3b20:	80 83       	st	Z, r24
    3b22:	1f c0       	rjmp	.+62     	; 0x3b62 <lcd_set_4bit+0x2ba>
    3b24:	fe 01       	movw	r30, r28
    3b26:	e9 5a       	subi	r30, 0xA9	; 169
    3b28:	ff 4f       	sbci	r31, 0xFF	; 255
    3b2a:	80 e7       	ldi	r24, 0x70	; 112
    3b2c:	91 e0       	ldi	r25, 0x01	; 1
    3b2e:	91 83       	std	Z+1, r25	; 0x01
    3b30:	80 83       	st	Z, r24
    3b32:	fe 01       	movw	r30, r28
    3b34:	e9 5a       	subi	r30, 0xA9	; 169
    3b36:	ff 4f       	sbci	r31, 0xFF	; 255
    3b38:	80 81       	ld	r24, Z
    3b3a:	91 81       	ldd	r25, Z+1	; 0x01
    3b3c:	01 97       	sbiw	r24, 0x01	; 1
    3b3e:	f1 f7       	brne	.-4      	; 0x3b3c <lcd_set_4bit+0x294>
    3b40:	fe 01       	movw	r30, r28
    3b42:	e9 5a       	subi	r30, 0xA9	; 169
    3b44:	ff 4f       	sbci	r31, 0xFF	; 255
    3b46:	91 83       	std	Z+1, r25	; 0x01
    3b48:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b4a:	de 01       	movw	r26, r28
    3b4c:	a7 5a       	subi	r26, 0xA7	; 167
    3b4e:	bf 4f       	sbci	r27, 0xFF	; 255
    3b50:	fe 01       	movw	r30, r28
    3b52:	e7 5a       	subi	r30, 0xA7	; 167
    3b54:	ff 4f       	sbci	r31, 0xFF	; 255
    3b56:	80 81       	ld	r24, Z
    3b58:	91 81       	ldd	r25, Z+1	; 0x01
    3b5a:	01 97       	sbiw	r24, 0x01	; 1
    3b5c:	11 96       	adiw	r26, 0x01	; 1
    3b5e:	9c 93       	st	X, r25
    3b60:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b62:	fe 01       	movw	r30, r28
    3b64:	e7 5a       	subi	r30, 0xA7	; 167
    3b66:	ff 4f       	sbci	r31, 0xFF	; 255
    3b68:	80 81       	ld	r24, Z
    3b6a:	91 81       	ldd	r25, Z+1	; 0x01
    3b6c:	00 97       	sbiw	r24, 0x00	; 0
    3b6e:	d1 f6       	brne	.-76     	; 0x3b24 <lcd_set_4bit+0x27c>
    3b70:	27 c0       	rjmp	.+78     	; 0x3bc0 <lcd_set_4bit+0x318>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b72:	8e 01       	movw	r16, r28
    3b74:	07 5a       	subi	r16, 0xA7	; 167
    3b76:	1f 4f       	sbci	r17, 0xFF	; 255
    3b78:	fe 01       	movw	r30, r28
    3b7a:	e5 5a       	subi	r30, 0xA5	; 165
    3b7c:	ff 4f       	sbci	r31, 0xFF	; 255
    3b7e:	60 81       	ld	r22, Z
    3b80:	71 81       	ldd	r23, Z+1	; 0x01
    3b82:	82 81       	ldd	r24, Z+2	; 0x02
    3b84:	93 81       	ldd	r25, Z+3	; 0x03
    3b86:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3b8a:	dc 01       	movw	r26, r24
    3b8c:	cb 01       	movw	r24, r22
    3b8e:	f8 01       	movw	r30, r16
    3b90:	91 83       	std	Z+1, r25	; 0x01
    3b92:	80 83       	st	Z, r24
    3b94:	de 01       	movw	r26, r28
    3b96:	ab 5a       	subi	r26, 0xAB	; 171
    3b98:	bf 4f       	sbci	r27, 0xFF	; 255
    3b9a:	fe 01       	movw	r30, r28
    3b9c:	e7 5a       	subi	r30, 0xA7	; 167
    3b9e:	ff 4f       	sbci	r31, 0xFF	; 255
    3ba0:	80 81       	ld	r24, Z
    3ba2:	91 81       	ldd	r25, Z+1	; 0x01
    3ba4:	8d 93       	st	X+, r24
    3ba6:	9c 93       	st	X, r25
    3ba8:	fe 01       	movw	r30, r28
    3baa:	eb 5a       	subi	r30, 0xAB	; 171
    3bac:	ff 4f       	sbci	r31, 0xFF	; 255
    3bae:	80 81       	ld	r24, Z
    3bb0:	91 81       	ldd	r25, Z+1	; 0x01
    3bb2:	01 97       	sbiw	r24, 0x01	; 1
    3bb4:	f1 f7       	brne	.-4      	; 0x3bb2 <lcd_set_4bit+0x30a>
    3bb6:	fe 01       	movw	r30, r28
    3bb8:	eb 5a       	subi	r30, 0xAB	; 171
    3bba:	ff 4f       	sbci	r31, 0xFF	; 255
    3bbc:	91 83       	std	Z+1, r25	; 0x01
    3bbe:	80 83       	st	Z, r24
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
    3bc0:	a8 e2       	ldi	r26, 0x28	; 40
    3bc2:	b0 e0       	ldi	r27, 0x00	; 0
    3bc4:	e8 e2       	ldi	r30, 0x28	; 40
    3bc6:	f0 e0       	ldi	r31, 0x00	; 0
    3bc8:	80 81       	ld	r24, Z
    3bca:	8b 7f       	andi	r24, 0xFB	; 251
    3bcc:	8c 93       	st	X, r24
    3bce:	fe 01       	movw	r30, r28
    3bd0:	ef 5a       	subi	r30, 0xAF	; 175
    3bd2:	ff 4f       	sbci	r31, 0xFF	; 255
    3bd4:	80 e0       	ldi	r24, 0x00	; 0
    3bd6:	90 e0       	ldi	r25, 0x00	; 0
    3bd8:	a0 e8       	ldi	r26, 0x80	; 128
    3bda:	bf e3       	ldi	r27, 0x3F	; 63
    3bdc:	80 83       	st	Z, r24
    3bde:	91 83       	std	Z+1, r25	; 0x01
    3be0:	a2 83       	std	Z+2, r26	; 0x02
    3be2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3be4:	8e 01       	movw	r16, r28
    3be6:	03 5b       	subi	r16, 0xB3	; 179
    3be8:	1f 4f       	sbci	r17, 0xFF	; 255
    3bea:	fe 01       	movw	r30, r28
    3bec:	ef 5a       	subi	r30, 0xAF	; 175
    3bee:	ff 4f       	sbci	r31, 0xFF	; 255
    3bf0:	60 81       	ld	r22, Z
    3bf2:	71 81       	ldd	r23, Z+1	; 0x01
    3bf4:	82 81       	ldd	r24, Z+2	; 0x02
    3bf6:	93 81       	ldd	r25, Z+3	; 0x03
    3bf8:	26 e6       	ldi	r18, 0x66	; 102
    3bfa:	36 e6       	ldi	r19, 0x66	; 102
    3bfc:	46 e6       	ldi	r20, 0x66	; 102
    3bfe:	55 e4       	ldi	r21, 0x45	; 69
    3c00:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3c04:	dc 01       	movw	r26, r24
    3c06:	cb 01       	movw	r24, r22
    3c08:	f8 01       	movw	r30, r16
    3c0a:	80 83       	st	Z, r24
    3c0c:	91 83       	std	Z+1, r25	; 0x01
    3c0e:	a2 83       	std	Z+2, r26	; 0x02
    3c10:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3c12:	fe 01       	movw	r30, r28
    3c14:	e3 5b       	subi	r30, 0xB3	; 179
    3c16:	ff 4f       	sbci	r31, 0xFF	; 255
    3c18:	60 81       	ld	r22, Z
    3c1a:	71 81       	ldd	r23, Z+1	; 0x01
    3c1c:	82 81       	ldd	r24, Z+2	; 0x02
    3c1e:	93 81       	ldd	r25, Z+3	; 0x03
    3c20:	20 e0       	ldi	r18, 0x00	; 0
    3c22:	30 e0       	ldi	r19, 0x00	; 0
    3c24:	40 e8       	ldi	r20, 0x80	; 128
    3c26:	5f e3       	ldi	r21, 0x3F	; 63
    3c28:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3c2c:	88 23       	and	r24, r24
    3c2e:	44 f4       	brge	.+16     	; 0x3c40 <lcd_set_4bit+0x398>
		__ticks = 1;
    3c30:	fe 01       	movw	r30, r28
    3c32:	e5 5b       	subi	r30, 0xB5	; 181
    3c34:	ff 4f       	sbci	r31, 0xFF	; 255
    3c36:	81 e0       	ldi	r24, 0x01	; 1
    3c38:	90 e0       	ldi	r25, 0x00	; 0
    3c3a:	91 83       	std	Z+1, r25	; 0x01
    3c3c:	80 83       	st	Z, r24
    3c3e:	64 c0       	rjmp	.+200    	; 0x3d08 <lcd_set_4bit+0x460>
	else if (__tmp > 65535)
    3c40:	fe 01       	movw	r30, r28
    3c42:	e3 5b       	subi	r30, 0xB3	; 179
    3c44:	ff 4f       	sbci	r31, 0xFF	; 255
    3c46:	60 81       	ld	r22, Z
    3c48:	71 81       	ldd	r23, Z+1	; 0x01
    3c4a:	82 81       	ldd	r24, Z+2	; 0x02
    3c4c:	93 81       	ldd	r25, Z+3	; 0x03
    3c4e:	20 e0       	ldi	r18, 0x00	; 0
    3c50:	3f ef       	ldi	r19, 0xFF	; 255
    3c52:	4f e7       	ldi	r20, 0x7F	; 127
    3c54:	57 e4       	ldi	r21, 0x47	; 71
    3c56:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3c5a:	18 16       	cp	r1, r24
    3c5c:	0c f0       	brlt	.+2      	; 0x3c60 <lcd_set_4bit+0x3b8>
    3c5e:	43 c0       	rjmp	.+134    	; 0x3ce6 <lcd_set_4bit+0x43e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3c60:	fe 01       	movw	r30, r28
    3c62:	ef 5a       	subi	r30, 0xAF	; 175
    3c64:	ff 4f       	sbci	r31, 0xFF	; 255
    3c66:	60 81       	ld	r22, Z
    3c68:	71 81       	ldd	r23, Z+1	; 0x01
    3c6a:	82 81       	ldd	r24, Z+2	; 0x02
    3c6c:	93 81       	ldd	r25, Z+3	; 0x03
    3c6e:	20 e0       	ldi	r18, 0x00	; 0
    3c70:	30 e0       	ldi	r19, 0x00	; 0
    3c72:	40 e2       	ldi	r20, 0x20	; 32
    3c74:	51 e4       	ldi	r21, 0x41	; 65
    3c76:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3c7a:	dc 01       	movw	r26, r24
    3c7c:	cb 01       	movw	r24, r22
    3c7e:	8e 01       	movw	r16, r28
    3c80:	05 5b       	subi	r16, 0xB5	; 181
    3c82:	1f 4f       	sbci	r17, 0xFF	; 255
    3c84:	bc 01       	movw	r22, r24
    3c86:	cd 01       	movw	r24, r26
    3c88:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3c8c:	dc 01       	movw	r26, r24
    3c8e:	cb 01       	movw	r24, r22
    3c90:	f8 01       	movw	r30, r16
    3c92:	91 83       	std	Z+1, r25	; 0x01
    3c94:	80 83       	st	Z, r24
    3c96:	1f c0       	rjmp	.+62     	; 0x3cd6 <lcd_set_4bit+0x42e>
    3c98:	fe 01       	movw	r30, r28
    3c9a:	e7 5b       	subi	r30, 0xB7	; 183
    3c9c:	ff 4f       	sbci	r31, 0xFF	; 255
    3c9e:	80 e7       	ldi	r24, 0x70	; 112
    3ca0:	91 e0       	ldi	r25, 0x01	; 1
    3ca2:	91 83       	std	Z+1, r25	; 0x01
    3ca4:	80 83       	st	Z, r24
    3ca6:	fe 01       	movw	r30, r28
    3ca8:	e7 5b       	subi	r30, 0xB7	; 183
    3caa:	ff 4f       	sbci	r31, 0xFF	; 255
    3cac:	80 81       	ld	r24, Z
    3cae:	91 81       	ldd	r25, Z+1	; 0x01
    3cb0:	01 97       	sbiw	r24, 0x01	; 1
    3cb2:	f1 f7       	brne	.-4      	; 0x3cb0 <lcd_set_4bit+0x408>
    3cb4:	fe 01       	movw	r30, r28
    3cb6:	e7 5b       	subi	r30, 0xB7	; 183
    3cb8:	ff 4f       	sbci	r31, 0xFF	; 255
    3cba:	91 83       	std	Z+1, r25	; 0x01
    3cbc:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3cbe:	de 01       	movw	r26, r28
    3cc0:	a5 5b       	subi	r26, 0xB5	; 181
    3cc2:	bf 4f       	sbci	r27, 0xFF	; 255
    3cc4:	fe 01       	movw	r30, r28
    3cc6:	e5 5b       	subi	r30, 0xB5	; 181
    3cc8:	ff 4f       	sbci	r31, 0xFF	; 255
    3cca:	80 81       	ld	r24, Z
    3ccc:	91 81       	ldd	r25, Z+1	; 0x01
    3cce:	01 97       	sbiw	r24, 0x01	; 1
    3cd0:	11 96       	adiw	r26, 0x01	; 1
    3cd2:	9c 93       	st	X, r25
    3cd4:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3cd6:	fe 01       	movw	r30, r28
    3cd8:	e5 5b       	subi	r30, 0xB5	; 181
    3cda:	ff 4f       	sbci	r31, 0xFF	; 255
    3cdc:	80 81       	ld	r24, Z
    3cde:	91 81       	ldd	r25, Z+1	; 0x01
    3ce0:	00 97       	sbiw	r24, 0x00	; 0
    3ce2:	d1 f6       	brne	.-76     	; 0x3c98 <lcd_set_4bit+0x3f0>
    3ce4:	27 c0       	rjmp	.+78     	; 0x3d34 <lcd_set_4bit+0x48c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3ce6:	8e 01       	movw	r16, r28
    3ce8:	05 5b       	subi	r16, 0xB5	; 181
    3cea:	1f 4f       	sbci	r17, 0xFF	; 255
    3cec:	fe 01       	movw	r30, r28
    3cee:	e3 5b       	subi	r30, 0xB3	; 179
    3cf0:	ff 4f       	sbci	r31, 0xFF	; 255
    3cf2:	60 81       	ld	r22, Z
    3cf4:	71 81       	ldd	r23, Z+1	; 0x01
    3cf6:	82 81       	ldd	r24, Z+2	; 0x02
    3cf8:	93 81       	ldd	r25, Z+3	; 0x03
    3cfa:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3cfe:	dc 01       	movw	r26, r24
    3d00:	cb 01       	movw	r24, r22
    3d02:	f8 01       	movw	r30, r16
    3d04:	91 83       	std	Z+1, r25	; 0x01
    3d06:	80 83       	st	Z, r24
    3d08:	de 01       	movw	r26, r28
    3d0a:	a9 5b       	subi	r26, 0xB9	; 185
    3d0c:	bf 4f       	sbci	r27, 0xFF	; 255
    3d0e:	fe 01       	movw	r30, r28
    3d10:	e5 5b       	subi	r30, 0xB5	; 181
    3d12:	ff 4f       	sbci	r31, 0xFF	; 255
    3d14:	80 81       	ld	r24, Z
    3d16:	91 81       	ldd	r25, Z+1	; 0x01
    3d18:	8d 93       	st	X+, r24
    3d1a:	9c 93       	st	X, r25
    3d1c:	fe 01       	movw	r30, r28
    3d1e:	e9 5b       	subi	r30, 0xB9	; 185
    3d20:	ff 4f       	sbci	r31, 0xFF	; 255
    3d22:	80 81       	ld	r24, Z
    3d24:	91 81       	ldd	r25, Z+1	; 0x01
    3d26:	01 97       	sbiw	r24, 0x01	; 1
    3d28:	f1 f7       	brne	.-4      	; 0x3d26 <lcd_set_4bit+0x47e>
    3d2a:	fe 01       	movw	r30, r28
    3d2c:	e9 5b       	subi	r30, 0xB9	; 185
    3d2e:	ff 4f       	sbci	r31, 0xFF	; 255
    3d30:	91 83       	std	Z+1, r25	; 0x01
    3d32:	80 83       	st	Z, r24

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
    3d34:	a8 e2       	ldi	r26, 0x28	; 40
    3d36:	b0 e0       	ldi	r27, 0x00	; 0
    3d38:	e8 e2       	ldi	r30, 0x28	; 40
    3d3a:	f0 e0       	ldi	r31, 0x00	; 0
    3d3c:	80 81       	ld	r24, Z
    3d3e:	8e 7f       	andi	r24, 0xFE	; 254
    3d40:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
    3d42:	a8 e2       	ldi	r26, 0x28	; 40
    3d44:	b0 e0       	ldi	r27, 0x00	; 0
    3d46:	e8 e2       	ldi	r30, 0x28	; 40
    3d48:	f0 e0       	ldi	r31, 0x00	; 0
    3d4a:	80 81       	ld	r24, Z
    3d4c:	8d 7f       	andi	r24, 0xFD	; 253
    3d4e:	8c 93       	st	X, r24
	lcd_port = 0x30;				//Sending 3
    3d50:	e8 e2       	ldi	r30, 0x28	; 40
    3d52:	f0 e0       	ldi	r31, 0x00	; 0
    3d54:	80 e3       	ldi	r24, 0x30	; 48
    3d56:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
    3d58:	a8 e2       	ldi	r26, 0x28	; 40
    3d5a:	b0 e0       	ldi	r27, 0x00	; 0
    3d5c:	e8 e2       	ldi	r30, 0x28	; 40
    3d5e:	f0 e0       	ldi	r31, 0x00	; 0
    3d60:	80 81       	ld	r24, Z
    3d62:	84 60       	ori	r24, 0x04	; 4
    3d64:	8c 93       	st	X, r24
    3d66:	fe 01       	movw	r30, r28
    3d68:	ed 5b       	subi	r30, 0xBD	; 189
    3d6a:	ff 4f       	sbci	r31, 0xFF	; 255
    3d6c:	80 e0       	ldi	r24, 0x00	; 0
    3d6e:	90 e0       	ldi	r25, 0x00	; 0
    3d70:	a0 ea       	ldi	r26, 0xA0	; 160
    3d72:	b0 e4       	ldi	r27, 0x40	; 64
    3d74:	80 83       	st	Z, r24
    3d76:	91 83       	std	Z+1, r25	; 0x01
    3d78:	a2 83       	std	Z+2, r26	; 0x02
    3d7a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d7c:	8e 01       	movw	r16, r28
    3d7e:	01 5c       	subi	r16, 0xC1	; 193
    3d80:	1f 4f       	sbci	r17, 0xFF	; 255
    3d82:	fe 01       	movw	r30, r28
    3d84:	ed 5b       	subi	r30, 0xBD	; 189
    3d86:	ff 4f       	sbci	r31, 0xFF	; 255
    3d88:	60 81       	ld	r22, Z
    3d8a:	71 81       	ldd	r23, Z+1	; 0x01
    3d8c:	82 81       	ldd	r24, Z+2	; 0x02
    3d8e:	93 81       	ldd	r25, Z+3	; 0x03
    3d90:	26 e6       	ldi	r18, 0x66	; 102
    3d92:	36 e6       	ldi	r19, 0x66	; 102
    3d94:	46 e6       	ldi	r20, 0x66	; 102
    3d96:	55 e4       	ldi	r21, 0x45	; 69
    3d98:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3d9c:	dc 01       	movw	r26, r24
    3d9e:	cb 01       	movw	r24, r22
    3da0:	f8 01       	movw	r30, r16
    3da2:	80 83       	st	Z, r24
    3da4:	91 83       	std	Z+1, r25	; 0x01
    3da6:	a2 83       	std	Z+2, r26	; 0x02
    3da8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3daa:	fe 01       	movw	r30, r28
    3dac:	ff 96       	adiw	r30, 0x3f	; 63
    3dae:	60 81       	ld	r22, Z
    3db0:	71 81       	ldd	r23, Z+1	; 0x01
    3db2:	82 81       	ldd	r24, Z+2	; 0x02
    3db4:	93 81       	ldd	r25, Z+3	; 0x03
    3db6:	20 e0       	ldi	r18, 0x00	; 0
    3db8:	30 e0       	ldi	r19, 0x00	; 0
    3dba:	40 e8       	ldi	r20, 0x80	; 128
    3dbc:	5f e3       	ldi	r21, 0x3F	; 63
    3dbe:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3dc2:	88 23       	and	r24, r24
    3dc4:	2c f4       	brge	.+10     	; 0x3dd0 <lcd_set_4bit+0x528>
		__ticks = 1;
    3dc6:	81 e0       	ldi	r24, 0x01	; 1
    3dc8:	90 e0       	ldi	r25, 0x00	; 0
    3dca:	9e af       	std	Y+62, r25	; 0x3e
    3dcc:	8d af       	std	Y+61, r24	; 0x3d
    3dce:	46 c0       	rjmp	.+140    	; 0x3e5c <lcd_set_4bit+0x5b4>
	else if (__tmp > 65535)
    3dd0:	fe 01       	movw	r30, r28
    3dd2:	ff 96       	adiw	r30, 0x3f	; 63
    3dd4:	60 81       	ld	r22, Z
    3dd6:	71 81       	ldd	r23, Z+1	; 0x01
    3dd8:	82 81       	ldd	r24, Z+2	; 0x02
    3dda:	93 81       	ldd	r25, Z+3	; 0x03
    3ddc:	20 e0       	ldi	r18, 0x00	; 0
    3dde:	3f ef       	ldi	r19, 0xFF	; 255
    3de0:	4f e7       	ldi	r20, 0x7F	; 127
    3de2:	57 e4       	ldi	r21, 0x47	; 71
    3de4:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3de8:	18 16       	cp	r1, r24
    3dea:	64 f5       	brge	.+88     	; 0x3e44 <lcd_set_4bit+0x59c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3dec:	fe 01       	movw	r30, r28
    3dee:	ed 5b       	subi	r30, 0xBD	; 189
    3df0:	ff 4f       	sbci	r31, 0xFF	; 255
    3df2:	60 81       	ld	r22, Z
    3df4:	71 81       	ldd	r23, Z+1	; 0x01
    3df6:	82 81       	ldd	r24, Z+2	; 0x02
    3df8:	93 81       	ldd	r25, Z+3	; 0x03
    3dfa:	20 e0       	ldi	r18, 0x00	; 0
    3dfc:	30 e0       	ldi	r19, 0x00	; 0
    3dfe:	40 e2       	ldi	r20, 0x20	; 32
    3e00:	51 e4       	ldi	r21, 0x41	; 65
    3e02:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3e06:	dc 01       	movw	r26, r24
    3e08:	cb 01       	movw	r24, r22
    3e0a:	bc 01       	movw	r22, r24
    3e0c:	cd 01       	movw	r24, r26
    3e0e:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3e12:	dc 01       	movw	r26, r24
    3e14:	cb 01       	movw	r24, r22
    3e16:	9e af       	std	Y+62, r25	; 0x3e
    3e18:	8d af       	std	Y+61, r24	; 0x3d
    3e1a:	0f c0       	rjmp	.+30     	; 0x3e3a <lcd_set_4bit+0x592>
    3e1c:	80 e7       	ldi	r24, 0x70	; 112
    3e1e:	91 e0       	ldi	r25, 0x01	; 1
    3e20:	9c af       	std	Y+60, r25	; 0x3c
    3e22:	8b af       	std	Y+59, r24	; 0x3b
    3e24:	8b ad       	ldd	r24, Y+59	; 0x3b
    3e26:	9c ad       	ldd	r25, Y+60	; 0x3c
    3e28:	01 97       	sbiw	r24, 0x01	; 1
    3e2a:	f1 f7       	brne	.-4      	; 0x3e28 <lcd_set_4bit+0x580>
    3e2c:	9c af       	std	Y+60, r25	; 0x3c
    3e2e:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e30:	8d ad       	ldd	r24, Y+61	; 0x3d
    3e32:	9e ad       	ldd	r25, Y+62	; 0x3e
    3e34:	01 97       	sbiw	r24, 0x01	; 1
    3e36:	9e af       	std	Y+62, r25	; 0x3e
    3e38:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e3a:	8d ad       	ldd	r24, Y+61	; 0x3d
    3e3c:	9e ad       	ldd	r25, Y+62	; 0x3e
    3e3e:	00 97       	sbiw	r24, 0x00	; 0
    3e40:	69 f7       	brne	.-38     	; 0x3e1c <lcd_set_4bit+0x574>
    3e42:	16 c0       	rjmp	.+44     	; 0x3e70 <lcd_set_4bit+0x5c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e44:	fe 01       	movw	r30, r28
    3e46:	ff 96       	adiw	r30, 0x3f	; 63
    3e48:	60 81       	ld	r22, Z
    3e4a:	71 81       	ldd	r23, Z+1	; 0x01
    3e4c:	82 81       	ldd	r24, Z+2	; 0x02
    3e4e:	93 81       	ldd	r25, Z+3	; 0x03
    3e50:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3e54:	dc 01       	movw	r26, r24
    3e56:	cb 01       	movw	r24, r22
    3e58:	9e af       	std	Y+62, r25	; 0x3e
    3e5a:	8d af       	std	Y+61, r24	; 0x3d
    3e5c:	8d ad       	ldd	r24, Y+61	; 0x3d
    3e5e:	9e ad       	ldd	r25, Y+62	; 0x3e
    3e60:	9a af       	std	Y+58, r25	; 0x3a
    3e62:	89 af       	std	Y+57, r24	; 0x39
    3e64:	89 ad       	ldd	r24, Y+57	; 0x39
    3e66:	9a ad       	ldd	r25, Y+58	; 0x3a
    3e68:	01 97       	sbiw	r24, 0x01	; 1
    3e6a:	f1 f7       	brne	.-4      	; 0x3e68 <lcd_set_4bit+0x5c0>
    3e6c:	9a af       	std	Y+58, r25	; 0x3a
    3e6e:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
    3e70:	a8 e2       	ldi	r26, 0x28	; 40
    3e72:	b0 e0       	ldi	r27, 0x00	; 0
    3e74:	e8 e2       	ldi	r30, 0x28	; 40
    3e76:	f0 e0       	ldi	r31, 0x00	; 0
    3e78:	80 81       	ld	r24, Z
    3e7a:	8b 7f       	andi	r24, 0xFB	; 251
    3e7c:	8c 93       	st	X, r24
    3e7e:	80 e0       	ldi	r24, 0x00	; 0
    3e80:	90 e0       	ldi	r25, 0x00	; 0
    3e82:	a0 e8       	ldi	r26, 0x80	; 128
    3e84:	bf e3       	ldi	r27, 0x3F	; 63
    3e86:	8d ab       	std	Y+53, r24	; 0x35
    3e88:	9e ab       	std	Y+54, r25	; 0x36
    3e8a:	af ab       	std	Y+55, r26	; 0x37
    3e8c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3e8e:	6d a9       	ldd	r22, Y+53	; 0x35
    3e90:	7e a9       	ldd	r23, Y+54	; 0x36
    3e92:	8f a9       	ldd	r24, Y+55	; 0x37
    3e94:	98 ad       	ldd	r25, Y+56	; 0x38
    3e96:	26 e6       	ldi	r18, 0x66	; 102
    3e98:	36 e6       	ldi	r19, 0x66	; 102
    3e9a:	46 e6       	ldi	r20, 0x66	; 102
    3e9c:	55 e4       	ldi	r21, 0x45	; 69
    3e9e:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3ea2:	dc 01       	movw	r26, r24
    3ea4:	cb 01       	movw	r24, r22
    3ea6:	89 ab       	std	Y+49, r24	; 0x31
    3ea8:	9a ab       	std	Y+50, r25	; 0x32
    3eaa:	ab ab       	std	Y+51, r26	; 0x33
    3eac:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3eae:	69 a9       	ldd	r22, Y+49	; 0x31
    3eb0:	7a a9       	ldd	r23, Y+50	; 0x32
    3eb2:	8b a9       	ldd	r24, Y+51	; 0x33
    3eb4:	9c a9       	ldd	r25, Y+52	; 0x34
    3eb6:	20 e0       	ldi	r18, 0x00	; 0
    3eb8:	30 e0       	ldi	r19, 0x00	; 0
    3eba:	40 e8       	ldi	r20, 0x80	; 128
    3ebc:	5f e3       	ldi	r21, 0x3F	; 63
    3ebe:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3ec2:	88 23       	and	r24, r24
    3ec4:	2c f4       	brge	.+10     	; 0x3ed0 <lcd_set_4bit+0x628>
		__ticks = 1;
    3ec6:	81 e0       	ldi	r24, 0x01	; 1
    3ec8:	90 e0       	ldi	r25, 0x00	; 0
    3eca:	98 ab       	std	Y+48, r25	; 0x30
    3ecc:	8f a7       	std	Y+47, r24	; 0x2f
    3ece:	3f c0       	rjmp	.+126    	; 0x3f4e <lcd_set_4bit+0x6a6>
	else if (__tmp > 65535)
    3ed0:	69 a9       	ldd	r22, Y+49	; 0x31
    3ed2:	7a a9       	ldd	r23, Y+50	; 0x32
    3ed4:	8b a9       	ldd	r24, Y+51	; 0x33
    3ed6:	9c a9       	ldd	r25, Y+52	; 0x34
    3ed8:	20 e0       	ldi	r18, 0x00	; 0
    3eda:	3f ef       	ldi	r19, 0xFF	; 255
    3edc:	4f e7       	ldi	r20, 0x7F	; 127
    3ede:	57 e4       	ldi	r21, 0x47	; 71
    3ee0:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3ee4:	18 16       	cp	r1, r24
    3ee6:	4c f5       	brge	.+82     	; 0x3f3a <lcd_set_4bit+0x692>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ee8:	6d a9       	ldd	r22, Y+53	; 0x35
    3eea:	7e a9       	ldd	r23, Y+54	; 0x36
    3eec:	8f a9       	ldd	r24, Y+55	; 0x37
    3eee:	98 ad       	ldd	r25, Y+56	; 0x38
    3ef0:	20 e0       	ldi	r18, 0x00	; 0
    3ef2:	30 e0       	ldi	r19, 0x00	; 0
    3ef4:	40 e2       	ldi	r20, 0x20	; 32
    3ef6:	51 e4       	ldi	r21, 0x41	; 65
    3ef8:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3efc:	dc 01       	movw	r26, r24
    3efe:	cb 01       	movw	r24, r22
    3f00:	bc 01       	movw	r22, r24
    3f02:	cd 01       	movw	r24, r26
    3f04:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3f08:	dc 01       	movw	r26, r24
    3f0a:	cb 01       	movw	r24, r22
    3f0c:	98 ab       	std	Y+48, r25	; 0x30
    3f0e:	8f a7       	std	Y+47, r24	; 0x2f
    3f10:	0f c0       	rjmp	.+30     	; 0x3f30 <lcd_set_4bit+0x688>
    3f12:	80 e7       	ldi	r24, 0x70	; 112
    3f14:	91 e0       	ldi	r25, 0x01	; 1
    3f16:	9e a7       	std	Y+46, r25	; 0x2e
    3f18:	8d a7       	std	Y+45, r24	; 0x2d
    3f1a:	8d a5       	ldd	r24, Y+45	; 0x2d
    3f1c:	9e a5       	ldd	r25, Y+46	; 0x2e
    3f1e:	01 97       	sbiw	r24, 0x01	; 1
    3f20:	f1 f7       	brne	.-4      	; 0x3f1e <lcd_set_4bit+0x676>
    3f22:	9e a7       	std	Y+46, r25	; 0x2e
    3f24:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f26:	8f a5       	ldd	r24, Y+47	; 0x2f
    3f28:	98 a9       	ldd	r25, Y+48	; 0x30
    3f2a:	01 97       	sbiw	r24, 0x01	; 1
    3f2c:	98 ab       	std	Y+48, r25	; 0x30
    3f2e:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f30:	8f a5       	ldd	r24, Y+47	; 0x2f
    3f32:	98 a9       	ldd	r25, Y+48	; 0x30
    3f34:	00 97       	sbiw	r24, 0x00	; 0
    3f36:	69 f7       	brne	.-38     	; 0x3f12 <lcd_set_4bit+0x66a>
    3f38:	14 c0       	rjmp	.+40     	; 0x3f62 <lcd_set_4bit+0x6ba>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f3a:	69 a9       	ldd	r22, Y+49	; 0x31
    3f3c:	7a a9       	ldd	r23, Y+50	; 0x32
    3f3e:	8b a9       	ldd	r24, Y+51	; 0x33
    3f40:	9c a9       	ldd	r25, Y+52	; 0x34
    3f42:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    3f46:	dc 01       	movw	r26, r24
    3f48:	cb 01       	movw	r24, r22
    3f4a:	98 ab       	std	Y+48, r25	; 0x30
    3f4c:	8f a7       	std	Y+47, r24	; 0x2f
    3f4e:	8f a5       	ldd	r24, Y+47	; 0x2f
    3f50:	98 a9       	ldd	r25, Y+48	; 0x30
    3f52:	9c a7       	std	Y+44, r25	; 0x2c
    3f54:	8b a7       	std	Y+43, r24	; 0x2b
    3f56:	8b a5       	ldd	r24, Y+43	; 0x2b
    3f58:	9c a5       	ldd	r25, Y+44	; 0x2c
    3f5a:	01 97       	sbiw	r24, 0x01	; 1
    3f5c:	f1 f7       	brne	.-4      	; 0x3f5a <lcd_set_4bit+0x6b2>
    3f5e:	9c a7       	std	Y+44, r25	; 0x2c
    3f60:	8b a7       	std	Y+43, r24	; 0x2b

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
    3f62:	a8 e2       	ldi	r26, 0x28	; 40
    3f64:	b0 e0       	ldi	r27, 0x00	; 0
    3f66:	e8 e2       	ldi	r30, 0x28	; 40
    3f68:	f0 e0       	ldi	r31, 0x00	; 0
    3f6a:	80 81       	ld	r24, Z
    3f6c:	8e 7f       	andi	r24, 0xFE	; 254
    3f6e:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
    3f70:	a8 e2       	ldi	r26, 0x28	; 40
    3f72:	b0 e0       	ldi	r27, 0x00	; 0
    3f74:	e8 e2       	ldi	r30, 0x28	; 40
    3f76:	f0 e0       	ldi	r31, 0x00	; 0
    3f78:	80 81       	ld	r24, Z
    3f7a:	8d 7f       	andi	r24, 0xFD	; 253
    3f7c:	8c 93       	st	X, r24
	lcd_port = 0x30;				//Sending 3
    3f7e:	e8 e2       	ldi	r30, 0x28	; 40
    3f80:	f0 e0       	ldi	r31, 0x00	; 0
    3f82:	80 e3       	ldi	r24, 0x30	; 48
    3f84:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
    3f86:	a8 e2       	ldi	r26, 0x28	; 40
    3f88:	b0 e0       	ldi	r27, 0x00	; 0
    3f8a:	e8 e2       	ldi	r30, 0x28	; 40
    3f8c:	f0 e0       	ldi	r31, 0x00	; 0
    3f8e:	80 81       	ld	r24, Z
    3f90:	84 60       	ori	r24, 0x04	; 4
    3f92:	8c 93       	st	X, r24
    3f94:	80 e0       	ldi	r24, 0x00	; 0
    3f96:	90 e0       	ldi	r25, 0x00	; 0
    3f98:	a0 ea       	ldi	r26, 0xA0	; 160
    3f9a:	b0 e4       	ldi	r27, 0x40	; 64
    3f9c:	8f a3       	std	Y+39, r24	; 0x27
    3f9e:	98 a7       	std	Y+40, r25	; 0x28
    3fa0:	a9 a7       	std	Y+41, r26	; 0x29
    3fa2:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3fa4:	6f a1       	ldd	r22, Y+39	; 0x27
    3fa6:	78 a5       	ldd	r23, Y+40	; 0x28
    3fa8:	89 a5       	ldd	r24, Y+41	; 0x29
    3faa:	9a a5       	ldd	r25, Y+42	; 0x2a
    3fac:	26 e6       	ldi	r18, 0x66	; 102
    3fae:	36 e6       	ldi	r19, 0x66	; 102
    3fb0:	46 e6       	ldi	r20, 0x66	; 102
    3fb2:	55 e4       	ldi	r21, 0x45	; 69
    3fb4:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    3fb8:	dc 01       	movw	r26, r24
    3fba:	cb 01       	movw	r24, r22
    3fbc:	8b a3       	std	Y+35, r24	; 0x23
    3fbe:	9c a3       	std	Y+36, r25	; 0x24
    3fc0:	ad a3       	std	Y+37, r26	; 0x25
    3fc2:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3fc4:	6b a1       	ldd	r22, Y+35	; 0x23
    3fc6:	7c a1       	ldd	r23, Y+36	; 0x24
    3fc8:	8d a1       	ldd	r24, Y+37	; 0x25
    3fca:	9e a1       	ldd	r25, Y+38	; 0x26
    3fcc:	20 e0       	ldi	r18, 0x00	; 0
    3fce:	30 e0       	ldi	r19, 0x00	; 0
    3fd0:	40 e8       	ldi	r20, 0x80	; 128
    3fd2:	5f e3       	ldi	r21, 0x3F	; 63
    3fd4:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    3fd8:	88 23       	and	r24, r24
    3fda:	2c f4       	brge	.+10     	; 0x3fe6 <lcd_set_4bit+0x73e>
		__ticks = 1;
    3fdc:	81 e0       	ldi	r24, 0x01	; 1
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	9a a3       	std	Y+34, r25	; 0x22
    3fe2:	89 a3       	std	Y+33, r24	; 0x21
    3fe4:	3f c0       	rjmp	.+126    	; 0x4064 <lcd_set_4bit+0x7bc>
	else if (__tmp > 65535)
    3fe6:	6b a1       	ldd	r22, Y+35	; 0x23
    3fe8:	7c a1       	ldd	r23, Y+36	; 0x24
    3fea:	8d a1       	ldd	r24, Y+37	; 0x25
    3fec:	9e a1       	ldd	r25, Y+38	; 0x26
    3fee:	20 e0       	ldi	r18, 0x00	; 0
    3ff0:	3f ef       	ldi	r19, 0xFF	; 255
    3ff2:	4f e7       	ldi	r20, 0x7F	; 127
    3ff4:	57 e4       	ldi	r21, 0x47	; 71
    3ff6:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    3ffa:	18 16       	cp	r1, r24
    3ffc:	4c f5       	brge	.+82     	; 0x4050 <lcd_set_4bit+0x7a8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ffe:	6f a1       	ldd	r22, Y+39	; 0x27
    4000:	78 a5       	ldd	r23, Y+40	; 0x28
    4002:	89 a5       	ldd	r24, Y+41	; 0x29
    4004:	9a a5       	ldd	r25, Y+42	; 0x2a
    4006:	20 e0       	ldi	r18, 0x00	; 0
    4008:	30 e0       	ldi	r19, 0x00	; 0
    400a:	40 e2       	ldi	r20, 0x20	; 32
    400c:	51 e4       	ldi	r21, 0x41	; 65
    400e:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    4012:	dc 01       	movw	r26, r24
    4014:	cb 01       	movw	r24, r22
    4016:	bc 01       	movw	r22, r24
    4018:	cd 01       	movw	r24, r26
    401a:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    401e:	dc 01       	movw	r26, r24
    4020:	cb 01       	movw	r24, r22
    4022:	9a a3       	std	Y+34, r25	; 0x22
    4024:	89 a3       	std	Y+33, r24	; 0x21
    4026:	0f c0       	rjmp	.+30     	; 0x4046 <lcd_set_4bit+0x79e>
    4028:	80 e7       	ldi	r24, 0x70	; 112
    402a:	91 e0       	ldi	r25, 0x01	; 1
    402c:	98 a3       	std	Y+32, r25	; 0x20
    402e:	8f 8f       	std	Y+31, r24	; 0x1f
    4030:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4032:	98 a1       	ldd	r25, Y+32	; 0x20
    4034:	01 97       	sbiw	r24, 0x01	; 1
    4036:	f1 f7       	brne	.-4      	; 0x4034 <lcd_set_4bit+0x78c>
    4038:	98 a3       	std	Y+32, r25	; 0x20
    403a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    403c:	89 a1       	ldd	r24, Y+33	; 0x21
    403e:	9a a1       	ldd	r25, Y+34	; 0x22
    4040:	01 97       	sbiw	r24, 0x01	; 1
    4042:	9a a3       	std	Y+34, r25	; 0x22
    4044:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4046:	89 a1       	ldd	r24, Y+33	; 0x21
    4048:	9a a1       	ldd	r25, Y+34	; 0x22
    404a:	00 97       	sbiw	r24, 0x00	; 0
    404c:	69 f7       	brne	.-38     	; 0x4028 <lcd_set_4bit+0x780>
    404e:	14 c0       	rjmp	.+40     	; 0x4078 <lcd_set_4bit+0x7d0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4050:	6b a1       	ldd	r22, Y+35	; 0x23
    4052:	7c a1       	ldd	r23, Y+36	; 0x24
    4054:	8d a1       	ldd	r24, Y+37	; 0x25
    4056:	9e a1       	ldd	r25, Y+38	; 0x26
    4058:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    405c:	dc 01       	movw	r26, r24
    405e:	cb 01       	movw	r24, r22
    4060:	9a a3       	std	Y+34, r25	; 0x22
    4062:	89 a3       	std	Y+33, r24	; 0x21
    4064:	89 a1       	ldd	r24, Y+33	; 0x21
    4066:	9a a1       	ldd	r25, Y+34	; 0x22
    4068:	9e 8f       	std	Y+30, r25	; 0x1e
    406a:	8d 8f       	std	Y+29, r24	; 0x1d
    406c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    406e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4070:	01 97       	sbiw	r24, 0x01	; 1
    4072:	f1 f7       	brne	.-4      	; 0x4070 <lcd_set_4bit+0x7c8>
    4074:	9e 8f       	std	Y+30, r25	; 0x1e
    4076:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
    4078:	a8 e2       	ldi	r26, 0x28	; 40
    407a:	b0 e0       	ldi	r27, 0x00	; 0
    407c:	e8 e2       	ldi	r30, 0x28	; 40
    407e:	f0 e0       	ldi	r31, 0x00	; 0
    4080:	80 81       	ld	r24, Z
    4082:	8b 7f       	andi	r24, 0xFB	; 251
    4084:	8c 93       	st	X, r24
    4086:	80 e0       	ldi	r24, 0x00	; 0
    4088:	90 e0       	ldi	r25, 0x00	; 0
    408a:	a0 e8       	ldi	r26, 0x80	; 128
    408c:	bf e3       	ldi	r27, 0x3F	; 63
    408e:	89 8f       	std	Y+25, r24	; 0x19
    4090:	9a 8f       	std	Y+26, r25	; 0x1a
    4092:	ab 8f       	std	Y+27, r26	; 0x1b
    4094:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4096:	69 8d       	ldd	r22, Y+25	; 0x19
    4098:	7a 8d       	ldd	r23, Y+26	; 0x1a
    409a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    409c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    409e:	26 e6       	ldi	r18, 0x66	; 102
    40a0:	36 e6       	ldi	r19, 0x66	; 102
    40a2:	46 e6       	ldi	r20, 0x66	; 102
    40a4:	55 e4       	ldi	r21, 0x45	; 69
    40a6:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    40aa:	dc 01       	movw	r26, r24
    40ac:	cb 01       	movw	r24, r22
    40ae:	8d 8b       	std	Y+21, r24	; 0x15
    40b0:	9e 8b       	std	Y+22, r25	; 0x16
    40b2:	af 8b       	std	Y+23, r26	; 0x17
    40b4:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    40b6:	6d 89       	ldd	r22, Y+21	; 0x15
    40b8:	7e 89       	ldd	r23, Y+22	; 0x16
    40ba:	8f 89       	ldd	r24, Y+23	; 0x17
    40bc:	98 8d       	ldd	r25, Y+24	; 0x18
    40be:	20 e0       	ldi	r18, 0x00	; 0
    40c0:	30 e0       	ldi	r19, 0x00	; 0
    40c2:	40 e8       	ldi	r20, 0x80	; 128
    40c4:	5f e3       	ldi	r21, 0x3F	; 63
    40c6:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    40ca:	88 23       	and	r24, r24
    40cc:	2c f4       	brge	.+10     	; 0x40d8 <lcd_set_4bit+0x830>
		__ticks = 1;
    40ce:	81 e0       	ldi	r24, 0x01	; 1
    40d0:	90 e0       	ldi	r25, 0x00	; 0
    40d2:	9c 8b       	std	Y+20, r25	; 0x14
    40d4:	8b 8b       	std	Y+19, r24	; 0x13
    40d6:	3f c0       	rjmp	.+126    	; 0x4156 <lcd_set_4bit+0x8ae>
	else if (__tmp > 65535)
    40d8:	6d 89       	ldd	r22, Y+21	; 0x15
    40da:	7e 89       	ldd	r23, Y+22	; 0x16
    40dc:	8f 89       	ldd	r24, Y+23	; 0x17
    40de:	98 8d       	ldd	r25, Y+24	; 0x18
    40e0:	20 e0       	ldi	r18, 0x00	; 0
    40e2:	3f ef       	ldi	r19, 0xFF	; 255
    40e4:	4f e7       	ldi	r20, 0x7F	; 127
    40e6:	57 e4       	ldi	r21, 0x47	; 71
    40e8:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    40ec:	18 16       	cp	r1, r24
    40ee:	4c f5       	brge	.+82     	; 0x4142 <lcd_set_4bit+0x89a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    40f0:	69 8d       	ldd	r22, Y+25	; 0x19
    40f2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    40f4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    40f6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    40f8:	20 e0       	ldi	r18, 0x00	; 0
    40fa:	30 e0       	ldi	r19, 0x00	; 0
    40fc:	40 e2       	ldi	r20, 0x20	; 32
    40fe:	51 e4       	ldi	r21, 0x41	; 65
    4100:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    4104:	dc 01       	movw	r26, r24
    4106:	cb 01       	movw	r24, r22
    4108:	bc 01       	movw	r22, r24
    410a:	cd 01       	movw	r24, r26
    410c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4110:	dc 01       	movw	r26, r24
    4112:	cb 01       	movw	r24, r22
    4114:	9c 8b       	std	Y+20, r25	; 0x14
    4116:	8b 8b       	std	Y+19, r24	; 0x13
    4118:	0f c0       	rjmp	.+30     	; 0x4138 <lcd_set_4bit+0x890>
    411a:	80 e7       	ldi	r24, 0x70	; 112
    411c:	91 e0       	ldi	r25, 0x01	; 1
    411e:	9a 8b       	std	Y+18, r25	; 0x12
    4120:	89 8b       	std	Y+17, r24	; 0x11
    4122:	89 89       	ldd	r24, Y+17	; 0x11
    4124:	9a 89       	ldd	r25, Y+18	; 0x12
    4126:	01 97       	sbiw	r24, 0x01	; 1
    4128:	f1 f7       	brne	.-4      	; 0x4126 <lcd_set_4bit+0x87e>
    412a:	9a 8b       	std	Y+18, r25	; 0x12
    412c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    412e:	8b 89       	ldd	r24, Y+19	; 0x13
    4130:	9c 89       	ldd	r25, Y+20	; 0x14
    4132:	01 97       	sbiw	r24, 0x01	; 1
    4134:	9c 8b       	std	Y+20, r25	; 0x14
    4136:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4138:	8b 89       	ldd	r24, Y+19	; 0x13
    413a:	9c 89       	ldd	r25, Y+20	; 0x14
    413c:	00 97       	sbiw	r24, 0x00	; 0
    413e:	69 f7       	brne	.-38     	; 0x411a <lcd_set_4bit+0x872>
    4140:	14 c0       	rjmp	.+40     	; 0x416a <lcd_set_4bit+0x8c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4142:	6d 89       	ldd	r22, Y+21	; 0x15
    4144:	7e 89       	ldd	r23, Y+22	; 0x16
    4146:	8f 89       	ldd	r24, Y+23	; 0x17
    4148:	98 8d       	ldd	r25, Y+24	; 0x18
    414a:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    414e:	dc 01       	movw	r26, r24
    4150:	cb 01       	movw	r24, r22
    4152:	9c 8b       	std	Y+20, r25	; 0x14
    4154:	8b 8b       	std	Y+19, r24	; 0x13
    4156:	8b 89       	ldd	r24, Y+19	; 0x13
    4158:	9c 89       	ldd	r25, Y+20	; 0x14
    415a:	98 8b       	std	Y+16, r25	; 0x10
    415c:	8f 87       	std	Y+15, r24	; 0x0f
    415e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4160:	98 89       	ldd	r25, Y+16	; 0x10
    4162:	01 97       	sbiw	r24, 0x01	; 1
    4164:	f1 f7       	brne	.-4      	; 0x4162 <lcd_set_4bit+0x8ba>
    4166:	98 8b       	std	Y+16, r25	; 0x10
    4168:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
    416a:	a8 e2       	ldi	r26, 0x28	; 40
    416c:	b0 e0       	ldi	r27, 0x00	; 0
    416e:	e8 e2       	ldi	r30, 0x28	; 40
    4170:	f0 e0       	ldi	r31, 0x00	; 0
    4172:	80 81       	ld	r24, Z
    4174:	8e 7f       	andi	r24, 0xFE	; 254
    4176:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
    4178:	a8 e2       	ldi	r26, 0x28	; 40
    417a:	b0 e0       	ldi	r27, 0x00	; 0
    417c:	e8 e2       	ldi	r30, 0x28	; 40
    417e:	f0 e0       	ldi	r31, 0x00	; 0
    4180:	80 81       	ld	r24, Z
    4182:	8d 7f       	andi	r24, 0xFD	; 253
    4184:	8c 93       	st	X, r24
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
    4186:	e8 e2       	ldi	r30, 0x28	; 40
    4188:	f0 e0       	ldi	r31, 0x00	; 0
    418a:	80 e2       	ldi	r24, 0x20	; 32
    418c:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
    418e:	a8 e2       	ldi	r26, 0x28	; 40
    4190:	b0 e0       	ldi	r27, 0x00	; 0
    4192:	e8 e2       	ldi	r30, 0x28	; 40
    4194:	f0 e0       	ldi	r31, 0x00	; 0
    4196:	80 81       	ld	r24, Z
    4198:	84 60       	ori	r24, 0x04	; 4
    419a:	8c 93       	st	X, r24
    419c:	80 e0       	ldi	r24, 0x00	; 0
    419e:	90 e0       	ldi	r25, 0x00	; 0
    41a0:	a0 ea       	ldi	r26, 0xA0	; 160
    41a2:	b0 e4       	ldi	r27, 0x40	; 64
    41a4:	8b 87       	std	Y+11, r24	; 0x0b
    41a6:	9c 87       	std	Y+12, r25	; 0x0c
    41a8:	ad 87       	std	Y+13, r26	; 0x0d
    41aa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    41ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    41ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    41b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    41b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    41b4:	26 e6       	ldi	r18, 0x66	; 102
    41b6:	36 e6       	ldi	r19, 0x66	; 102
    41b8:	46 e6       	ldi	r20, 0x66	; 102
    41ba:	55 e4       	ldi	r21, 0x45	; 69
    41bc:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    41c0:	dc 01       	movw	r26, r24
    41c2:	cb 01       	movw	r24, r22
    41c4:	8f 83       	std	Y+7, r24	; 0x07
    41c6:	98 87       	std	Y+8, r25	; 0x08
    41c8:	a9 87       	std	Y+9, r26	; 0x09
    41ca:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    41cc:	6f 81       	ldd	r22, Y+7	; 0x07
    41ce:	78 85       	ldd	r23, Y+8	; 0x08
    41d0:	89 85       	ldd	r24, Y+9	; 0x09
    41d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    41d4:	20 e0       	ldi	r18, 0x00	; 0
    41d6:	30 e0       	ldi	r19, 0x00	; 0
    41d8:	40 e8       	ldi	r20, 0x80	; 128
    41da:	5f e3       	ldi	r21, 0x3F	; 63
    41dc:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    41e0:	88 23       	and	r24, r24
    41e2:	2c f4       	brge	.+10     	; 0x41ee <lcd_set_4bit+0x946>
		__ticks = 1;
    41e4:	81 e0       	ldi	r24, 0x01	; 1
    41e6:	90 e0       	ldi	r25, 0x00	; 0
    41e8:	9e 83       	std	Y+6, r25	; 0x06
    41ea:	8d 83       	std	Y+5, r24	; 0x05
    41ec:	3f c0       	rjmp	.+126    	; 0x426c <lcd_set_4bit+0x9c4>
	else if (__tmp > 65535)
    41ee:	6f 81       	ldd	r22, Y+7	; 0x07
    41f0:	78 85       	ldd	r23, Y+8	; 0x08
    41f2:	89 85       	ldd	r24, Y+9	; 0x09
    41f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    41f6:	20 e0       	ldi	r18, 0x00	; 0
    41f8:	3f ef       	ldi	r19, 0xFF	; 255
    41fa:	4f e7       	ldi	r20, 0x7F	; 127
    41fc:	57 e4       	ldi	r21, 0x47	; 71
    41fe:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    4202:	18 16       	cp	r1, r24
    4204:	4c f5       	brge	.+82     	; 0x4258 <lcd_set_4bit+0x9b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4206:	6b 85       	ldd	r22, Y+11	; 0x0b
    4208:	7c 85       	ldd	r23, Y+12	; 0x0c
    420a:	8d 85       	ldd	r24, Y+13	; 0x0d
    420c:	9e 85       	ldd	r25, Y+14	; 0x0e
    420e:	20 e0       	ldi	r18, 0x00	; 0
    4210:	30 e0       	ldi	r19, 0x00	; 0
    4212:	40 e2       	ldi	r20, 0x20	; 32
    4214:	51 e4       	ldi	r21, 0x41	; 65
    4216:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    421a:	dc 01       	movw	r26, r24
    421c:	cb 01       	movw	r24, r22
    421e:	bc 01       	movw	r22, r24
    4220:	cd 01       	movw	r24, r26
    4222:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4226:	dc 01       	movw	r26, r24
    4228:	cb 01       	movw	r24, r22
    422a:	9e 83       	std	Y+6, r25	; 0x06
    422c:	8d 83       	std	Y+5, r24	; 0x05
    422e:	0f c0       	rjmp	.+30     	; 0x424e <lcd_set_4bit+0x9a6>
    4230:	80 e7       	ldi	r24, 0x70	; 112
    4232:	91 e0       	ldi	r25, 0x01	; 1
    4234:	9c 83       	std	Y+4, r25	; 0x04
    4236:	8b 83       	std	Y+3, r24	; 0x03
    4238:	8b 81       	ldd	r24, Y+3	; 0x03
    423a:	9c 81       	ldd	r25, Y+4	; 0x04
    423c:	01 97       	sbiw	r24, 0x01	; 1
    423e:	f1 f7       	brne	.-4      	; 0x423c <lcd_set_4bit+0x994>
    4240:	9c 83       	std	Y+4, r25	; 0x04
    4242:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4244:	8d 81       	ldd	r24, Y+5	; 0x05
    4246:	9e 81       	ldd	r25, Y+6	; 0x06
    4248:	01 97       	sbiw	r24, 0x01	; 1
    424a:	9e 83       	std	Y+6, r25	; 0x06
    424c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    424e:	8d 81       	ldd	r24, Y+5	; 0x05
    4250:	9e 81       	ldd	r25, Y+6	; 0x06
    4252:	00 97       	sbiw	r24, 0x00	; 0
    4254:	69 f7       	brne	.-38     	; 0x4230 <lcd_set_4bit+0x988>
    4256:	14 c0       	rjmp	.+40     	; 0x4280 <lcd_set_4bit+0x9d8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4258:	6f 81       	ldd	r22, Y+7	; 0x07
    425a:	78 85       	ldd	r23, Y+8	; 0x08
    425c:	89 85       	ldd	r24, Y+9	; 0x09
    425e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4260:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4264:	dc 01       	movw	r26, r24
    4266:	cb 01       	movw	r24, r22
    4268:	9e 83       	std	Y+6, r25	; 0x06
    426a:	8d 83       	std	Y+5, r24	; 0x05
    426c:	8d 81       	ldd	r24, Y+5	; 0x05
    426e:	9e 81       	ldd	r25, Y+6	; 0x06
    4270:	9a 83       	std	Y+2, r25	; 0x02
    4272:	89 83       	std	Y+1, r24	; 0x01
    4274:	89 81       	ldd	r24, Y+1	; 0x01
    4276:	9a 81       	ldd	r25, Y+2	; 0x02
    4278:	01 97       	sbiw	r24, 0x01	; 1
    427a:	f1 f7       	brne	.-4      	; 0x4278 <lcd_set_4bit+0x9d0>
    427c:	9a 83       	std	Y+2, r25	; 0x02
    427e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
    4280:	a8 e2       	ldi	r26, 0x28	; 40
    4282:	b0 e0       	ldi	r27, 0x00	; 0
    4284:	e8 e2       	ldi	r30, 0x28	; 40
    4286:	f0 e0       	ldi	r31, 0x00	; 0
    4288:	80 81       	ld	r24, Z
    428a:	8b 7f       	andi	r24, 0xFB	; 251
    428c:	8c 93       	st	X, r24

	
}
    428e:	c0 59       	subi	r28, 0x90	; 144
    4290:	df 4f       	sbci	r29, 0xFF	; 255
    4292:	0f b6       	in	r0, 0x3f	; 63
    4294:	f8 94       	cli
    4296:	de bf       	out	0x3e, r29	; 62
    4298:	0f be       	out	0x3f, r0	; 63
    429a:	cd bf       	out	0x3d, r28	; 61
    429c:	cf 91       	pop	r28
    429e:	df 91       	pop	r29
    42a0:	1f 91       	pop	r17
    42a2:	0f 91       	pop	r16
    42a4:	08 95       	ret

000042a6 <lcd_init>:

/*****Function to Initialize LCD*****/
void lcd_init()
{
    42a6:	df 93       	push	r29
    42a8:	cf 93       	push	r28
    42aa:	cd b7       	in	r28, 0x3d	; 61
    42ac:	de b7       	in	r29, 0x3e	; 62
    42ae:	2e 97       	sbiw	r28, 0x0e	; 14
    42b0:	0f b6       	in	r0, 0x3f	; 63
    42b2:	f8 94       	cli
    42b4:	de bf       	out	0x3e, r29	; 62
    42b6:	0f be       	out	0x3f, r0	; 63
    42b8:	cd bf       	out	0x3d, r28	; 61
    42ba:	80 e0       	ldi	r24, 0x00	; 0
    42bc:	90 e0       	ldi	r25, 0x00	; 0
    42be:	a0 e8       	ldi	r26, 0x80	; 128
    42c0:	bf e3       	ldi	r27, 0x3F	; 63
    42c2:	8b 87       	std	Y+11, r24	; 0x0b
    42c4:	9c 87       	std	Y+12, r25	; 0x0c
    42c6:	ad 87       	std	Y+13, r26	; 0x0d
    42c8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    42ca:	6b 85       	ldd	r22, Y+11	; 0x0b
    42cc:	7c 85       	ldd	r23, Y+12	; 0x0c
    42ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    42d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    42d2:	26 e6       	ldi	r18, 0x66	; 102
    42d4:	36 e6       	ldi	r19, 0x66	; 102
    42d6:	46 e6       	ldi	r20, 0x66	; 102
    42d8:	55 e4       	ldi	r21, 0x45	; 69
    42da:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    42de:	dc 01       	movw	r26, r24
    42e0:	cb 01       	movw	r24, r22
    42e2:	8f 83       	std	Y+7, r24	; 0x07
    42e4:	98 87       	std	Y+8, r25	; 0x08
    42e6:	a9 87       	std	Y+9, r26	; 0x09
    42e8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    42ea:	6f 81       	ldd	r22, Y+7	; 0x07
    42ec:	78 85       	ldd	r23, Y+8	; 0x08
    42ee:	89 85       	ldd	r24, Y+9	; 0x09
    42f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    42f2:	20 e0       	ldi	r18, 0x00	; 0
    42f4:	30 e0       	ldi	r19, 0x00	; 0
    42f6:	40 e8       	ldi	r20, 0x80	; 128
    42f8:	5f e3       	ldi	r21, 0x3F	; 63
    42fa:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    42fe:	88 23       	and	r24, r24
    4300:	2c f4       	brge	.+10     	; 0x430c <lcd_init+0x66>
		__ticks = 1;
    4302:	81 e0       	ldi	r24, 0x01	; 1
    4304:	90 e0       	ldi	r25, 0x00	; 0
    4306:	9e 83       	std	Y+6, r25	; 0x06
    4308:	8d 83       	std	Y+5, r24	; 0x05
    430a:	3f c0       	rjmp	.+126    	; 0x438a <lcd_init+0xe4>
	else if (__tmp > 65535)
    430c:	6f 81       	ldd	r22, Y+7	; 0x07
    430e:	78 85       	ldd	r23, Y+8	; 0x08
    4310:	89 85       	ldd	r24, Y+9	; 0x09
    4312:	9a 85       	ldd	r25, Y+10	; 0x0a
    4314:	20 e0       	ldi	r18, 0x00	; 0
    4316:	3f ef       	ldi	r19, 0xFF	; 255
    4318:	4f e7       	ldi	r20, 0x7F	; 127
    431a:	57 e4       	ldi	r21, 0x47	; 71
    431c:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    4320:	18 16       	cp	r1, r24
    4322:	4c f5       	brge	.+82     	; 0x4376 <lcd_init+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4324:	6b 85       	ldd	r22, Y+11	; 0x0b
    4326:	7c 85       	ldd	r23, Y+12	; 0x0c
    4328:	8d 85       	ldd	r24, Y+13	; 0x0d
    432a:	9e 85       	ldd	r25, Y+14	; 0x0e
    432c:	20 e0       	ldi	r18, 0x00	; 0
    432e:	30 e0       	ldi	r19, 0x00	; 0
    4330:	40 e2       	ldi	r20, 0x20	; 32
    4332:	51 e4       	ldi	r21, 0x41	; 65
    4334:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    4338:	dc 01       	movw	r26, r24
    433a:	cb 01       	movw	r24, r22
    433c:	bc 01       	movw	r22, r24
    433e:	cd 01       	movw	r24, r26
    4340:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4344:	dc 01       	movw	r26, r24
    4346:	cb 01       	movw	r24, r22
    4348:	9e 83       	std	Y+6, r25	; 0x06
    434a:	8d 83       	std	Y+5, r24	; 0x05
    434c:	0f c0       	rjmp	.+30     	; 0x436c <lcd_init+0xc6>
    434e:	80 e7       	ldi	r24, 0x70	; 112
    4350:	91 e0       	ldi	r25, 0x01	; 1
    4352:	9c 83       	std	Y+4, r25	; 0x04
    4354:	8b 83       	std	Y+3, r24	; 0x03
    4356:	8b 81       	ldd	r24, Y+3	; 0x03
    4358:	9c 81       	ldd	r25, Y+4	; 0x04
    435a:	01 97       	sbiw	r24, 0x01	; 1
    435c:	f1 f7       	brne	.-4      	; 0x435a <lcd_init+0xb4>
    435e:	9c 83       	std	Y+4, r25	; 0x04
    4360:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4362:	8d 81       	ldd	r24, Y+5	; 0x05
    4364:	9e 81       	ldd	r25, Y+6	; 0x06
    4366:	01 97       	sbiw	r24, 0x01	; 1
    4368:	9e 83       	std	Y+6, r25	; 0x06
    436a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    436c:	8d 81       	ldd	r24, Y+5	; 0x05
    436e:	9e 81       	ldd	r25, Y+6	; 0x06
    4370:	00 97       	sbiw	r24, 0x00	; 0
    4372:	69 f7       	brne	.-38     	; 0x434e <lcd_init+0xa8>
    4374:	14 c0       	rjmp	.+40     	; 0x439e <lcd_init+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4376:	6f 81       	ldd	r22, Y+7	; 0x07
    4378:	78 85       	ldd	r23, Y+8	; 0x08
    437a:	89 85       	ldd	r24, Y+9	; 0x09
    437c:	9a 85       	ldd	r25, Y+10	; 0x0a
    437e:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4382:	dc 01       	movw	r26, r24
    4384:	cb 01       	movw	r24, r22
    4386:	9e 83       	std	Y+6, r25	; 0x06
    4388:	8d 83       	std	Y+5, r24	; 0x05
    438a:	8d 81       	ldd	r24, Y+5	; 0x05
    438c:	9e 81       	ldd	r25, Y+6	; 0x06
    438e:	9a 83       	std	Y+2, r25	; 0x02
    4390:	89 83       	std	Y+1, r24	; 0x01
    4392:	89 81       	ldd	r24, Y+1	; 0x01
    4394:	9a 81       	ldd	r25, Y+2	; 0x02
    4396:	01 97       	sbiw	r24, 0x01	; 1
    4398:	f1 f7       	brne	.-4      	; 0x4396 <lcd_init+0xf0>
    439a:	9a 83       	std	Y+2, r25	; 0x02
    439c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
    439e:	88 e2       	ldi	r24, 0x28	; 40
    43a0:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
	lcd_wr_command(0x01);
    43a4:	81 e0       	ldi	r24, 0x01	; 1
    43a6:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
	lcd_wr_command(0x06);
    43aa:	86 e0       	ldi	r24, 0x06	; 6
    43ac:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
	lcd_wr_command(0x0E);
    43b0:	8e e0       	ldi	r24, 0x0E	; 14
    43b2:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
	lcd_wr_command(0x80);
    43b6:	80 e8       	ldi	r24, 0x80	; 128
    43b8:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
		
}
    43bc:	2e 96       	adiw	r28, 0x0e	; 14
    43be:	0f b6       	in	r0, 0x3f	; 63
    43c0:	f8 94       	cli
    43c2:	de bf       	out	0x3e, r29	; 62
    43c4:	0f be       	out	0x3f, r0	; 63
    43c6:	cd bf       	out	0x3d, r28	; 61
    43c8:	cf 91       	pop	r28
    43ca:	df 91       	pop	r29
    43cc:	08 95       	ret

000043ce <lcd_wr_command>:

	 
/*****Function to Write Command on LCD*****/
void lcd_wr_command(unsigned char cmd)
{
    43ce:	df 93       	push	r29
    43d0:	cf 93       	push	r28
    43d2:	cd b7       	in	r28, 0x3d	; 61
    43d4:	de b7       	in	r29, 0x3e	; 62
    43d6:	6e 97       	sbiw	r28, 0x1e	; 30
    43d8:	0f b6       	in	r0, 0x3f	; 63
    43da:	f8 94       	cli
    43dc:	de bf       	out	0x3e, r29	; 62
    43de:	0f be       	out	0x3f, r0	; 63
    43e0:	cd bf       	out	0x3d, r28	; 61
    43e2:	8e 8f       	std	Y+30, r24	; 0x1e
	unsigned char temp;
	temp = cmd;
    43e4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    43e6:	8d 8f       	std	Y+29, r24	; 0x1d
	temp = temp & 0xF0;
    43e8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    43ea:	80 7f       	andi	r24, 0xF0	; 240
    43ec:	8d 8f       	std	Y+29, r24	; 0x1d
	lcd_port &= 0x0F;
    43ee:	a8 e2       	ldi	r26, 0x28	; 40
    43f0:	b0 e0       	ldi	r27, 0x00	; 0
    43f2:	e8 e2       	ldi	r30, 0x28	; 40
    43f4:	f0 e0       	ldi	r31, 0x00	; 0
    43f6:	80 81       	ld	r24, Z
    43f8:	8f 70       	andi	r24, 0x0F	; 15
    43fa:	8c 93       	st	X, r24
	lcd_port |= temp;
    43fc:	a8 e2       	ldi	r26, 0x28	; 40
    43fe:	b0 e0       	ldi	r27, 0x00	; 0
    4400:	e8 e2       	ldi	r30, 0x28	; 40
    4402:	f0 e0       	ldi	r31, 0x00	; 0
    4404:	90 81       	ld	r25, Z
    4406:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4408:	89 2b       	or	r24, r25
    440a:	8c 93       	st	X, r24
	cbit(lcd_port,RS);
    440c:	a8 e2       	ldi	r26, 0x28	; 40
    440e:	b0 e0       	ldi	r27, 0x00	; 0
    4410:	e8 e2       	ldi	r30, 0x28	; 40
    4412:	f0 e0       	ldi	r31, 0x00	; 0
    4414:	80 81       	ld	r24, Z
    4416:	8e 7f       	andi	r24, 0xFE	; 254
    4418:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
    441a:	a8 e2       	ldi	r26, 0x28	; 40
    441c:	b0 e0       	ldi	r27, 0x00	; 0
    441e:	e8 e2       	ldi	r30, 0x28	; 40
    4420:	f0 e0       	ldi	r31, 0x00	; 0
    4422:	80 81       	ld	r24, Z
    4424:	8d 7f       	andi	r24, 0xFD	; 253
    4426:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
    4428:	a8 e2       	ldi	r26, 0x28	; 40
    442a:	b0 e0       	ldi	r27, 0x00	; 0
    442c:	e8 e2       	ldi	r30, 0x28	; 40
    442e:	f0 e0       	ldi	r31, 0x00	; 0
    4430:	80 81       	ld	r24, Z
    4432:	84 60       	ori	r24, 0x04	; 4
    4434:	8c 93       	st	X, r24
    4436:	80 e0       	ldi	r24, 0x00	; 0
    4438:	90 e0       	ldi	r25, 0x00	; 0
    443a:	a0 ea       	ldi	r26, 0xA0	; 160
    443c:	b0 e4       	ldi	r27, 0x40	; 64
    443e:	89 8f       	std	Y+25, r24	; 0x19
    4440:	9a 8f       	std	Y+26, r25	; 0x1a
    4442:	ab 8f       	std	Y+27, r26	; 0x1b
    4444:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4446:	69 8d       	ldd	r22, Y+25	; 0x19
    4448:	7a 8d       	ldd	r23, Y+26	; 0x1a
    444a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    444c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    444e:	26 e6       	ldi	r18, 0x66	; 102
    4450:	36 e6       	ldi	r19, 0x66	; 102
    4452:	46 e6       	ldi	r20, 0x66	; 102
    4454:	55 e4       	ldi	r21, 0x45	; 69
    4456:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    445a:	dc 01       	movw	r26, r24
    445c:	cb 01       	movw	r24, r22
    445e:	8d 8b       	std	Y+21, r24	; 0x15
    4460:	9e 8b       	std	Y+22, r25	; 0x16
    4462:	af 8b       	std	Y+23, r26	; 0x17
    4464:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4466:	6d 89       	ldd	r22, Y+21	; 0x15
    4468:	7e 89       	ldd	r23, Y+22	; 0x16
    446a:	8f 89       	ldd	r24, Y+23	; 0x17
    446c:	98 8d       	ldd	r25, Y+24	; 0x18
    446e:	20 e0       	ldi	r18, 0x00	; 0
    4470:	30 e0       	ldi	r19, 0x00	; 0
    4472:	40 e8       	ldi	r20, 0x80	; 128
    4474:	5f e3       	ldi	r21, 0x3F	; 63
    4476:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    447a:	88 23       	and	r24, r24
    447c:	2c f4       	brge	.+10     	; 0x4488 <lcd_wr_command+0xba>
		__ticks = 1;
    447e:	81 e0       	ldi	r24, 0x01	; 1
    4480:	90 e0       	ldi	r25, 0x00	; 0
    4482:	9c 8b       	std	Y+20, r25	; 0x14
    4484:	8b 8b       	std	Y+19, r24	; 0x13
    4486:	3f c0       	rjmp	.+126    	; 0x4506 <lcd_wr_command+0x138>
	else if (__tmp > 65535)
    4488:	6d 89       	ldd	r22, Y+21	; 0x15
    448a:	7e 89       	ldd	r23, Y+22	; 0x16
    448c:	8f 89       	ldd	r24, Y+23	; 0x17
    448e:	98 8d       	ldd	r25, Y+24	; 0x18
    4490:	20 e0       	ldi	r18, 0x00	; 0
    4492:	3f ef       	ldi	r19, 0xFF	; 255
    4494:	4f e7       	ldi	r20, 0x7F	; 127
    4496:	57 e4       	ldi	r21, 0x47	; 71
    4498:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    449c:	18 16       	cp	r1, r24
    449e:	4c f5       	brge	.+82     	; 0x44f2 <lcd_wr_command+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    44a0:	69 8d       	ldd	r22, Y+25	; 0x19
    44a2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    44a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    44a6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    44a8:	20 e0       	ldi	r18, 0x00	; 0
    44aa:	30 e0       	ldi	r19, 0x00	; 0
    44ac:	40 e2       	ldi	r20, 0x20	; 32
    44ae:	51 e4       	ldi	r21, 0x41	; 65
    44b0:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    44b4:	dc 01       	movw	r26, r24
    44b6:	cb 01       	movw	r24, r22
    44b8:	bc 01       	movw	r22, r24
    44ba:	cd 01       	movw	r24, r26
    44bc:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    44c0:	dc 01       	movw	r26, r24
    44c2:	cb 01       	movw	r24, r22
    44c4:	9c 8b       	std	Y+20, r25	; 0x14
    44c6:	8b 8b       	std	Y+19, r24	; 0x13
    44c8:	0f c0       	rjmp	.+30     	; 0x44e8 <lcd_wr_command+0x11a>
    44ca:	80 e7       	ldi	r24, 0x70	; 112
    44cc:	91 e0       	ldi	r25, 0x01	; 1
    44ce:	9a 8b       	std	Y+18, r25	; 0x12
    44d0:	89 8b       	std	Y+17, r24	; 0x11
    44d2:	89 89       	ldd	r24, Y+17	; 0x11
    44d4:	9a 89       	ldd	r25, Y+18	; 0x12
    44d6:	01 97       	sbiw	r24, 0x01	; 1
    44d8:	f1 f7       	brne	.-4      	; 0x44d6 <lcd_wr_command+0x108>
    44da:	9a 8b       	std	Y+18, r25	; 0x12
    44dc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    44de:	8b 89       	ldd	r24, Y+19	; 0x13
    44e0:	9c 89       	ldd	r25, Y+20	; 0x14
    44e2:	01 97       	sbiw	r24, 0x01	; 1
    44e4:	9c 8b       	std	Y+20, r25	; 0x14
    44e6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    44e8:	8b 89       	ldd	r24, Y+19	; 0x13
    44ea:	9c 89       	ldd	r25, Y+20	; 0x14
    44ec:	00 97       	sbiw	r24, 0x00	; 0
    44ee:	69 f7       	brne	.-38     	; 0x44ca <lcd_wr_command+0xfc>
    44f0:	14 c0       	rjmp	.+40     	; 0x451a <lcd_wr_command+0x14c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    44f2:	6d 89       	ldd	r22, Y+21	; 0x15
    44f4:	7e 89       	ldd	r23, Y+22	; 0x16
    44f6:	8f 89       	ldd	r24, Y+23	; 0x17
    44f8:	98 8d       	ldd	r25, Y+24	; 0x18
    44fa:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    44fe:	dc 01       	movw	r26, r24
    4500:	cb 01       	movw	r24, r22
    4502:	9c 8b       	std	Y+20, r25	; 0x14
    4504:	8b 8b       	std	Y+19, r24	; 0x13
    4506:	8b 89       	ldd	r24, Y+19	; 0x13
    4508:	9c 89       	ldd	r25, Y+20	; 0x14
    450a:	98 8b       	std	Y+16, r25	; 0x10
    450c:	8f 87       	std	Y+15, r24	; 0x0f
    450e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4510:	98 89       	ldd	r25, Y+16	; 0x10
    4512:	01 97       	sbiw	r24, 0x01	; 1
    4514:	f1 f7       	brne	.-4      	; 0x4512 <lcd_wr_command+0x144>
    4516:	98 8b       	std	Y+16, r25	; 0x10
    4518:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
	cbit(lcd_port,EN);
    451a:	a8 e2       	ldi	r26, 0x28	; 40
    451c:	b0 e0       	ldi	r27, 0x00	; 0
    451e:	e8 e2       	ldi	r30, 0x28	; 40
    4520:	f0 e0       	ldi	r31, 0x00	; 0
    4522:	80 81       	ld	r24, Z
    4524:	8b 7f       	andi	r24, 0xFB	; 251
    4526:	8c 93       	st	X, r24
	
	cmd = cmd & 0x0F;
    4528:	8e 8d       	ldd	r24, Y+30	; 0x1e
    452a:	8f 70       	andi	r24, 0x0F	; 15
    452c:	8e 8f       	std	Y+30, r24	; 0x1e
	cmd = cmd<<4;
    452e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4530:	82 95       	swap	r24
    4532:	80 7f       	andi	r24, 0xF0	; 240
    4534:	8e 8f       	std	Y+30, r24	; 0x1e
	lcd_port &= 0x0F;
    4536:	a8 e2       	ldi	r26, 0x28	; 40
    4538:	b0 e0       	ldi	r27, 0x00	; 0
    453a:	e8 e2       	ldi	r30, 0x28	; 40
    453c:	f0 e0       	ldi	r31, 0x00	; 0
    453e:	80 81       	ld	r24, Z
    4540:	8f 70       	andi	r24, 0x0F	; 15
    4542:	8c 93       	st	X, r24
	lcd_port |= cmd;
    4544:	a8 e2       	ldi	r26, 0x28	; 40
    4546:	b0 e0       	ldi	r27, 0x00	; 0
    4548:	e8 e2       	ldi	r30, 0x28	; 40
    454a:	f0 e0       	ldi	r31, 0x00	; 0
    454c:	90 81       	ld	r25, Z
    454e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4550:	89 2b       	or	r24, r25
    4552:	8c 93       	st	X, r24
	cbit(lcd_port,RS);
    4554:	a8 e2       	ldi	r26, 0x28	; 40
    4556:	b0 e0       	ldi	r27, 0x00	; 0
    4558:	e8 e2       	ldi	r30, 0x28	; 40
    455a:	f0 e0       	ldi	r31, 0x00	; 0
    455c:	80 81       	ld	r24, Z
    455e:	8e 7f       	andi	r24, 0xFE	; 254
    4560:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
    4562:	a8 e2       	ldi	r26, 0x28	; 40
    4564:	b0 e0       	ldi	r27, 0x00	; 0
    4566:	e8 e2       	ldi	r30, 0x28	; 40
    4568:	f0 e0       	ldi	r31, 0x00	; 0
    456a:	80 81       	ld	r24, Z
    456c:	8d 7f       	andi	r24, 0xFD	; 253
    456e:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
    4570:	a8 e2       	ldi	r26, 0x28	; 40
    4572:	b0 e0       	ldi	r27, 0x00	; 0
    4574:	e8 e2       	ldi	r30, 0x28	; 40
    4576:	f0 e0       	ldi	r31, 0x00	; 0
    4578:	80 81       	ld	r24, Z
    457a:	84 60       	ori	r24, 0x04	; 4
    457c:	8c 93       	st	X, r24
    457e:	80 e0       	ldi	r24, 0x00	; 0
    4580:	90 e0       	ldi	r25, 0x00	; 0
    4582:	a0 ea       	ldi	r26, 0xA0	; 160
    4584:	b0 e4       	ldi	r27, 0x40	; 64
    4586:	8b 87       	std	Y+11, r24	; 0x0b
    4588:	9c 87       	std	Y+12, r25	; 0x0c
    458a:	ad 87       	std	Y+13, r26	; 0x0d
    458c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    458e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4590:	7c 85       	ldd	r23, Y+12	; 0x0c
    4592:	8d 85       	ldd	r24, Y+13	; 0x0d
    4594:	9e 85       	ldd	r25, Y+14	; 0x0e
    4596:	26 e6       	ldi	r18, 0x66	; 102
    4598:	36 e6       	ldi	r19, 0x66	; 102
    459a:	46 e6       	ldi	r20, 0x66	; 102
    459c:	55 e4       	ldi	r21, 0x45	; 69
    459e:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    45a2:	dc 01       	movw	r26, r24
    45a4:	cb 01       	movw	r24, r22
    45a6:	8f 83       	std	Y+7, r24	; 0x07
    45a8:	98 87       	std	Y+8, r25	; 0x08
    45aa:	a9 87       	std	Y+9, r26	; 0x09
    45ac:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    45ae:	6f 81       	ldd	r22, Y+7	; 0x07
    45b0:	78 85       	ldd	r23, Y+8	; 0x08
    45b2:	89 85       	ldd	r24, Y+9	; 0x09
    45b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    45b6:	20 e0       	ldi	r18, 0x00	; 0
    45b8:	30 e0       	ldi	r19, 0x00	; 0
    45ba:	40 e8       	ldi	r20, 0x80	; 128
    45bc:	5f e3       	ldi	r21, 0x3F	; 63
    45be:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    45c2:	88 23       	and	r24, r24
    45c4:	2c f4       	brge	.+10     	; 0x45d0 <lcd_wr_command+0x202>
		__ticks = 1;
    45c6:	81 e0       	ldi	r24, 0x01	; 1
    45c8:	90 e0       	ldi	r25, 0x00	; 0
    45ca:	9e 83       	std	Y+6, r25	; 0x06
    45cc:	8d 83       	std	Y+5, r24	; 0x05
    45ce:	3f c0       	rjmp	.+126    	; 0x464e <lcd_wr_command+0x280>
	else if (__tmp > 65535)
    45d0:	6f 81       	ldd	r22, Y+7	; 0x07
    45d2:	78 85       	ldd	r23, Y+8	; 0x08
    45d4:	89 85       	ldd	r24, Y+9	; 0x09
    45d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    45d8:	20 e0       	ldi	r18, 0x00	; 0
    45da:	3f ef       	ldi	r19, 0xFF	; 255
    45dc:	4f e7       	ldi	r20, 0x7F	; 127
    45de:	57 e4       	ldi	r21, 0x47	; 71
    45e0:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    45e4:	18 16       	cp	r1, r24
    45e6:	4c f5       	brge	.+82     	; 0x463a <lcd_wr_command+0x26c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    45e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    45ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    45ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    45ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    45f0:	20 e0       	ldi	r18, 0x00	; 0
    45f2:	30 e0       	ldi	r19, 0x00	; 0
    45f4:	40 e2       	ldi	r20, 0x20	; 32
    45f6:	51 e4       	ldi	r21, 0x41	; 65
    45f8:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    45fc:	dc 01       	movw	r26, r24
    45fe:	cb 01       	movw	r24, r22
    4600:	bc 01       	movw	r22, r24
    4602:	cd 01       	movw	r24, r26
    4604:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4608:	dc 01       	movw	r26, r24
    460a:	cb 01       	movw	r24, r22
    460c:	9e 83       	std	Y+6, r25	; 0x06
    460e:	8d 83       	std	Y+5, r24	; 0x05
    4610:	0f c0       	rjmp	.+30     	; 0x4630 <lcd_wr_command+0x262>
    4612:	80 e7       	ldi	r24, 0x70	; 112
    4614:	91 e0       	ldi	r25, 0x01	; 1
    4616:	9c 83       	std	Y+4, r25	; 0x04
    4618:	8b 83       	std	Y+3, r24	; 0x03
    461a:	8b 81       	ldd	r24, Y+3	; 0x03
    461c:	9c 81       	ldd	r25, Y+4	; 0x04
    461e:	01 97       	sbiw	r24, 0x01	; 1
    4620:	f1 f7       	brne	.-4      	; 0x461e <lcd_wr_command+0x250>
    4622:	9c 83       	std	Y+4, r25	; 0x04
    4624:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4626:	8d 81       	ldd	r24, Y+5	; 0x05
    4628:	9e 81       	ldd	r25, Y+6	; 0x06
    462a:	01 97       	sbiw	r24, 0x01	; 1
    462c:	9e 83       	std	Y+6, r25	; 0x06
    462e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4630:	8d 81       	ldd	r24, Y+5	; 0x05
    4632:	9e 81       	ldd	r25, Y+6	; 0x06
    4634:	00 97       	sbiw	r24, 0x00	; 0
    4636:	69 f7       	brne	.-38     	; 0x4612 <lcd_wr_command+0x244>
    4638:	14 c0       	rjmp	.+40     	; 0x4662 <lcd_wr_command+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    463a:	6f 81       	ldd	r22, Y+7	; 0x07
    463c:	78 85       	ldd	r23, Y+8	; 0x08
    463e:	89 85       	ldd	r24, Y+9	; 0x09
    4640:	9a 85       	ldd	r25, Y+10	; 0x0a
    4642:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4646:	dc 01       	movw	r26, r24
    4648:	cb 01       	movw	r24, r22
    464a:	9e 83       	std	Y+6, r25	; 0x06
    464c:	8d 83       	std	Y+5, r24	; 0x05
    464e:	8d 81       	ldd	r24, Y+5	; 0x05
    4650:	9e 81       	ldd	r25, Y+6	; 0x06
    4652:	9a 83       	std	Y+2, r25	; 0x02
    4654:	89 83       	std	Y+1, r24	; 0x01
    4656:	89 81       	ldd	r24, Y+1	; 0x01
    4658:	9a 81       	ldd	r25, Y+2	; 0x02
    465a:	01 97       	sbiw	r24, 0x01	; 1
    465c:	f1 f7       	brne	.-4      	; 0x465a <lcd_wr_command+0x28c>
    465e:	9a 83       	std	Y+2, r25	; 0x02
    4660:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
	cbit(lcd_port,EN);
    4662:	a8 e2       	ldi	r26, 0x28	; 40
    4664:	b0 e0       	ldi	r27, 0x00	; 0
    4666:	e8 e2       	ldi	r30, 0x28	; 40
    4668:	f0 e0       	ldi	r31, 0x00	; 0
    466a:	80 81       	ld	r24, Z
    466c:	8b 7f       	andi	r24, 0xFB	; 251
    466e:	8c 93       	st	X, r24
}
    4670:	6e 96       	adiw	r28, 0x1e	; 30
    4672:	0f b6       	in	r0, 0x3f	; 63
    4674:	f8 94       	cli
    4676:	de bf       	out	0x3e, r29	; 62
    4678:	0f be       	out	0x3f, r0	; 63
    467a:	cd bf       	out	0x3d, r28	; 61
    467c:	cf 91       	pop	r28
    467e:	df 91       	pop	r29
    4680:	08 95       	ret

00004682 <lcd_wr_char>:

/*****Function to Write Data on LCD*****/
void lcd_wr_char(char letter)
{
    4682:	df 93       	push	r29
    4684:	cf 93       	push	r28
    4686:	cd b7       	in	r28, 0x3d	; 61
    4688:	de b7       	in	r29, 0x3e	; 62
    468a:	6e 97       	sbiw	r28, 0x1e	; 30
    468c:	0f b6       	in	r0, 0x3f	; 63
    468e:	f8 94       	cli
    4690:	de bf       	out	0x3e, r29	; 62
    4692:	0f be       	out	0x3f, r0	; 63
    4694:	cd bf       	out	0x3d, r28	; 61
    4696:	8e 8f       	std	Y+30, r24	; 0x1e
	char temp;
	temp = letter;
    4698:	8e 8d       	ldd	r24, Y+30	; 0x1e
    469a:	8d 8f       	std	Y+29, r24	; 0x1d
	temp = (temp & 0xF0);
    469c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    469e:	80 7f       	andi	r24, 0xF0	; 240
    46a0:	8d 8f       	std	Y+29, r24	; 0x1d
	lcd_port &= 0x0F;
    46a2:	a8 e2       	ldi	r26, 0x28	; 40
    46a4:	b0 e0       	ldi	r27, 0x00	; 0
    46a6:	e8 e2       	ldi	r30, 0x28	; 40
    46a8:	f0 e0       	ldi	r31, 0x00	; 0
    46aa:	80 81       	ld	r24, Z
    46ac:	8f 70       	andi	r24, 0x0F	; 15
    46ae:	8c 93       	st	X, r24
	lcd_port |= temp;
    46b0:	a8 e2       	ldi	r26, 0x28	; 40
    46b2:	b0 e0       	ldi	r27, 0x00	; 0
    46b4:	e8 e2       	ldi	r30, 0x28	; 40
    46b6:	f0 e0       	ldi	r31, 0x00	; 0
    46b8:	90 81       	ld	r25, Z
    46ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    46bc:	89 2b       	or	r24, r25
    46be:	8c 93       	st	X, r24
	sbit(lcd_port,RS);
    46c0:	a8 e2       	ldi	r26, 0x28	; 40
    46c2:	b0 e0       	ldi	r27, 0x00	; 0
    46c4:	e8 e2       	ldi	r30, 0x28	; 40
    46c6:	f0 e0       	ldi	r31, 0x00	; 0
    46c8:	80 81       	ld	r24, Z
    46ca:	81 60       	ori	r24, 0x01	; 1
    46cc:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
    46ce:	a8 e2       	ldi	r26, 0x28	; 40
    46d0:	b0 e0       	ldi	r27, 0x00	; 0
    46d2:	e8 e2       	ldi	r30, 0x28	; 40
    46d4:	f0 e0       	ldi	r31, 0x00	; 0
    46d6:	80 81       	ld	r24, Z
    46d8:	8d 7f       	andi	r24, 0xFD	; 253
    46da:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
    46dc:	a8 e2       	ldi	r26, 0x28	; 40
    46de:	b0 e0       	ldi	r27, 0x00	; 0
    46e0:	e8 e2       	ldi	r30, 0x28	; 40
    46e2:	f0 e0       	ldi	r31, 0x00	; 0
    46e4:	80 81       	ld	r24, Z
    46e6:	84 60       	ori	r24, 0x04	; 4
    46e8:	8c 93       	st	X, r24
    46ea:	80 e0       	ldi	r24, 0x00	; 0
    46ec:	90 e0       	ldi	r25, 0x00	; 0
    46ee:	a0 ea       	ldi	r26, 0xA0	; 160
    46f0:	b0 e4       	ldi	r27, 0x40	; 64
    46f2:	89 8f       	std	Y+25, r24	; 0x19
    46f4:	9a 8f       	std	Y+26, r25	; 0x1a
    46f6:	ab 8f       	std	Y+27, r26	; 0x1b
    46f8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    46fa:	69 8d       	ldd	r22, Y+25	; 0x19
    46fc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    46fe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4700:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4702:	26 e6       	ldi	r18, 0x66	; 102
    4704:	36 e6       	ldi	r19, 0x66	; 102
    4706:	46 e6       	ldi	r20, 0x66	; 102
    4708:	55 e4       	ldi	r21, 0x45	; 69
    470a:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    470e:	dc 01       	movw	r26, r24
    4710:	cb 01       	movw	r24, r22
    4712:	8d 8b       	std	Y+21, r24	; 0x15
    4714:	9e 8b       	std	Y+22, r25	; 0x16
    4716:	af 8b       	std	Y+23, r26	; 0x17
    4718:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    471a:	6d 89       	ldd	r22, Y+21	; 0x15
    471c:	7e 89       	ldd	r23, Y+22	; 0x16
    471e:	8f 89       	ldd	r24, Y+23	; 0x17
    4720:	98 8d       	ldd	r25, Y+24	; 0x18
    4722:	20 e0       	ldi	r18, 0x00	; 0
    4724:	30 e0       	ldi	r19, 0x00	; 0
    4726:	40 e8       	ldi	r20, 0x80	; 128
    4728:	5f e3       	ldi	r21, 0x3F	; 63
    472a:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    472e:	88 23       	and	r24, r24
    4730:	2c f4       	brge	.+10     	; 0x473c <lcd_wr_char+0xba>
		__ticks = 1;
    4732:	81 e0       	ldi	r24, 0x01	; 1
    4734:	90 e0       	ldi	r25, 0x00	; 0
    4736:	9c 8b       	std	Y+20, r25	; 0x14
    4738:	8b 8b       	std	Y+19, r24	; 0x13
    473a:	3f c0       	rjmp	.+126    	; 0x47ba <lcd_wr_char+0x138>
	else if (__tmp > 65535)
    473c:	6d 89       	ldd	r22, Y+21	; 0x15
    473e:	7e 89       	ldd	r23, Y+22	; 0x16
    4740:	8f 89       	ldd	r24, Y+23	; 0x17
    4742:	98 8d       	ldd	r25, Y+24	; 0x18
    4744:	20 e0       	ldi	r18, 0x00	; 0
    4746:	3f ef       	ldi	r19, 0xFF	; 255
    4748:	4f e7       	ldi	r20, 0x7F	; 127
    474a:	57 e4       	ldi	r21, 0x47	; 71
    474c:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    4750:	18 16       	cp	r1, r24
    4752:	4c f5       	brge	.+82     	; 0x47a6 <lcd_wr_char+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4754:	69 8d       	ldd	r22, Y+25	; 0x19
    4756:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4758:	8b 8d       	ldd	r24, Y+27	; 0x1b
    475a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    475c:	20 e0       	ldi	r18, 0x00	; 0
    475e:	30 e0       	ldi	r19, 0x00	; 0
    4760:	40 e2       	ldi	r20, 0x20	; 32
    4762:	51 e4       	ldi	r21, 0x41	; 65
    4764:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    4768:	dc 01       	movw	r26, r24
    476a:	cb 01       	movw	r24, r22
    476c:	bc 01       	movw	r22, r24
    476e:	cd 01       	movw	r24, r26
    4770:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    4774:	dc 01       	movw	r26, r24
    4776:	cb 01       	movw	r24, r22
    4778:	9c 8b       	std	Y+20, r25	; 0x14
    477a:	8b 8b       	std	Y+19, r24	; 0x13
    477c:	0f c0       	rjmp	.+30     	; 0x479c <lcd_wr_char+0x11a>
    477e:	80 e7       	ldi	r24, 0x70	; 112
    4780:	91 e0       	ldi	r25, 0x01	; 1
    4782:	9a 8b       	std	Y+18, r25	; 0x12
    4784:	89 8b       	std	Y+17, r24	; 0x11
    4786:	89 89       	ldd	r24, Y+17	; 0x11
    4788:	9a 89       	ldd	r25, Y+18	; 0x12
    478a:	01 97       	sbiw	r24, 0x01	; 1
    478c:	f1 f7       	brne	.-4      	; 0x478a <lcd_wr_char+0x108>
    478e:	9a 8b       	std	Y+18, r25	; 0x12
    4790:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4792:	8b 89       	ldd	r24, Y+19	; 0x13
    4794:	9c 89       	ldd	r25, Y+20	; 0x14
    4796:	01 97       	sbiw	r24, 0x01	; 1
    4798:	9c 8b       	std	Y+20, r25	; 0x14
    479a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    479c:	8b 89       	ldd	r24, Y+19	; 0x13
    479e:	9c 89       	ldd	r25, Y+20	; 0x14
    47a0:	00 97       	sbiw	r24, 0x00	; 0
    47a2:	69 f7       	brne	.-38     	; 0x477e <lcd_wr_char+0xfc>
    47a4:	14 c0       	rjmp	.+40     	; 0x47ce <lcd_wr_char+0x14c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    47a6:	6d 89       	ldd	r22, Y+21	; 0x15
    47a8:	7e 89       	ldd	r23, Y+22	; 0x16
    47aa:	8f 89       	ldd	r24, Y+23	; 0x17
    47ac:	98 8d       	ldd	r25, Y+24	; 0x18
    47ae:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    47b2:	dc 01       	movw	r26, r24
    47b4:	cb 01       	movw	r24, r22
    47b6:	9c 8b       	std	Y+20, r25	; 0x14
    47b8:	8b 8b       	std	Y+19, r24	; 0x13
    47ba:	8b 89       	ldd	r24, Y+19	; 0x13
    47bc:	9c 89       	ldd	r25, Y+20	; 0x14
    47be:	98 8b       	std	Y+16, r25	; 0x10
    47c0:	8f 87       	std	Y+15, r24	; 0x0f
    47c2:	8f 85       	ldd	r24, Y+15	; 0x0f
    47c4:	98 89       	ldd	r25, Y+16	; 0x10
    47c6:	01 97       	sbiw	r24, 0x01	; 1
    47c8:	f1 f7       	brne	.-4      	; 0x47c6 <lcd_wr_char+0x144>
    47ca:	98 8b       	std	Y+16, r25	; 0x10
    47cc:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
	cbit(lcd_port,EN);
    47ce:	a8 e2       	ldi	r26, 0x28	; 40
    47d0:	b0 e0       	ldi	r27, 0x00	; 0
    47d2:	e8 e2       	ldi	r30, 0x28	; 40
    47d4:	f0 e0       	ldi	r31, 0x00	; 0
    47d6:	80 81       	ld	r24, Z
    47d8:	8b 7f       	andi	r24, 0xFB	; 251
    47da:	8c 93       	st	X, r24

	letter = letter & 0x0F;
    47dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    47de:	8f 70       	andi	r24, 0x0F	; 15
    47e0:	8e 8f       	std	Y+30, r24	; 0x1e
	letter = letter<<4;
    47e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    47e4:	82 95       	swap	r24
    47e6:	80 7f       	andi	r24, 0xF0	; 240
    47e8:	8e 8f       	std	Y+30, r24	; 0x1e
	lcd_port &= 0x0F;
    47ea:	a8 e2       	ldi	r26, 0x28	; 40
    47ec:	b0 e0       	ldi	r27, 0x00	; 0
    47ee:	e8 e2       	ldi	r30, 0x28	; 40
    47f0:	f0 e0       	ldi	r31, 0x00	; 0
    47f2:	80 81       	ld	r24, Z
    47f4:	8f 70       	andi	r24, 0x0F	; 15
    47f6:	8c 93       	st	X, r24
	lcd_port |= letter;
    47f8:	a8 e2       	ldi	r26, 0x28	; 40
    47fa:	b0 e0       	ldi	r27, 0x00	; 0
    47fc:	e8 e2       	ldi	r30, 0x28	; 40
    47fe:	f0 e0       	ldi	r31, 0x00	; 0
    4800:	90 81       	ld	r25, Z
    4802:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4804:	89 2b       	or	r24, r25
    4806:	8c 93       	st	X, r24
	sbit(lcd_port,RS);
    4808:	a8 e2       	ldi	r26, 0x28	; 40
    480a:	b0 e0       	ldi	r27, 0x00	; 0
    480c:	e8 e2       	ldi	r30, 0x28	; 40
    480e:	f0 e0       	ldi	r31, 0x00	; 0
    4810:	80 81       	ld	r24, Z
    4812:	81 60       	ori	r24, 0x01	; 1
    4814:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
    4816:	a8 e2       	ldi	r26, 0x28	; 40
    4818:	b0 e0       	ldi	r27, 0x00	; 0
    481a:	e8 e2       	ldi	r30, 0x28	; 40
    481c:	f0 e0       	ldi	r31, 0x00	; 0
    481e:	80 81       	ld	r24, Z
    4820:	8d 7f       	andi	r24, 0xFD	; 253
    4822:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
    4824:	a8 e2       	ldi	r26, 0x28	; 40
    4826:	b0 e0       	ldi	r27, 0x00	; 0
    4828:	e8 e2       	ldi	r30, 0x28	; 40
    482a:	f0 e0       	ldi	r31, 0x00	; 0
    482c:	80 81       	ld	r24, Z
    482e:	84 60       	ori	r24, 0x04	; 4
    4830:	8c 93       	st	X, r24
    4832:	80 e0       	ldi	r24, 0x00	; 0
    4834:	90 e0       	ldi	r25, 0x00	; 0
    4836:	a0 ea       	ldi	r26, 0xA0	; 160
    4838:	b0 e4       	ldi	r27, 0x40	; 64
    483a:	8b 87       	std	Y+11, r24	; 0x0b
    483c:	9c 87       	std	Y+12, r25	; 0x0c
    483e:	ad 87       	std	Y+13, r26	; 0x0d
    4840:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4842:	6b 85       	ldd	r22, Y+11	; 0x0b
    4844:	7c 85       	ldd	r23, Y+12	; 0x0c
    4846:	8d 85       	ldd	r24, Y+13	; 0x0d
    4848:	9e 85       	ldd	r25, Y+14	; 0x0e
    484a:	26 e6       	ldi	r18, 0x66	; 102
    484c:	36 e6       	ldi	r19, 0x66	; 102
    484e:	46 e6       	ldi	r20, 0x66	; 102
    4850:	55 e4       	ldi	r21, 0x45	; 69
    4852:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    4856:	dc 01       	movw	r26, r24
    4858:	cb 01       	movw	r24, r22
    485a:	8f 83       	std	Y+7, r24	; 0x07
    485c:	98 87       	std	Y+8, r25	; 0x08
    485e:	a9 87       	std	Y+9, r26	; 0x09
    4860:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4862:	6f 81       	ldd	r22, Y+7	; 0x07
    4864:	78 85       	ldd	r23, Y+8	; 0x08
    4866:	89 85       	ldd	r24, Y+9	; 0x09
    4868:	9a 85       	ldd	r25, Y+10	; 0x0a
    486a:	20 e0       	ldi	r18, 0x00	; 0
    486c:	30 e0       	ldi	r19, 0x00	; 0
    486e:	40 e8       	ldi	r20, 0x80	; 128
    4870:	5f e3       	ldi	r21, 0x3F	; 63
    4872:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    4876:	88 23       	and	r24, r24
    4878:	2c f4       	brge	.+10     	; 0x4884 <lcd_wr_char+0x202>
		__ticks = 1;
    487a:	81 e0       	ldi	r24, 0x01	; 1
    487c:	90 e0       	ldi	r25, 0x00	; 0
    487e:	9e 83       	std	Y+6, r25	; 0x06
    4880:	8d 83       	std	Y+5, r24	; 0x05
    4882:	3f c0       	rjmp	.+126    	; 0x4902 <lcd_wr_char+0x280>
	else if (__tmp > 65535)
    4884:	6f 81       	ldd	r22, Y+7	; 0x07
    4886:	78 85       	ldd	r23, Y+8	; 0x08
    4888:	89 85       	ldd	r24, Y+9	; 0x09
    488a:	9a 85       	ldd	r25, Y+10	; 0x0a
    488c:	20 e0       	ldi	r18, 0x00	; 0
    488e:	3f ef       	ldi	r19, 0xFF	; 255
    4890:	4f e7       	ldi	r20, 0x7F	; 127
    4892:	57 e4       	ldi	r21, 0x47	; 71
    4894:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    4898:	18 16       	cp	r1, r24
    489a:	4c f5       	brge	.+82     	; 0x48ee <lcd_wr_char+0x26c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    489c:	6b 85       	ldd	r22, Y+11	; 0x0b
    489e:	7c 85       	ldd	r23, Y+12	; 0x0c
    48a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    48a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    48a4:	20 e0       	ldi	r18, 0x00	; 0
    48a6:	30 e0       	ldi	r19, 0x00	; 0
    48a8:	40 e2       	ldi	r20, 0x20	; 32
    48aa:	51 e4       	ldi	r21, 0x41	; 65
    48ac:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    48b0:	dc 01       	movw	r26, r24
    48b2:	cb 01       	movw	r24, r22
    48b4:	bc 01       	movw	r22, r24
    48b6:	cd 01       	movw	r24, r26
    48b8:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    48bc:	dc 01       	movw	r26, r24
    48be:	cb 01       	movw	r24, r22
    48c0:	9e 83       	std	Y+6, r25	; 0x06
    48c2:	8d 83       	std	Y+5, r24	; 0x05
    48c4:	0f c0       	rjmp	.+30     	; 0x48e4 <lcd_wr_char+0x262>
    48c6:	80 e7       	ldi	r24, 0x70	; 112
    48c8:	91 e0       	ldi	r25, 0x01	; 1
    48ca:	9c 83       	std	Y+4, r25	; 0x04
    48cc:	8b 83       	std	Y+3, r24	; 0x03
    48ce:	8b 81       	ldd	r24, Y+3	; 0x03
    48d0:	9c 81       	ldd	r25, Y+4	; 0x04
    48d2:	01 97       	sbiw	r24, 0x01	; 1
    48d4:	f1 f7       	brne	.-4      	; 0x48d2 <lcd_wr_char+0x250>
    48d6:	9c 83       	std	Y+4, r25	; 0x04
    48d8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    48da:	8d 81       	ldd	r24, Y+5	; 0x05
    48dc:	9e 81       	ldd	r25, Y+6	; 0x06
    48de:	01 97       	sbiw	r24, 0x01	; 1
    48e0:	9e 83       	std	Y+6, r25	; 0x06
    48e2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    48e4:	8d 81       	ldd	r24, Y+5	; 0x05
    48e6:	9e 81       	ldd	r25, Y+6	; 0x06
    48e8:	00 97       	sbiw	r24, 0x00	; 0
    48ea:	69 f7       	brne	.-38     	; 0x48c6 <lcd_wr_char+0x244>
    48ec:	14 c0       	rjmp	.+40     	; 0x4916 <lcd_wr_char+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    48ee:	6f 81       	ldd	r22, Y+7	; 0x07
    48f0:	78 85       	ldd	r23, Y+8	; 0x08
    48f2:	89 85       	ldd	r24, Y+9	; 0x09
    48f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    48f6:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    48fa:	dc 01       	movw	r26, r24
    48fc:	cb 01       	movw	r24, r22
    48fe:	9e 83       	std	Y+6, r25	; 0x06
    4900:	8d 83       	std	Y+5, r24	; 0x05
    4902:	8d 81       	ldd	r24, Y+5	; 0x05
    4904:	9e 81       	ldd	r25, Y+6	; 0x06
    4906:	9a 83       	std	Y+2, r25	; 0x02
    4908:	89 83       	std	Y+1, r24	; 0x01
    490a:	89 81       	ldd	r24, Y+1	; 0x01
    490c:	9a 81       	ldd	r25, Y+2	; 0x02
    490e:	01 97       	sbiw	r24, 0x01	; 1
    4910:	f1 f7       	brne	.-4      	; 0x490e <lcd_wr_char+0x28c>
    4912:	9a 83       	std	Y+2, r25	; 0x02
    4914:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
	cbit(lcd_port,EN);
    4916:	a8 e2       	ldi	r26, 0x28	; 40
    4918:	b0 e0       	ldi	r27, 0x00	; 0
    491a:	e8 e2       	ldi	r30, 0x28	; 40
    491c:	f0 e0       	ldi	r31, 0x00	; 0
    491e:	80 81       	ld	r24, Z
    4920:	8b 7f       	andi	r24, 0xFB	; 251
    4922:	8c 93       	st	X, r24
}
    4924:	6e 96       	adiw	r28, 0x1e	; 30
    4926:	0f b6       	in	r0, 0x3f	; 63
    4928:	f8 94       	cli
    492a:	de bf       	out	0x3e, r29	; 62
    492c:	0f be       	out	0x3f, r0	; 63
    492e:	cd bf       	out	0x3d, r28	; 61
    4930:	cf 91       	pop	r28
    4932:	df 91       	pop	r29
    4934:	08 95       	ret

00004936 <lcd_home>:


void lcd_home()
{
    4936:	df 93       	push	r29
    4938:	cf 93       	push	r28
    493a:	cd b7       	in	r28, 0x3d	; 61
    493c:	de b7       	in	r29, 0x3e	; 62
	lcd_wr_command(0x80);
    493e:	80 e8       	ldi	r24, 0x80	; 128
    4940:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
}
    4944:	cf 91       	pop	r28
    4946:	df 91       	pop	r29
    4948:	08 95       	ret

0000494a <lcd_string>:


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
    494a:	df 93       	push	r29
    494c:	cf 93       	push	r28
    494e:	0f 92       	push	r0
    4950:	0f 92       	push	r0
    4952:	cd b7       	in	r28, 0x3d	; 61
    4954:	de b7       	in	r29, 0x3e	; 62
    4956:	9a 83       	std	Y+2, r25	; 0x02
    4958:	89 83       	std	Y+1, r24	; 0x01
    495a:	0a c0       	rjmp	.+20     	; 0x4970 <lcd_string+0x26>
	while(*str != '\0')
	{
		lcd_wr_char(*str);
    495c:	e9 81       	ldd	r30, Y+1	; 0x01
    495e:	fa 81       	ldd	r31, Y+2	; 0x02
    4960:	80 81       	ld	r24, Z
    4962:	0e 94 41 23 	call	0x4682	; 0x4682 <lcd_wr_char>
		str++;
    4966:	89 81       	ldd	r24, Y+1	; 0x01
    4968:	9a 81       	ldd	r25, Y+2	; 0x02
    496a:	01 96       	adiw	r24, 0x01	; 1
    496c:	9a 83       	std	Y+2, r25	; 0x02
    496e:	89 83       	std	Y+1, r24	; 0x01


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
	while(*str != '\0')
    4970:	e9 81       	ldd	r30, Y+1	; 0x01
    4972:	fa 81       	ldd	r31, Y+2	; 0x02
    4974:	80 81       	ld	r24, Z
    4976:	88 23       	and	r24, r24
    4978:	89 f7       	brne	.-30     	; 0x495c <lcd_string+0x12>
	{
		lcd_wr_char(*str);
		str++;
	}
}
    497a:	0f 90       	pop	r0
    497c:	0f 90       	pop	r0
    497e:	cf 91       	pop	r28
    4980:	df 91       	pop	r29
    4982:	08 95       	ret

00004984 <lcd_cursor>:

/*** Position the LCD cursor at "row", "column". ***/

void lcd_cursor (char row, char column)
{
    4984:	df 93       	push	r29
    4986:	cf 93       	push	r28
    4988:	00 d0       	rcall	.+0      	; 0x498a <lcd_cursor+0x6>
    498a:	0f 92       	push	r0
    498c:	cd b7       	in	r28, 0x3d	; 61
    498e:	de b7       	in	r29, 0x3e	; 62
    4990:	89 83       	std	Y+1, r24	; 0x01
    4992:	6a 83       	std	Y+2, r22	; 0x02
	switch (row) {
    4994:	89 81       	ldd	r24, Y+1	; 0x01
    4996:	28 2f       	mov	r18, r24
    4998:	30 e0       	ldi	r19, 0x00	; 0
    499a:	3c 83       	std	Y+4, r19	; 0x04
    499c:	2b 83       	std	Y+3, r18	; 0x03
    499e:	8b 81       	ldd	r24, Y+3	; 0x03
    49a0:	9c 81       	ldd	r25, Y+4	; 0x04
    49a2:	82 30       	cpi	r24, 0x02	; 2
    49a4:	91 05       	cpc	r25, r1
    49a6:	d9 f0       	breq	.+54     	; 0x49de <lcd_cursor+0x5a>
    49a8:	2b 81       	ldd	r18, Y+3	; 0x03
    49aa:	3c 81       	ldd	r19, Y+4	; 0x04
    49ac:	23 30       	cpi	r18, 0x03	; 3
    49ae:	31 05       	cpc	r19, r1
    49b0:	34 f4       	brge	.+12     	; 0x49be <lcd_cursor+0x3a>
    49b2:	8b 81       	ldd	r24, Y+3	; 0x03
    49b4:	9c 81       	ldd	r25, Y+4	; 0x04
    49b6:	81 30       	cpi	r24, 0x01	; 1
    49b8:	91 05       	cpc	r25, r1
    49ba:	61 f0       	breq	.+24     	; 0x49d4 <lcd_cursor+0x50>
    49bc:	1e c0       	rjmp	.+60     	; 0x49fa <lcd_cursor+0x76>
    49be:	2b 81       	ldd	r18, Y+3	; 0x03
    49c0:	3c 81       	ldd	r19, Y+4	; 0x04
    49c2:	23 30       	cpi	r18, 0x03	; 3
    49c4:	31 05       	cpc	r19, r1
    49c6:	81 f0       	breq	.+32     	; 0x49e8 <lcd_cursor+0x64>
    49c8:	8b 81       	ldd	r24, Y+3	; 0x03
    49ca:	9c 81       	ldd	r25, Y+4	; 0x04
    49cc:	84 30       	cpi	r24, 0x04	; 4
    49ce:	91 05       	cpc	r25, r1
    49d0:	81 f0       	breq	.+32     	; 0x49f2 <lcd_cursor+0x6e>
    49d2:	13 c0       	rjmp	.+38     	; 0x49fa <lcd_cursor+0x76>
		case 1: lcd_wr_command (0x80 + column - 1); break;
    49d4:	8a 81       	ldd	r24, Y+2	; 0x02
    49d6:	81 58       	subi	r24, 0x81	; 129
    49d8:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
    49dc:	0e c0       	rjmp	.+28     	; 0x49fa <lcd_cursor+0x76>
		case 2: lcd_wr_command (0xc0 + column - 1); break;
    49de:	8a 81       	ldd	r24, Y+2	; 0x02
    49e0:	81 54       	subi	r24, 0x41	; 65
    49e2:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
    49e6:	09 c0       	rjmp	.+18     	; 0x49fa <lcd_cursor+0x76>
		case 3: lcd_wr_command (0x94 + column - 1); break;
    49e8:	8a 81       	ldd	r24, Y+2	; 0x02
    49ea:	8d 56       	subi	r24, 0x6D	; 109
    49ec:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
    49f0:	04 c0       	rjmp	.+8      	; 0x49fa <lcd_cursor+0x76>
		case 4: lcd_wr_command (0xd4 + column - 1); break;
    49f2:	8a 81       	ldd	r24, Y+2	; 0x02
    49f4:	8d 52       	subi	r24, 0x2D	; 45
    49f6:	0e 94 e7 21 	call	0x43ce	; 0x43ce <lcd_wr_command>
		default: break;
	}
}
    49fa:	0f 90       	pop	r0
    49fc:	0f 90       	pop	r0
    49fe:	0f 90       	pop	r0
    4a00:	0f 90       	pop	r0
    4a02:	cf 91       	pop	r28
    4a04:	df 91       	pop	r29
    4a06:	08 95       	ret

00004a08 <lcd_print>:

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
    4a08:	df 93       	push	r29
    4a0a:	cf 93       	push	r28
    4a0c:	cd b7       	in	r28, 0x3d	; 61
    4a0e:	de b7       	in	r29, 0x3e	; 62
    4a10:	27 97       	sbiw	r28, 0x07	; 7
    4a12:	0f b6       	in	r0, 0x3f	; 63
    4a14:	f8 94       	cli
    4a16:	de bf       	out	0x3e, r29	; 62
    4a18:	0f be       	out	0x3f, r0	; 63
    4a1a:	cd bf       	out	0x3d, r28	; 61
    4a1c:	8a 83       	std	Y+2, r24	; 0x02
    4a1e:	6b 83       	std	Y+3, r22	; 0x03
    4a20:	5d 83       	std	Y+5, r21	; 0x05
    4a22:	4c 83       	std	Y+4, r20	; 0x04
    4a24:	3f 83       	std	Y+7, r19	; 0x07
    4a26:	2e 83       	std	Y+6, r18	; 0x06
	unsigned char flag=0;
    4a28:	19 82       	std	Y+1, r1	; 0x01
	if(row==0||coloumn==0)
    4a2a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a2c:	88 23       	and	r24, r24
    4a2e:	19 f0       	breq	.+6      	; 0x4a36 <lcd_print+0x2e>
    4a30:	8b 81       	ldd	r24, Y+3	; 0x03
    4a32:	88 23       	and	r24, r24
    4a34:	19 f4       	brne	.+6      	; 0x4a3c <lcd_print+0x34>
	{
		lcd_home();
    4a36:	0e 94 9b 24 	call	0x4936	; 0x4936 <lcd_home>
    4a3a:	04 c0       	rjmp	.+8      	; 0x4a44 <lcd_print+0x3c>
	}
	else
	{
		lcd_cursor(row,coloumn);
    4a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a3e:	6b 81       	ldd	r22, Y+3	; 0x03
    4a40:	0e 94 c2 24 	call	0x4984	; 0x4984 <lcd_cursor>
	}
	if(digits==5 || flag==1)
    4a44:	8e 81       	ldd	r24, Y+6	; 0x06
    4a46:	9f 81       	ldd	r25, Y+7	; 0x07
    4a48:	85 30       	cpi	r24, 0x05	; 5
    4a4a:	91 05       	cpc	r25, r1
    4a4c:	19 f0       	breq	.+6      	; 0x4a54 <lcd_print+0x4c>
    4a4e:	89 81       	ldd	r24, Y+1	; 0x01
    4a50:	81 30       	cpi	r24, 0x01	; 1
    4a52:	a9 f4       	brne	.+42     	; 0x4a7e <lcd_print+0x76>
	{
		million=value/10000+48;
    4a54:	8c 81       	ldd	r24, Y+4	; 0x04
    4a56:	9d 81       	ldd	r25, Y+5	; 0x05
    4a58:	20 e1       	ldi	r18, 0x10	; 16
    4a5a:	37 e2       	ldi	r19, 0x27	; 39
    4a5c:	b9 01       	movw	r22, r18
    4a5e:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4a62:	cb 01       	movw	r24, r22
    4a64:	c0 96       	adiw	r24, 0x30	; 48
    4a66:	90 93 f5 03 	sts	0x03F5, r25
    4a6a:	80 93 f4 03 	sts	0x03F4, r24
		lcd_wr_char(million);
    4a6e:	80 91 f4 03 	lds	r24, 0x03F4
    4a72:	90 91 f5 03 	lds	r25, 0x03F5
    4a76:	0e 94 41 23 	call	0x4682	; 0x4682 <lcd_wr_char>
		flag=1;
    4a7a:	81 e0       	ldi	r24, 0x01	; 1
    4a7c:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==4 || flag==1)
    4a7e:	8e 81       	ldd	r24, Y+6	; 0x06
    4a80:	9f 81       	ldd	r25, Y+7	; 0x07
    4a82:	84 30       	cpi	r24, 0x04	; 4
    4a84:	91 05       	cpc	r25, r1
    4a86:	19 f0       	breq	.+6      	; 0x4a8e <lcd_print+0x86>
    4a88:	89 81       	ldd	r24, Y+1	; 0x01
    4a8a:	81 30       	cpi	r24, 0x01	; 1
    4a8c:	11 f5       	brne	.+68     	; 0x4ad2 <lcd_print+0xca>
	{
		temp = value/1000;
    4a8e:	8c 81       	ldd	r24, Y+4	; 0x04
    4a90:	9d 81       	ldd	r25, Y+5	; 0x05
    4a92:	28 ee       	ldi	r18, 0xE8	; 232
    4a94:	33 e0       	ldi	r19, 0x03	; 3
    4a96:	b9 01       	movw	r22, r18
    4a98:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4a9c:	cb 01       	movw	r24, r22
    4a9e:	90 93 f7 03 	sts	0x03F7, r25
    4aa2:	80 93 f6 03 	sts	0x03F6, r24
		thousand = temp%10 + 48;
    4aa6:	80 91 f6 03 	lds	r24, 0x03F6
    4aaa:	90 91 f7 03 	lds	r25, 0x03F7
    4aae:	2a e0       	ldi	r18, 0x0A	; 10
    4ab0:	30 e0       	ldi	r19, 0x00	; 0
    4ab2:	b9 01       	movw	r22, r18
    4ab4:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4ab8:	c0 96       	adiw	r24, 0x30	; 48
    4aba:	90 93 77 04 	sts	0x0477, r25
    4abe:	80 93 76 04 	sts	0x0476, r24
		lcd_wr_char(thousand);
    4ac2:	80 91 76 04 	lds	r24, 0x0476
    4ac6:	90 91 77 04 	lds	r25, 0x0477
    4aca:	0e 94 41 23 	call	0x4682	; 0x4682 <lcd_wr_char>
		flag=1;
    4ace:	81 e0       	ldi	r24, 0x01	; 1
    4ad0:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==3 || flag==1)
    4ad2:	8e 81       	ldd	r24, Y+6	; 0x06
    4ad4:	9f 81       	ldd	r25, Y+7	; 0x07
    4ad6:	83 30       	cpi	r24, 0x03	; 3
    4ad8:	91 05       	cpc	r25, r1
    4ada:	19 f0       	breq	.+6      	; 0x4ae2 <lcd_print+0xda>
    4adc:	89 81       	ldd	r24, Y+1	; 0x01
    4ade:	81 30       	cpi	r24, 0x01	; 1
    4ae0:	11 f5       	brne	.+68     	; 0x4b26 <lcd_print+0x11e>
	{
		temp = value/100;
    4ae2:	8c 81       	ldd	r24, Y+4	; 0x04
    4ae4:	9d 81       	ldd	r25, Y+5	; 0x05
    4ae6:	24 e6       	ldi	r18, 0x64	; 100
    4ae8:	30 e0       	ldi	r19, 0x00	; 0
    4aea:	b9 01       	movw	r22, r18
    4aec:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4af0:	cb 01       	movw	r24, r22
    4af2:	90 93 f7 03 	sts	0x03F7, r25
    4af6:	80 93 f6 03 	sts	0x03F6, r24
		hundred = temp%10 + 48;
    4afa:	80 91 f6 03 	lds	r24, 0x03F6
    4afe:	90 91 f7 03 	lds	r25, 0x03F7
    4b02:	2a e0       	ldi	r18, 0x0A	; 10
    4b04:	30 e0       	ldi	r19, 0x00	; 0
    4b06:	b9 01       	movw	r22, r18
    4b08:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4b0c:	c0 96       	adiw	r24, 0x30	; 48
    4b0e:	90 93 1b 04 	sts	0x041B, r25
    4b12:	80 93 1a 04 	sts	0x041A, r24
		lcd_wr_char(hundred);
    4b16:	80 91 1a 04 	lds	r24, 0x041A
    4b1a:	90 91 1b 04 	lds	r25, 0x041B
    4b1e:	0e 94 41 23 	call	0x4682	; 0x4682 <lcd_wr_char>
		flag=1;
    4b22:	81 e0       	ldi	r24, 0x01	; 1
    4b24:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==2 || flag==1)
    4b26:	8e 81       	ldd	r24, Y+6	; 0x06
    4b28:	9f 81       	ldd	r25, Y+7	; 0x07
    4b2a:	82 30       	cpi	r24, 0x02	; 2
    4b2c:	91 05       	cpc	r25, r1
    4b2e:	19 f0       	breq	.+6      	; 0x4b36 <lcd_print+0x12e>
    4b30:	89 81       	ldd	r24, Y+1	; 0x01
    4b32:	81 30       	cpi	r24, 0x01	; 1
    4b34:	11 f5       	brne	.+68     	; 0x4b7a <lcd_print+0x172>
	{
		temp = value/10;
    4b36:	8c 81       	ldd	r24, Y+4	; 0x04
    4b38:	9d 81       	ldd	r25, Y+5	; 0x05
    4b3a:	2a e0       	ldi	r18, 0x0A	; 10
    4b3c:	30 e0       	ldi	r19, 0x00	; 0
    4b3e:	b9 01       	movw	r22, r18
    4b40:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4b44:	cb 01       	movw	r24, r22
    4b46:	90 93 f7 03 	sts	0x03F7, r25
    4b4a:	80 93 f6 03 	sts	0x03F6, r24
		tens = temp%10 + 48;
    4b4e:	80 91 f6 03 	lds	r24, 0x03F6
    4b52:	90 91 f7 03 	lds	r25, 0x03F7
    4b56:	2a e0       	ldi	r18, 0x0A	; 10
    4b58:	30 e0       	ldi	r19, 0x00	; 0
    4b5a:	b9 01       	movw	r22, r18
    4b5c:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4b60:	c0 96       	adiw	r24, 0x30	; 48
    4b62:	90 93 18 04 	sts	0x0418, r25
    4b66:	80 93 17 04 	sts	0x0417, r24
		lcd_wr_char(tens);
    4b6a:	80 91 17 04 	lds	r24, 0x0417
    4b6e:	90 91 18 04 	lds	r25, 0x0418
    4b72:	0e 94 41 23 	call	0x4682	; 0x4682 <lcd_wr_char>
		flag=1;
    4b76:	81 e0       	ldi	r24, 0x01	; 1
    4b78:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==1 || flag==1)
    4b7a:	8e 81       	ldd	r24, Y+6	; 0x06
    4b7c:	9f 81       	ldd	r25, Y+7	; 0x07
    4b7e:	81 30       	cpi	r24, 0x01	; 1
    4b80:	91 05       	cpc	r25, r1
    4b82:	19 f0       	breq	.+6      	; 0x4b8a <lcd_print+0x182>
    4b84:	89 81       	ldd	r24, Y+1	; 0x01
    4b86:	81 30       	cpi	r24, 0x01	; 1
    4b88:	91 f4       	brne	.+36     	; 0x4bae <lcd_print+0x1a6>
	{
		unit = value%10 + 48;
    4b8a:	8c 81       	ldd	r24, Y+4	; 0x04
    4b8c:	9d 81       	ldd	r25, Y+5	; 0x05
    4b8e:	2a e0       	ldi	r18, 0x0A	; 10
    4b90:	30 e0       	ldi	r19, 0x00	; 0
    4b92:	b9 01       	movw	r22, r18
    4b94:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodhi4>
    4b98:	c0 96       	adiw	r24, 0x30	; 48
    4b9a:	90 93 75 04 	sts	0x0475, r25
    4b9e:	80 93 74 04 	sts	0x0474, r24
		lcd_wr_char(unit);
    4ba2:	80 91 74 04 	lds	r24, 0x0474
    4ba6:	90 91 75 04 	lds	r25, 0x0475
    4baa:	0e 94 41 23 	call	0x4682	; 0x4682 <lcd_wr_char>
	}
	if(digits>5)
    4bae:	8e 81       	ldd	r24, Y+6	; 0x06
    4bb0:	9f 81       	ldd	r25, Y+7	; 0x07
    4bb2:	86 30       	cpi	r24, 0x06	; 6
    4bb4:	91 05       	cpc	r25, r1
    4bb6:	1c f0       	brlt	.+6      	; 0x4bbe <lcd_print+0x1b6>
	{
		lcd_wr_char('E');
    4bb8:	85 e4       	ldi	r24, 0x45	; 69
    4bba:	0e 94 41 23 	call	0x4682	; 0x4682 <lcd_wr_char>
	}
	
}
    4bbe:	27 96       	adiw	r28, 0x07	; 7
    4bc0:	0f b6       	in	r0, 0x3f	; 63
    4bc2:	f8 94       	cli
    4bc4:	de bf       	out	0x3e, r29	; 62
    4bc6:	0f be       	out	0x3f, r0	; 63
    4bc8:	cd bf       	out	0x3d, r28	; 61
    4bca:	cf 91       	pop	r28
    4bcc:	df 91       	pop	r29
    4bce:	08 95       	ret

00004bd0 <lcd_port_config>:
* Logic: 			Function to configure LCD port
* Example Call:		lcd_port_config();
*
*/
void lcd_port_config (void)
{
    4bd0:	df 93       	push	r29
    4bd2:	cf 93       	push	r28
    4bd4:	cd b7       	in	r28, 0x3d	; 61
    4bd6:	de b7       	in	r29, 0x3e	; 62
 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
    4bd8:	a7 e2       	ldi	r26, 0x27	; 39
    4bda:	b0 e0       	ldi	r27, 0x00	; 0
    4bdc:	e7 e2       	ldi	r30, 0x27	; 39
    4bde:	f0 e0       	ldi	r31, 0x00	; 0
    4be0:	80 81       	ld	r24, Z
    4be2:	87 6f       	ori	r24, 0xF7	; 247
    4be4:	8c 93       	st	X, r24
 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
    4be6:	a8 e2       	ldi	r26, 0x28	; 40
    4be8:	b0 e0       	ldi	r27, 0x00	; 0
    4bea:	e8 e2       	ldi	r30, 0x28	; 40
    4bec:	f0 e0       	ldi	r31, 0x00	; 0
    4bee:	80 81       	ld	r24, Z
    4bf0:	80 78       	andi	r24, 0x80	; 128
    4bf2:	8c 93       	st	X, r24
}
    4bf4:	cf 91       	pop	r28
    4bf6:	df 91       	pop	r29
    4bf8:	08 95       	ret

00004bfa <adc_pin_config>:
* Logic: 			ADC pin configuration
* Example Call:		adc_pin_config();
*
*/
void adc_pin_config (void)
{
    4bfa:	df 93       	push	r29
    4bfc:	cf 93       	push	r28
    4bfe:	cd b7       	in	r28, 0x3d	; 61
    4c00:	de b7       	in	r29, 0x3e	; 62
 DDRF = 0x00; 
    4c02:	e0 e3       	ldi	r30, 0x30	; 48
    4c04:	f0 e0       	ldi	r31, 0x00	; 0
    4c06:	10 82       	st	Z, r1
 PORTF = 0x00;
    4c08:	e1 e3       	ldi	r30, 0x31	; 49
    4c0a:	f0 e0       	ldi	r31, 0x00	; 0
    4c0c:	10 82       	st	Z, r1
 DDRK = 0x00;
    4c0e:	e7 e0       	ldi	r30, 0x07	; 7
    4c10:	f1 e0       	ldi	r31, 0x01	; 1
    4c12:	10 82       	st	Z, r1
 PORTK = 0x00;
    4c14:	e8 e0       	ldi	r30, 0x08	; 8
    4c16:	f1 e0       	ldi	r31, 0x01	; 1
    4c18:	10 82       	st	Z, r1
}
    4c1a:	cf 91       	pop	r28
    4c1c:	df 91       	pop	r29
    4c1e:	08 95       	ret

00004c20 <motion_pin_config>:
* Logic: 			Function to configure ports to enable robot's motion
* Example Call:		motion_pin_config();
*
*/
void motion_pin_config (void) 
{
    4c20:	df 93       	push	r29
    4c22:	cf 93       	push	r28
    4c24:	cd b7       	in	r28, 0x3d	; 61
    4c26:	de b7       	in	r29, 0x3e	; 62
 DDRA = DDRA | 0x0F;
    4c28:	a1 e2       	ldi	r26, 0x21	; 33
    4c2a:	b0 e0       	ldi	r27, 0x00	; 0
    4c2c:	e1 e2       	ldi	r30, 0x21	; 33
    4c2e:	f0 e0       	ldi	r31, 0x00	; 0
    4c30:	80 81       	ld	r24, Z
    4c32:	8f 60       	ori	r24, 0x0F	; 15
    4c34:	8c 93       	st	X, r24
 PORTA = PORTA & 0xF0;
    4c36:	a2 e2       	ldi	r26, 0x22	; 34
    4c38:	b0 e0       	ldi	r27, 0x00	; 0
    4c3a:	e2 e2       	ldi	r30, 0x22	; 34
    4c3c:	f0 e0       	ldi	r31, 0x00	; 0
    4c3e:	80 81       	ld	r24, Z
    4c40:	80 7f       	andi	r24, 0xF0	; 240
    4c42:	8c 93       	st	X, r24
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
    4c44:	aa e0       	ldi	r26, 0x0A	; 10
    4c46:	b1 e0       	ldi	r27, 0x01	; 1
    4c48:	ea e0       	ldi	r30, 0x0A	; 10
    4c4a:	f1 e0       	ldi	r31, 0x01	; 1
    4c4c:	80 81       	ld	r24, Z
    4c4e:	88 61       	ori	r24, 0x18	; 24
    4c50:	8c 93       	st	X, r24
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
    4c52:	ab e0       	ldi	r26, 0x0B	; 11
    4c54:	b1 e0       	ldi	r27, 0x01	; 1
    4c56:	eb e0       	ldi	r30, 0x0B	; 11
    4c58:	f1 e0       	ldi	r31, 0x01	; 1
    4c5a:	80 81       	ld	r24, Z
    4c5c:	88 61       	ori	r24, 0x18	; 24
    4c5e:	8c 93       	st	X, r24
}
    4c60:	cf 91       	pop	r28
    4c62:	df 91       	pop	r29
    4c64:	08 95       	ret

00004c66 <port_init>:
* Logic: 			Function to Initialize PORTS
* Example Call:		port_init();
*
*/
void port_init()
{
    4c66:	df 93       	push	r29
    4c68:	cf 93       	push	r28
    4c6a:	cd b7       	in	r28, 0x3d	; 61
    4c6c:	de b7       	in	r29, 0x3e	; 62
	lcd_port_config();
    4c6e:	0e 94 e8 25 	call	0x4bd0	; 0x4bd0 <lcd_port_config>
	adc_pin_config();
    4c72:	0e 94 fd 25 	call	0x4bfa	; 0x4bfa <adc_pin_config>
	motion_pin_config();
    4c76:	0e 94 10 26 	call	0x4c20	; 0x4c20 <motion_pin_config>
	led_pin_config();
    4c7a:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <led_pin_config>
	buzzer_pin_config();
    4c7e:	0e 94 48 26 	call	0x4c90	; 0x4c90 <buzzer_pin_config>
		
	left_encoder_pin_config(); //left encoder pin config
    4c82:	0e 94 05 29 	call	0x520a	; 0x520a <left_encoder_pin_config>
    right_encoder_pin_config(); // right encoder pin config
    4c86:	0e 94 1a 29 	call	0x5234	; 0x5234 <right_encoder_pin_config>
}
    4c8a:	cf 91       	pop	r28
    4c8c:	df 91       	pop	r29
    4c8e:	08 95       	ret

00004c90 <buzzer_pin_config>:
* Logic: 			Function used for configure buzzer ports
* Example Call:		buzzer_pin_config();
*
*/
void buzzer_pin_config (void)
{
    4c90:	df 93       	push	r29
    4c92:	cf 93       	push	r28
    4c94:	cd b7       	in	r28, 0x3d	; 61
    4c96:	de b7       	in	r29, 0x3e	; 62
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as outpt
    4c98:	a7 e2       	ldi	r26, 0x27	; 39
    4c9a:	b0 e0       	ldi	r27, 0x00	; 0
    4c9c:	e7 e2       	ldi	r30, 0x27	; 39
    4c9e:	f0 e0       	ldi	r31, 0x00	; 0
    4ca0:	80 81       	ld	r24, Z
    4ca2:	88 60       	ori	r24, 0x08	; 8
    4ca4:	8c 93       	st	X, r24
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
    4ca6:	a8 e2       	ldi	r26, 0x28	; 40
    4ca8:	b0 e0       	ldi	r27, 0x00	; 0
    4caa:	e8 e2       	ldi	r30, 0x28	; 40
    4cac:	f0 e0       	ldi	r31, 0x00	; 0
    4cae:	80 81       	ld	r24, Z
    4cb0:	87 7f       	andi	r24, 0xF7	; 247
    4cb2:	8c 93       	st	X, r24
}
    4cb4:	cf 91       	pop	r28
    4cb6:	df 91       	pop	r29
    4cb8:	08 95       	ret

00004cba <buzzer_on>:
* Logic: 			Function used to turn on buzzer
* Example Call:		buzzer_on();
*
*/
void buzzer_on (void)
{
    4cba:	df 93       	push	r29
    4cbc:	cf 93       	push	r28
    4cbe:	0f 92       	push	r0
    4cc0:	cd b7       	in	r28, 0x3d	; 61
    4cc2:	de b7       	in	r29, 0x3e	; 62
 unsigned char port_restore = 0;
    4cc4:	19 82       	std	Y+1, r1	; 0x01
 port_restore = PINC;
    4cc6:	e6 e2       	ldi	r30, 0x26	; 38
    4cc8:	f0 e0       	ldi	r31, 0x00	; 0
    4cca:	80 81       	ld	r24, Z
    4ccc:	89 83       	std	Y+1, r24	; 0x01
 port_restore = port_restore | 0x08;
    4cce:	89 81       	ldd	r24, Y+1	; 0x01
    4cd0:	88 60       	ori	r24, 0x08	; 8
    4cd2:	89 83       	std	Y+1, r24	; 0x01
 PORTC = port_restore;
    4cd4:	e8 e2       	ldi	r30, 0x28	; 40
    4cd6:	f0 e0       	ldi	r31, 0x00	; 0
    4cd8:	89 81       	ldd	r24, Y+1	; 0x01
    4cda:	80 83       	st	Z, r24
}
    4cdc:	0f 90       	pop	r0
    4cde:	cf 91       	pop	r28
    4ce0:	df 91       	pop	r29
    4ce2:	08 95       	ret

00004ce4 <buzzer_off>:
* Logic: 			Function used to turn off buzzer
* Example Call:		buzzer_off();
*
*/
void buzzer_off (void)
{
    4ce4:	df 93       	push	r29
    4ce6:	cf 93       	push	r28
    4ce8:	0f 92       	push	r0
    4cea:	cd b7       	in	r28, 0x3d	; 61
    4cec:	de b7       	in	r29, 0x3e	; 62
 unsigned char port_restore = 0;
    4cee:	19 82       	std	Y+1, r1	; 0x01
 port_restore = PINC;
    4cf0:	e6 e2       	ldi	r30, 0x26	; 38
    4cf2:	f0 e0       	ldi	r31, 0x00	; 0
    4cf4:	80 81       	ld	r24, Z
    4cf6:	89 83       	std	Y+1, r24	; 0x01
 port_restore = port_restore & 0xF7;
    4cf8:	89 81       	ldd	r24, Y+1	; 0x01
    4cfa:	87 7f       	andi	r24, 0xF7	; 247
    4cfc:	89 83       	std	Y+1, r24	; 0x01
 PORTC = port_restore;
    4cfe:	e8 e2       	ldi	r30, 0x28	; 40
    4d00:	f0 e0       	ldi	r31, 0x00	; 0
    4d02:	89 81       	ldd	r24, Y+1	; 0x01
    4d04:	80 83       	st	Z, r24
}
    4d06:	0f 90       	pop	r0
    4d08:	cf 91       	pop	r28
    4d0a:	df 91       	pop	r29
    4d0c:	08 95       	ret

00004d0e <led_pin_config>:
* Logic: 			Function used to configure LED ports
* Example Call:		led_pin_config();
*
*/
void led_pin_config()
{
    4d0e:	df 93       	push	r29
    4d10:	cf 93       	push	r28
    4d12:	cd b7       	in	r28, 0x3d	; 61
    4d14:	de b7       	in	r29, 0x3e	; 62
	DDRG = 0x03;// for right led
    4d16:	e3 e3       	ldi	r30, 0x33	; 51
    4d18:	f0 e0       	ldi	r31, 0x00	; 0
    4d1a:	83 e0       	ldi	r24, 0x03	; 3
    4d1c:	80 83       	st	Z, r24
	DDRH=0x80;// for left led
    4d1e:	e1 e0       	ldi	r30, 0x01	; 1
    4d20:	f1 e0       	ldi	r31, 0x01	; 1
    4d22:	80 e8       	ldi	r24, 0x80	; 128
    4d24:	80 83       	st	Z, r24
}
    4d26:	cf 91       	pop	r28
    4d28:	df 91       	pop	r29
    4d2a:	08 95       	ret

00004d2c <Right_led_on>:
* Logic: 			Function used to turn on right led
* Example Call:		Right_led_on();
*
*/
void Right_led_on()
{
    4d2c:	df 93       	push	r29
    4d2e:	cf 93       	push	r28
    4d30:	cd b7       	in	r28, 0x3d	; 61
    4d32:	de b7       	in	r29, 0x3e	; 62
	PORTG = 0x02;
    4d34:	e4 e3       	ldi	r30, 0x34	; 52
    4d36:	f0 e0       	ldi	r31, 0x00	; 0
    4d38:	82 e0       	ldi	r24, 0x02	; 2
    4d3a:	80 83       	st	Z, r24
}
    4d3c:	cf 91       	pop	r28
    4d3e:	df 91       	pop	r29
    4d40:	08 95       	ret

00004d42 <Right_led_off>:
* Logic: 			Function used to turn off right led
* Example Call:		Right_led_off();
*
*/
void Right_led_off()
{
    4d42:	df 93       	push	r29
    4d44:	cf 93       	push	r28
    4d46:	cd b7       	in	r28, 0x3d	; 61
    4d48:	de b7       	in	r29, 0x3e	; 62
	PORTG = 0x00;
    4d4a:	e4 e3       	ldi	r30, 0x34	; 52
    4d4c:	f0 e0       	ldi	r31, 0x00	; 0
    4d4e:	10 82       	st	Z, r1
}
    4d50:	cf 91       	pop	r28
    4d52:	df 91       	pop	r29
    4d54:	08 95       	ret

00004d56 <Left_led_on>:
* Logic: 			Function used to turn on left led
* Example Call:		Left_led_on();
*
*/
void Left_led_on()
{
    4d56:	df 93       	push	r29
    4d58:	cf 93       	push	r28
    4d5a:	cd b7       	in	r28, 0x3d	; 61
    4d5c:	de b7       	in	r29, 0x3e	; 62
	PORTH = 0x80;
    4d5e:	e2 e0       	ldi	r30, 0x02	; 2
    4d60:	f1 e0       	ldi	r31, 0x01	; 1
    4d62:	80 e8       	ldi	r24, 0x80	; 128
    4d64:	80 83       	st	Z, r24
}
    4d66:	cf 91       	pop	r28
    4d68:	df 91       	pop	r29
    4d6a:	08 95       	ret

00004d6c <Left_led_off>:
* Logic: 			Function used to turn off left led
* Example Call:		Left_led_off();
*
*/
void Left_led_off()
{
    4d6c:	df 93       	push	r29
    4d6e:	cf 93       	push	r28
    4d70:	cd b7       	in	r28, 0x3d	; 61
    4d72:	de b7       	in	r29, 0x3e	; 62
	PORTH = 0x00;
    4d74:	e2 e0       	ldi	r30, 0x02	; 2
    4d76:	f1 e0       	ldi	r31, 0x01	; 1
    4d78:	10 82       	st	Z, r1
}
    4d7a:	cf 91       	pop	r28
    4d7c:	df 91       	pop	r29
    4d7e:	08 95       	ret

00004d80 <uart2_init>:
// desired baud rate:9600
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart2_init(void)
{
    4d80:	df 93       	push	r29
    4d82:	cf 93       	push	r28
    4d84:	cd b7       	in	r28, 0x3d	; 61
    4d86:	de b7       	in	r29, 0x3e	; 62
 UCSR2B = 0x00; //disable while setting baud rate
    4d88:	e1 ed       	ldi	r30, 0xD1	; 209
    4d8a:	f0 e0       	ldi	r31, 0x00	; 0
    4d8c:	10 82       	st	Z, r1
 UCSR2A = 0x00;
    4d8e:	e0 ed       	ldi	r30, 0xD0	; 208
    4d90:	f0 e0       	ldi	r31, 0x00	; 0
    4d92:	10 82       	st	Z, r1
 UCSR2C = 0x06;
    4d94:	e2 ed       	ldi	r30, 0xD2	; 210
    4d96:	f0 e0       	ldi	r31, 0x00	; 0
    4d98:	86 e0       	ldi	r24, 0x06	; 6
    4d9a:	80 83       	st	Z, r24
 UBRR2L = 0x5F; //set baud rate lo
    4d9c:	e4 ed       	ldi	r30, 0xD4	; 212
    4d9e:	f0 e0       	ldi	r31, 0x00	; 0
    4da0:	8f e5       	ldi	r24, 0x5F	; 95
    4da2:	80 83       	st	Z, r24
 UBRR2H = 0x00; //set baud rate hi
    4da4:	e5 ed       	ldi	r30, 0xD5	; 213
    4da6:	f0 e0       	ldi	r31, 0x00	; 0
    4da8:	10 82       	st	Z, r1
 UCSR2B = 0x98;
    4daa:	e1 ed       	ldi	r30, 0xD1	; 209
    4dac:	f0 e0       	ldi	r31, 0x00	; 0
    4dae:	88 e9       	ldi	r24, 0x98	; 152
    4db0:	80 83       	st	Z, r24
}
    4db2:	cf 91       	pop	r28
    4db4:	df 91       	pop	r29
    4db6:	08 95       	ret

00004db8 <__vector_51>:


// the following interrupt is used for recieving serially transmitted data from the python script using pyserial package in python.
SIGNAL(SIG_USART2_RECV){ 		// ISR for receive complete interrupt
    4db8:	1f 92       	push	r1
    4dba:	0f 92       	push	r0
    4dbc:	0f b6       	in	r0, 0x3f	; 63
    4dbe:	0f 92       	push	r0
    4dc0:	00 90 5b 00 	lds	r0, 0x005B
    4dc4:	0f 92       	push	r0
    4dc6:	11 24       	eor	r1, r1
    4dc8:	2f 93       	push	r18
    4dca:	3f 93       	push	r19
    4dcc:	4f 93       	push	r20
    4dce:	5f 93       	push	r21
    4dd0:	6f 93       	push	r22
    4dd2:	7f 93       	push	r23
    4dd4:	8f 93       	push	r24
    4dd6:	9f 93       	push	r25
    4dd8:	af 93       	push	r26
    4dda:	bf 93       	push	r27
    4ddc:	ef 93       	push	r30
    4dde:	ff 93       	push	r31
    4de0:	df 93       	push	r29
    4de2:	cf 93       	push	r28
    4de4:	cd b7       	in	r28, 0x3d	; 61
    4de6:	de b7       	in	r29, 0x3e	; 62
	data = UDR2; 				//making copy of data from UDR2 in 'data' variable 
    4de8:	e6 ed       	ldi	r30, 0xD6	; 214
    4dea:	f0 e0       	ldi	r31, 0x00	; 0
    4dec:	80 81       	ld	r24, Z
    4dee:	80 93 19 04 	sts	0x0419, r24
	UDR2 = data; 				//echo data back to PC
    4df2:	e6 ed       	ldi	r30, 0xD6	; 214
    4df4:	f0 e0       	ldi	r31, 0x00	; 0
    4df6:	80 91 19 04 	lds	r24, 0x0419
    4dfa:	80 83       	st	Z, r24

	if(data == 0x2E){   // ASCII for '.'
    4dfc:	80 91 19 04 	lds	r24, 0x0419
    4e00:	8e 32       	cpi	r24, 0x2E	; 46
    4e02:	21 f5       	brne	.+72     	; 0x4e4c <__vector_51+0x94>
		flag2++;
    4e04:	80 91 ea 03 	lds	r24, 0x03EA
    4e08:	90 91 eb 03 	lds	r25, 0x03EB
    4e0c:	01 96       	adiw	r24, 0x01	; 1
    4e0e:	90 93 eb 03 	sts	0x03EB, r25
    4e12:	80 93 ea 03 	sts	0x03EA, r24
		if(flag2==2){
    4e16:	80 91 ea 03 	lds	r24, 0x03EA
    4e1a:	90 91 eb 03 	lds	r25, 0x03EB
    4e1e:	82 30       	cpi	r24, 0x02	; 2
    4e20:	91 05       	cpc	r25, r1
    4e22:	a1 f4       	brne	.+40     	; 0x4e4c <__vector_51+0x94>
			c=0;
    4e24:	10 92 e5 03 	sts	0x03E5, r1
    4e28:	10 92 e4 03 	sts	0x03E4, r1
			p=0;q=0;m=0,n=0;
    4e2c:	10 92 e7 03 	sts	0x03E7, r1
    4e30:	10 92 e6 03 	sts	0x03E6, r1
    4e34:	10 92 e9 03 	sts	0x03E9, r1
    4e38:	10 92 e8 03 	sts	0x03E8, r1
    4e3c:	10 92 ed 03 	sts	0x03ED, r1
    4e40:	10 92 ec 03 	sts	0x03EC, r1
    4e44:	10 92 f1 03 	sts	0x03F1, r1
    4e48:	10 92 f0 03 	sts	0x03F0, r1
		}
	}
	if(flag2==0){          // flag2 will remain 0 until all the numbers from D1 list(task 1) are recieved
    4e4c:	80 91 ea 03 	lds	r24, 0x03EA
    4e50:	90 91 eb 03 	lds	r25, 0x03EB
    4e54:	00 97       	sbiw	r24, 0x00	; 0
    4e56:	21 f5       	brne	.+72     	; 0x4ea0 <__vector_51+0xe8>
		if(data >=0x30 && data <= 0x39 ){  //ASCII for digits	
    4e58:	80 91 19 04 	lds	r24, 0x0419
    4e5c:	80 33       	cpi	r24, 0x30	; 48
    4e5e:	00 f1       	brcs	.+64     	; 0x4ea0 <__vector_51+0xe8>
    4e60:	80 91 19 04 	lds	r24, 0x0419
    4e64:	8a 33       	cpi	r24, 0x3A	; 58
    4e66:	e0 f4       	brcc	.+56     	; 0x4ea0 <__vector_51+0xe8>
			Grid1[n]= (int)data - 48;  //saves the D1 list generated in task 1 into Grid1[] array(48 is substracted because numbers are recieved in ASCII form)
    4e68:	40 91 f0 03 	lds	r20, 0x03F0
    4e6c:	50 91 f1 03 	lds	r21, 0x03F1
    4e70:	80 91 19 04 	lds	r24, 0x0419
    4e74:	88 2f       	mov	r24, r24
    4e76:	90 e0       	ldi	r25, 0x00	; 0
    4e78:	9c 01       	movw	r18, r24
    4e7a:	20 53       	subi	r18, 0x30	; 48
    4e7c:	30 40       	sbci	r19, 0x00	; 0
    4e7e:	ca 01       	movw	r24, r20
    4e80:	88 0f       	add	r24, r24
    4e82:	99 1f       	adc	r25, r25
    4e84:	fc 01       	movw	r30, r24
    4e86:	e1 50       	subi	r30, 0x01	; 1
    4e88:	fc 4f       	sbci	r31, 0xFC	; 252
    4e8a:	31 83       	std	Z+1, r19	; 0x01
    4e8c:	20 83       	st	Z, r18
			n++;
    4e8e:	80 91 f0 03 	lds	r24, 0x03F0
    4e92:	90 91 f1 03 	lds	r25, 0x03F1
    4e96:	01 96       	adiw	r24, 0x01	; 1
    4e98:	90 93 f1 03 	sts	0x03F1, r25
    4e9c:	80 93 f0 03 	sts	0x03F0, r24
		}
    }
	if (flag2==1 ){		//flag2 will remain 1 until D2 list(task 1) is recieved 
    4ea0:	80 91 ea 03 	lds	r24, 0x03EA
    4ea4:	90 91 eb 03 	lds	r25, 0x03EB
    4ea8:	81 30       	cpi	r24, 0x01	; 1
    4eaa:	91 05       	cpc	r25, r1
    4eac:	09 f0       	breq	.+2      	; 0x4eb0 <__vector_51+0xf8>
    4eae:	85 c0       	rjmp	.+266    	; 0x4fba <__vector_51+0x202>
		if(data == 0x2C){	// ASCII for ','
    4eb0:	80 91 19 04 	lds	r24, 0x0419
    4eb4:	8c 32       	cpi	r24, 0x2C	; 44
    4eb6:	29 f5       	brne	.+74     	; 0x4f02 <__vector_51+0x14a>
			Grid2[m]=s;		// saves D2 list from task 1 into Grid2[] array
    4eb8:	80 91 ec 03 	lds	r24, 0x03EC
    4ebc:	90 91 ed 03 	lds	r25, 0x03ED
    4ec0:	20 91 ee 03 	lds	r18, 0x03EE
    4ec4:	30 91 ef 03 	lds	r19, 0x03EF
    4ec8:	88 0f       	add	r24, r24
    4eca:	99 1f       	adc	r25, r25
    4ecc:	fc 01       	movw	r30, r24
    4ece:	e8 58       	subi	r30, 0x88	; 136
    4ed0:	fb 4f       	sbci	r31, 0xFB	; 251
    4ed2:	31 83       	std	Z+1, r19	; 0x01
    4ed4:	20 83       	st	Z, r18
			c=0;
    4ed6:	10 92 e5 03 	sts	0x03E5, r1
    4eda:	10 92 e4 03 	sts	0x03E4, r1
			p=0;q=0;
    4ede:	10 92 e7 03 	sts	0x03E7, r1
    4ee2:	10 92 e6 03 	sts	0x03E6, r1
    4ee6:	10 92 e9 03 	sts	0x03E9, r1
    4eea:	10 92 e8 03 	sts	0x03E8, r1
			m++;
    4eee:	80 91 ec 03 	lds	r24, 0x03EC
    4ef2:	90 91 ed 03 	lds	r25, 0x03ED
    4ef6:	01 96       	adiw	r24, 0x01	; 1
    4ef8:	90 93 ed 03 	sts	0x03ED, r25
    4efc:	80 93 ec 03 	sts	0x03EC, r24
    4f00:	5c c0       	rjmp	.+184    	; 0x4fba <__vector_51+0x202>
		}
		else if (data >=0x30 && data <= 0x39){	   //ASCII for digits
    4f02:	80 91 19 04 	lds	r24, 0x0419
    4f06:	80 33       	cpi	r24, 0x30	; 48
    4f08:	08 f4       	brcc	.+2      	; 0x4f0c <__vector_51+0x154>
    4f0a:	57 c0       	rjmp	.+174    	; 0x4fba <__vector_51+0x202>
    4f0c:	80 91 19 04 	lds	r24, 0x0419
    4f10:	8a 33       	cpi	r24, 0x3A	; 58
    4f12:	08 f0       	brcs	.+2      	; 0x4f16 <__vector_51+0x15e>
    4f14:	52 c0       	rjmp	.+164    	; 0x4fba <__vector_51+0x202>
			c++;
    4f16:	80 91 e4 03 	lds	r24, 0x03E4
    4f1a:	90 91 e5 03 	lds	r25, 0x03E5
    4f1e:	01 96       	adiw	r24, 0x01	; 1
    4f20:	90 93 e5 03 	sts	0x03E5, r25
    4f24:	80 93 e4 03 	sts	0x03E4, r24
			q=(int)data - 48;		// 48 is substracted because the numbers are recieved in ASCII form
    4f28:	80 91 19 04 	lds	r24, 0x0419
    4f2c:	88 2f       	mov	r24, r24
    4f2e:	90 e0       	ldi	r25, 0x00	; 0
    4f30:	c0 97       	sbiw	r24, 0x30	; 48
    4f32:	90 93 e9 03 	sts	0x03E9, r25
    4f36:	80 93 e8 03 	sts	0x03E8, r24
			if(c==1){			//code below is to recieve double digit numbers as well as single digit numbers from D2 list(task 1)
    4f3a:	80 91 e4 03 	lds	r24, 0x03E4
    4f3e:	90 91 e5 03 	lds	r25, 0x03E5
    4f42:	81 30       	cpi	r24, 0x01	; 1
    4f44:	91 05       	cpc	r25, r1
    4f46:	c9 f4       	brne	.+50     	; 0x4f7a <__vector_51+0x1c2>
				s=p*10+q;
    4f48:	80 91 e6 03 	lds	r24, 0x03E6
    4f4c:	90 91 e7 03 	lds	r25, 0x03E7
    4f50:	9c 01       	movw	r18, r24
    4f52:	22 0f       	add	r18, r18
    4f54:	33 1f       	adc	r19, r19
    4f56:	c9 01       	movw	r24, r18
    4f58:	88 0f       	add	r24, r24
    4f5a:	99 1f       	adc	r25, r25
    4f5c:	88 0f       	add	r24, r24
    4f5e:	99 1f       	adc	r25, r25
    4f60:	28 0f       	add	r18, r24
    4f62:	39 1f       	adc	r19, r25
    4f64:	80 91 e8 03 	lds	r24, 0x03E8
    4f68:	90 91 e9 03 	lds	r25, 0x03E9
    4f6c:	82 0f       	add	r24, r18
    4f6e:	93 1f       	adc	r25, r19
    4f70:	90 93 ef 03 	sts	0x03EF, r25
    4f74:	80 93 ee 03 	sts	0x03EE, r24
    4f78:	20 c0       	rjmp	.+64     	; 0x4fba <__vector_51+0x202>
			}
			else{
				p=s;
    4f7a:	80 91 ee 03 	lds	r24, 0x03EE
    4f7e:	90 91 ef 03 	lds	r25, 0x03EF
    4f82:	90 93 e7 03 	sts	0x03E7, r25
    4f86:	80 93 e6 03 	sts	0x03E6, r24
				s=p*10+q;
    4f8a:	80 91 e6 03 	lds	r24, 0x03E6
    4f8e:	90 91 e7 03 	lds	r25, 0x03E7
    4f92:	9c 01       	movw	r18, r24
    4f94:	22 0f       	add	r18, r18
    4f96:	33 1f       	adc	r19, r19
    4f98:	c9 01       	movw	r24, r18
    4f9a:	88 0f       	add	r24, r24
    4f9c:	99 1f       	adc	r25, r25
    4f9e:	88 0f       	add	r24, r24
    4fa0:	99 1f       	adc	r25, r25
    4fa2:	28 0f       	add	r18, r24
    4fa4:	39 1f       	adc	r19, r25
    4fa6:	80 91 e8 03 	lds	r24, 0x03E8
    4faa:	90 91 e9 03 	lds	r25, 0x03E9
    4fae:	82 0f       	add	r24, r18
    4fb0:	93 1f       	adc	r25, r19
    4fb2:	90 93 ef 03 	sts	0x03EF, r25
    4fb6:	80 93 ee 03 	sts	0x03EE, r24
			}
		}
	}					

	if(flag2==2){	     //flag2 will remain 2 until result of task 2 is recieved
    4fba:	80 91 ea 03 	lds	r24, 0x03EA
    4fbe:	90 91 eb 03 	lds	r25, 0x03EB
    4fc2:	82 30       	cpi	r24, 0x02	; 2
    4fc4:	91 05       	cpc	r25, r1
    4fc6:	09 f0       	breq	.+2      	; 0x4fca <__vector_51+0x212>
    4fc8:	55 c0       	rjmp	.+170    	; 0x5074 <__vector_51+0x2bc>
		 if(data==0x2C){     //ASCII for ','
    4fca:	80 91 19 04 	lds	r24, 0x0419
    4fce:	8c 32       	cpi	r24, 0x2C	; 44
    4fd0:	e9 f4       	brne	.+58     	; 0x500c <__vector_51+0x254>
		 	 num[m]=n;		// num[] array keeps account of how many numbers are required by each target_numbers to complete it
    4fd2:	80 91 ec 03 	lds	r24, 0x03EC
    4fd6:	90 91 ed 03 	lds	r25, 0x03ED
    4fda:	20 91 f0 03 	lds	r18, 0x03F0
    4fde:	30 91 f1 03 	lds	r19, 0x03F1
    4fe2:	88 0f       	add	r24, r24
    4fe4:	99 1f       	adc	r25, r25
    4fe6:	fc 01       	movw	r30, r24
    4fe8:	e8 52       	subi	r30, 0x28	; 40
    4fea:	fc 4f       	sbci	r31, 0xFC	; 252
    4fec:	31 83       	std	Z+1, r19	; 0x01
    4fee:	20 83       	st	Z, r18
		 	 m++;
    4ff0:	80 91 ec 03 	lds	r24, 0x03EC
    4ff4:	90 91 ed 03 	lds	r25, 0x03ED
    4ff8:	01 96       	adiw	r24, 0x01	; 1
    4ffa:	90 93 ed 03 	sts	0x03ED, r25
    4ffe:	80 93 ec 03 	sts	0x03EC, r24
			 n=0;	
    5002:	10 92 f1 03 	sts	0x03F1, r1
    5006:	10 92 f0 03 	sts	0x03F0, r1
    500a:	34 c0       	rjmp	.+104    	; 0x5074 <__vector_51+0x2bc>
		 }
		 else if(data>=0x30 && data<=0x39){     //ASCII for digits
    500c:	80 91 19 04 	lds	r24, 0x0419
    5010:	80 33       	cpi	r24, 0x30	; 48
    5012:	80 f1       	brcs	.+96     	; 0x5074 <__vector_51+0x2bc>
    5014:	80 91 19 04 	lds	r24, 0x0419
    5018:	8a 33       	cpi	r24, 0x3A	; 58
    501a:	60 f5       	brcc	.+88     	; 0x5074 <__vector_51+0x2bc>
		 	 Sol[m][n]=(int)data - 48;  // task 2 result is stored in Sol[][] and 48 is substracted because numbers recieved are in ASCII form
    501c:	40 91 ec 03 	lds	r20, 0x03EC
    5020:	50 91 ed 03 	lds	r21, 0x03ED
    5024:	60 91 f0 03 	lds	r22, 0x03F0
    5028:	70 91 f1 03 	lds	r23, 0x03F1
    502c:	80 91 19 04 	lds	r24, 0x0419
    5030:	88 2f       	mov	r24, r24
    5032:	90 e0       	ldi	r25, 0x00	; 0
    5034:	dc 01       	movw	r26, r24
    5036:	d0 97       	sbiw	r26, 0x30	; 48
    5038:	ca 01       	movw	r24, r20
    503a:	88 0f       	add	r24, r24
    503c:	99 1f       	adc	r25, r25
    503e:	9c 01       	movw	r18, r24
    5040:	22 0f       	add	r18, r18
    5042:	33 1f       	adc	r19, r19
    5044:	22 0f       	add	r18, r18
    5046:	33 1f       	adc	r19, r19
    5048:	82 0f       	add	r24, r18
    504a:	93 1f       	adc	r25, r19
    504c:	84 0f       	add	r24, r20
    504e:	95 1f       	adc	r25, r21
    5050:	86 0f       	add	r24, r22
    5052:	97 1f       	adc	r25, r23
    5054:	88 0f       	add	r24, r24
    5056:	99 1f       	adc	r25, r25
    5058:	fc 01       	movw	r30, r24
    505a:	e4 5e       	subi	r30, 0xE4	; 228
    505c:	fb 4f       	sbci	r31, 0xFB	; 251
    505e:	b1 83       	std	Z+1, r27	; 0x01
    5060:	a0 83       	st	Z, r26
			 n++;
    5062:	80 91 f0 03 	lds	r24, 0x03F0
    5066:	90 91 f1 03 	lds	r25, 0x03F1
    506a:	01 96       	adiw	r24, 0x01	; 1
    506c:	90 93 f1 03 	sts	0x03F1, r25
    5070:	80 93 f0 03 	sts	0x03F0, r24
		 }
	}	 	 	
}
    5074:	cf 91       	pop	r28
    5076:	df 91       	pop	r29
    5078:	ff 91       	pop	r31
    507a:	ef 91       	pop	r30
    507c:	bf 91       	pop	r27
    507e:	af 91       	pop	r26
    5080:	9f 91       	pop	r25
    5082:	8f 91       	pop	r24
    5084:	7f 91       	pop	r23
    5086:	6f 91       	pop	r22
    5088:	5f 91       	pop	r21
    508a:	4f 91       	pop	r20
    508c:	3f 91       	pop	r19
    508e:	2f 91       	pop	r18
    5090:	0f 90       	pop	r0
    5092:	00 92 5b 00 	sts	0x005B, r0
    5096:	0f 90       	pop	r0
    5098:	0f be       	out	0x3f, r0	; 63
    509a:	0f 90       	pop	r0
    509c:	1f 90       	pop	r1
    509e:	18 95       	reti

000050a0 <timer5_init>:
// Timer 5 initialized in PWM mode for velocity control
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
    50a0:	df 93       	push	r29
    50a2:	cf 93       	push	r28
    50a4:	cd b7       	in	r28, 0x3d	; 61
    50a6:	de b7       	in	r29, 0x3e	; 62
	TCCR5B = 0x00;	//Stop
    50a8:	e1 e2       	ldi	r30, 0x21	; 33
    50aa:	f1 e0       	ldi	r31, 0x01	; 1
    50ac:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
    50ae:	e5 e2       	ldi	r30, 0x25	; 37
    50b0:	f1 e0       	ldi	r31, 0x01	; 1
    50b2:	8f ef       	ldi	r24, 0xFF	; 255
    50b4:	80 83       	st	Z, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
    50b6:	e4 e2       	ldi	r30, 0x24	; 36
    50b8:	f1 e0       	ldi	r31, 0x01	; 1
    50ba:	81 e0       	ldi	r24, 0x01	; 1
    50bc:	80 83       	st	Z, r24
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
    50be:	e9 e2       	ldi	r30, 0x29	; 41
    50c0:	f1 e0       	ldi	r31, 0x01	; 1
    50c2:	10 82       	st	Z, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
    50c4:	e8 e2       	ldi	r30, 0x28	; 40
    50c6:	f1 e0       	ldi	r31, 0x01	; 1
    50c8:	8f ef       	ldi	r24, 0xFF	; 255
    50ca:	80 83       	st	Z, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
    50cc:	eb e2       	ldi	r30, 0x2B	; 43
    50ce:	f1 e0       	ldi	r31, 0x01	; 1
    50d0:	10 82       	st	Z, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
    50d2:	ea e2       	ldi	r30, 0x2A	; 42
    50d4:	f1 e0       	ldi	r31, 0x01	; 1
    50d6:	8f ef       	ldi	r24, 0xFF	; 255
    50d8:	80 83       	st	Z, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
    50da:	ed e2       	ldi	r30, 0x2D	; 45
    50dc:	f1 e0       	ldi	r31, 0x01	; 1
    50de:	10 82       	st	Z, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
    50e0:	ec e2       	ldi	r30, 0x2C	; 44
    50e2:	f1 e0       	ldi	r31, 0x01	; 1
    50e4:	8f ef       	ldi	r24, 0xFF	; 255
    50e6:	80 83       	st	Z, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
    50e8:	e0 e2       	ldi	r30, 0x20	; 32
    50ea:	f1 e0       	ldi	r31, 0x01	; 1
    50ec:	89 ea       	ldi	r24, 0xA9	; 169
    50ee:	80 83       	st	Z, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
    50f0:	e1 e2       	ldi	r30, 0x21	; 33
    50f2:	f1 e0       	ldi	r31, 0x01	; 1
    50f4:	8b e0       	ldi	r24, 0x0B	; 11
    50f6:	80 83       	st	Z, r24
}
    50f8:	cf 91       	pop	r28
    50fa:	df 91       	pop	r29
    50fc:	08 95       	ret

000050fe <adc_init>:
* Logic: 			Function used to initialise ADC
* Example Call:		adc_init();
*
*/
void adc_init()
{
    50fe:	df 93       	push	r29
    5100:	cf 93       	push	r28
    5102:	cd b7       	in	r28, 0x3d	; 61
    5104:	de b7       	in	r29, 0x3e	; 62
	ADCSRA = 0x00;
    5106:	ea e7       	ldi	r30, 0x7A	; 122
    5108:	f0 e0       	ldi	r31, 0x00	; 0
    510a:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
    510c:	eb e7       	ldi	r30, 0x7B	; 123
    510e:	f0 e0       	ldi	r31, 0x00	; 0
    5110:	10 82       	st	Z, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
    5112:	ec e7       	ldi	r30, 0x7C	; 124
    5114:	f0 e0       	ldi	r31, 0x00	; 0
    5116:	80 e2       	ldi	r24, 0x20	; 32
    5118:	80 83       	st	Z, r24
	ACSR = 0x80;
    511a:	e0 e5       	ldi	r30, 0x50	; 80
    511c:	f0 e0       	ldi	r31, 0x00	; 0
    511e:	80 e8       	ldi	r24, 0x80	; 128
    5120:	80 83       	st	Z, r24
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
    5122:	ea e7       	ldi	r30, 0x7A	; 122
    5124:	f0 e0       	ldi	r31, 0x00	; 0
    5126:	86 e8       	ldi	r24, 0x86	; 134
    5128:	80 83       	st	Z, r24
}
    512a:	cf 91       	pop	r28
    512c:	df 91       	pop	r29
    512e:	08 95       	ret

00005130 <ADC_Conversion>:
* Logic: 			Function For ADC Conversion
* Example Call:		ADC_Conversion(3);
*
*/
unsigned char ADC_Conversion(unsigned char Ch) 
{
    5130:	df 93       	push	r29
    5132:	cf 93       	push	r28
    5134:	0f 92       	push	r0
    5136:	0f 92       	push	r0
    5138:	cd b7       	in	r28, 0x3d	; 61
    513a:	de b7       	in	r29, 0x3e	; 62
    513c:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char a;
	if(Ch>7)
    513e:	8a 81       	ldd	r24, Y+2	; 0x02
    5140:	88 30       	cpi	r24, 0x08	; 8
    5142:	20 f0       	brcs	.+8      	; 0x514c <ADC_Conversion+0x1c>
	{
		ADCSRB = 0x08;
    5144:	eb e7       	ldi	r30, 0x7B	; 123
    5146:	f0 e0       	ldi	r31, 0x00	; 0
    5148:	88 e0       	ldi	r24, 0x08	; 8
    514a:	80 83       	st	Z, r24
	}
	Ch = Ch & 0x07;  			
    514c:	8a 81       	ldd	r24, Y+2	; 0x02
    514e:	87 70       	andi	r24, 0x07	; 7
    5150:	8a 83       	std	Y+2, r24	; 0x02
	ADMUX= 0x20| Ch;	   		
    5152:	ec e7       	ldi	r30, 0x7C	; 124
    5154:	f0 e0       	ldi	r31, 0x00	; 0
    5156:	8a 81       	ldd	r24, Y+2	; 0x02
    5158:	80 62       	ori	r24, 0x20	; 32
    515a:	80 83       	st	Z, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
    515c:	aa e7       	ldi	r26, 0x7A	; 122
    515e:	b0 e0       	ldi	r27, 0x00	; 0
    5160:	ea e7       	ldi	r30, 0x7A	; 122
    5162:	f0 e0       	ldi	r31, 0x00	; 0
    5164:	80 81       	ld	r24, Z
    5166:	80 64       	ori	r24, 0x40	; 64
    5168:	8c 93       	st	X, r24
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
    516a:	ea e7       	ldi	r30, 0x7A	; 122
    516c:	f0 e0       	ldi	r31, 0x00	; 0
    516e:	80 81       	ld	r24, Z
    5170:	88 2f       	mov	r24, r24
    5172:	90 e0       	ldi	r25, 0x00	; 0
    5174:	80 71       	andi	r24, 0x10	; 16
    5176:	90 70       	andi	r25, 0x00	; 0
    5178:	00 97       	sbiw	r24, 0x00	; 0
    517a:	b9 f3       	breq	.-18     	; 0x516a <ADC_Conversion+0x3a>
	a=ADCH;
    517c:	e9 e7       	ldi	r30, 0x79	; 121
    517e:	f0 e0       	ldi	r31, 0x00	; 0
    5180:	80 81       	ld	r24, Z
    5182:	89 83       	std	Y+1, r24	; 0x01
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
    5184:	aa e7       	ldi	r26, 0x7A	; 122
    5186:	b0 e0       	ldi	r27, 0x00	; 0
    5188:	ea e7       	ldi	r30, 0x7A	; 122
    518a:	f0 e0       	ldi	r31, 0x00	; 0
    518c:	80 81       	ld	r24, Z
    518e:	80 61       	ori	r24, 0x10	; 16
    5190:	8c 93       	st	X, r24
	ADCSRB = 0x00;
    5192:	eb e7       	ldi	r30, 0x7B	; 123
    5194:	f0 e0       	ldi	r31, 0x00	; 0
    5196:	10 82       	st	Z, r1
	return a;
    5198:	89 81       	ldd	r24, Y+1	; 0x01
}
    519a:	0f 90       	pop	r0
    519c:	0f 90       	pop	r0
    519e:	cf 91       	pop	r28
    51a0:	df 91       	pop	r29
    51a2:	08 95       	ret

000051a4 <print_sensor>:
* Logic: 			Function To Print Sesor Values At Desired Row And Coloumn Location on LCD
* Example Call:		print_sensor(1,1,3);
*
*/
void print_sensor(char row, char coloumn,unsigned char channel)
{
    51a4:	df 93       	push	r29
    51a6:	cf 93       	push	r28
    51a8:	00 d0       	rcall	.+0      	; 0x51aa <print_sensor+0x6>
    51aa:	cd b7       	in	r28, 0x3d	; 61
    51ac:	de b7       	in	r29, 0x3e	; 62
    51ae:	89 83       	std	Y+1, r24	; 0x01
    51b0:	6a 83       	std	Y+2, r22	; 0x02
    51b2:	4b 83       	std	Y+3, r20	; 0x03
	
	ADC_Value = ADC_Conversion(channel);
    51b4:	8b 81       	ldd	r24, Y+3	; 0x03
    51b6:	0e 94 98 28 	call	0x5130	; 0x5130 <ADC_Conversion>
    51ba:	80 93 fc 03 	sts	0x03FC, r24
	lcd_print(row, coloumn, ADC_Value, 3);
    51be:	80 91 fc 03 	lds	r24, 0x03FC
    51c2:	28 2f       	mov	r18, r24
    51c4:	30 e0       	ldi	r19, 0x00	; 0
    51c6:	89 81       	ldd	r24, Y+1	; 0x01
    51c8:	6a 81       	ldd	r22, Y+2	; 0x02
    51ca:	a9 01       	movw	r20, r18
    51cc:	23 e0       	ldi	r18, 0x03	; 3
    51ce:	30 e0       	ldi	r19, 0x00	; 0
    51d0:	0e 94 04 25 	call	0x4a08	; 0x4a08 <lcd_print>
}
    51d4:	0f 90       	pop	r0
    51d6:	0f 90       	pop	r0
    51d8:	0f 90       	pop	r0
    51da:	cf 91       	pop	r28
    51dc:	df 91       	pop	r29
    51de:	08 95       	ret

000051e0 <velocity>:
* Logic: 			Function for velocity control
* Example Call:		velocity(115,125);
*
*/
void velocity (unsigned char left_motor, unsigned char right_motor)
{
    51e0:	df 93       	push	r29
    51e2:	cf 93       	push	r28
    51e4:	0f 92       	push	r0
    51e6:	0f 92       	push	r0
    51e8:	cd b7       	in	r28, 0x3d	; 61
    51ea:	de b7       	in	r29, 0x3e	; 62
    51ec:	89 83       	std	Y+1, r24	; 0x01
    51ee:	6a 83       	std	Y+2, r22	; 0x02
	OCR5AL = (unsigned char)left_motor;
    51f0:	e8 e2       	ldi	r30, 0x28	; 40
    51f2:	f1 e0       	ldi	r31, 0x01	; 1
    51f4:	89 81       	ldd	r24, Y+1	; 0x01
    51f6:	80 83       	st	Z, r24
	OCR5BL = (unsigned char)right_motor;
    51f8:	ea e2       	ldi	r30, 0x2A	; 42
    51fa:	f1 e0       	ldi	r31, 0x01	; 1
    51fc:	8a 81       	ldd	r24, Y+2	; 0x02
    51fe:	80 83       	st	Z, r24
}
    5200:	0f 90       	pop	r0
    5202:	0f 90       	pop	r0
    5204:	cf 91       	pop	r28
    5206:	df 91       	pop	r29
    5208:	08 95       	ret

0000520a <left_encoder_pin_config>:
* Logic: 			Function used to configure pins for left encoder
* Example Call:		left_encoder_pin_config();
*
*/
void left_encoder_pin_config (void)
{
    520a:	df 93       	push	r29
    520c:	cf 93       	push	r28
    520e:	cd b7       	in	r28, 0x3d	; 61
    5210:	de b7       	in	r29, 0x3e	; 62
 DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
    5212:	ad e2       	ldi	r26, 0x2D	; 45
    5214:	b0 e0       	ldi	r27, 0x00	; 0
    5216:	ed e2       	ldi	r30, 0x2D	; 45
    5218:	f0 e0       	ldi	r31, 0x00	; 0
    521a:	80 81       	ld	r24, Z
    521c:	8f 7e       	andi	r24, 0xEF	; 239
    521e:	8c 93       	st	X, r24
 PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
    5220:	ae e2       	ldi	r26, 0x2E	; 46
    5222:	b0 e0       	ldi	r27, 0x00	; 0
    5224:	ee e2       	ldi	r30, 0x2E	; 46
    5226:	f0 e0       	ldi	r31, 0x00	; 0
    5228:	80 81       	ld	r24, Z
    522a:	80 61       	ori	r24, 0x10	; 16
    522c:	8c 93       	st	X, r24
}
    522e:	cf 91       	pop	r28
    5230:	df 91       	pop	r29
    5232:	08 95       	ret

00005234 <right_encoder_pin_config>:
* Logic: 			Function used to configure pins for left encoder
* Example Call:		right_encoder_pin_config();
*
*/
void right_encoder_pin_config (void)
{
    5234:	df 93       	push	r29
    5236:	cf 93       	push	r28
    5238:	cd b7       	in	r28, 0x3d	; 61
    523a:	de b7       	in	r29, 0x3e	; 62
 DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
    523c:	ad e2       	ldi	r26, 0x2D	; 45
    523e:	b0 e0       	ldi	r27, 0x00	; 0
    5240:	ed e2       	ldi	r30, 0x2D	; 45
    5242:	f0 e0       	ldi	r31, 0x00	; 0
    5244:	80 81       	ld	r24, Z
    5246:	8f 7d       	andi	r24, 0xDF	; 223
    5248:	8c 93       	st	X, r24
 PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
    524a:	ae e2       	ldi	r26, 0x2E	; 46
    524c:	b0 e0       	ldi	r27, 0x00	; 0
    524e:	ee e2       	ldi	r30, 0x2E	; 46
    5250:	f0 e0       	ldi	r31, 0x00	; 0
    5252:	80 81       	ld	r24, Z
    5254:	80 62       	ori	r24, 0x20	; 32
    5256:	8c 93       	st	X, r24
}
    5258:	cf 91       	pop	r28
    525a:	df 91       	pop	r29
    525c:	08 95       	ret

0000525e <left_position_encoder_interrupt_init>:
* Logic: 			Function to configure INT4 (PORTE 4) pin as input for the right position encoder
* Example Call:		left_position_encoder_interrupt_init();
*
*/
void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
    525e:	df 93       	push	r29
    5260:	cf 93       	push	r28
    5262:	cd b7       	in	r28, 0x3d	; 61
    5264:	de b7       	in	r29, 0x3e	; 62
 cli(); //Clears the global interrupt
    5266:	f8 94       	cli
 EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
    5268:	aa e6       	ldi	r26, 0x6A	; 106
    526a:	b0 e0       	ldi	r27, 0x00	; 0
    526c:	ea e6       	ldi	r30, 0x6A	; 106
    526e:	f0 e0       	ldi	r31, 0x00	; 0
    5270:	80 81       	ld	r24, Z
    5272:	82 60       	ori	r24, 0x02	; 2
    5274:	8c 93       	st	X, r24
 EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
    5276:	ad e3       	ldi	r26, 0x3D	; 61
    5278:	b0 e0       	ldi	r27, 0x00	; 0
    527a:	ed e3       	ldi	r30, 0x3D	; 61
    527c:	f0 e0       	ldi	r31, 0x00	; 0
    527e:	80 81       	ld	r24, Z
    5280:	80 61       	ori	r24, 0x10	; 16
    5282:	8c 93       	st	X, r24
 sei();   // Enables the global interrupt 
    5284:	78 94       	sei
}
    5286:	cf 91       	pop	r28
    5288:	df 91       	pop	r29
    528a:	08 95       	ret

0000528c <right_position_encoder_interrupt_init>:
* Logic: 			Function to configure INT5 (PORTE 5) pin as input for the right position encoder
* Example Call:		right_position_encoder_interrupt_init();
*
*/
void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
    528c:	df 93       	push	r29
    528e:	cf 93       	push	r28
    5290:	cd b7       	in	r28, 0x3d	; 61
    5292:	de b7       	in	r29, 0x3e	; 62
 cli(); //Clears the global interrupt
    5294:	f8 94       	cli
 EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
    5296:	aa e6       	ldi	r26, 0x6A	; 106
    5298:	b0 e0       	ldi	r27, 0x00	; 0
    529a:	ea e6       	ldi	r30, 0x6A	; 106
    529c:	f0 e0       	ldi	r31, 0x00	; 0
    529e:	80 81       	ld	r24, Z
    52a0:	88 60       	ori	r24, 0x08	; 8
    52a2:	8c 93       	st	X, r24
 EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
    52a4:	ad e3       	ldi	r26, 0x3D	; 61
    52a6:	b0 e0       	ldi	r27, 0x00	; 0
    52a8:	ed e3       	ldi	r30, 0x3D	; 61
    52aa:	f0 e0       	ldi	r31, 0x00	; 0
    52ac:	80 81       	ld	r24, Z
    52ae:	80 62       	ori	r24, 0x20	; 32
    52b0:	8c 93       	st	X, r24
 sei();   // Enables the global interrupt 
    52b2:	78 94       	sei
}
    52b4:	cf 91       	pop	r28
    52b6:	df 91       	pop	r29
    52b8:	08 95       	ret

000052ba <boot_key_interrupt_init>:
* Logic: 			Function to configure INT7 (PORTE 7) pin as input for the boot key
* Example Call:		boot_key_interrupt_init();
*
*/
void boot_key_interrupt_init(void)
{
    52ba:	df 93       	push	r29
    52bc:	cf 93       	push	r28
    52be:	cd b7       	in	r28, 0x3d	; 61
    52c0:	de b7       	in	r29, 0x3e	; 62
	cli();
    52c2:	f8 94       	cli
	EICRB= EICRB | 0x80;
    52c4:	aa e6       	ldi	r26, 0x6A	; 106
    52c6:	b0 e0       	ldi	r27, 0x00	; 0
    52c8:	ea e6       	ldi	r30, 0x6A	; 106
    52ca:	f0 e0       	ldi	r31, 0x00	; 0
    52cc:	80 81       	ld	r24, Z
    52ce:	80 68       	ori	r24, 0x80	; 128
    52d0:	8c 93       	st	X, r24
	EIMSK= EIMSK | 0x80;
    52d2:	ad e3       	ldi	r26, 0x3D	; 61
    52d4:	b0 e0       	ldi	r27, 0x00	; 0
    52d6:	ed e3       	ldi	r30, 0x3D	; 61
    52d8:	f0 e0       	ldi	r31, 0x00	; 0
    52da:	80 81       	ld	r24, Z
    52dc:	80 68       	ori	r24, 0x80	; 128
    52de:	8c 93       	st	X, r24
	sei();
    52e0:	78 94       	sei
}
    52e2:	cf 91       	pop	r28
    52e4:	df 91       	pop	r29
    52e6:	08 95       	ret

000052e8 <__vector_8>:

//ISR for boot key press
ISR(INT7_vect)
{
    52e8:	1f 92       	push	r1
    52ea:	0f 92       	push	r0
    52ec:	0f b6       	in	r0, 0x3f	; 63
    52ee:	0f 92       	push	r0
    52f0:	11 24       	eor	r1, r1
    52f2:	8f 93       	push	r24
    52f4:	9f 93       	push	r25
    52f6:	df 93       	push	r29
    52f8:	cf 93       	push	r28
    52fa:	cd b7       	in	r28, 0x3d	; 61
    52fc:	de b7       	in	r29, 0x3e	; 62
	boot_key_press=1;
    52fe:	81 e0       	ldi	r24, 0x01	; 1
    5300:	90 e0       	ldi	r25, 0x00	; 0
    5302:	90 93 d7 03 	sts	0x03D7, r25
    5306:	80 93 d6 03 	sts	0x03D6, r24
}
    530a:	cf 91       	pop	r28
    530c:	df 91       	pop	r29
    530e:	9f 91       	pop	r25
    5310:	8f 91       	pop	r24
    5312:	0f 90       	pop	r0
    5314:	0f be       	out	0x3f, r0	; 63
    5316:	0f 90       	pop	r0
    5318:	1f 90       	pop	r1
    531a:	18 95       	reti

0000531c <__vector_6>:



//ISR for right position encoder
ISR(INT5_vect)  
{
    531c:	1f 92       	push	r1
    531e:	0f 92       	push	r0
    5320:	0f b6       	in	r0, 0x3f	; 63
    5322:	0f 92       	push	r0
    5324:	11 24       	eor	r1, r1
    5326:	8f 93       	push	r24
    5328:	9f 93       	push	r25
    532a:	af 93       	push	r26
    532c:	bf 93       	push	r27
    532e:	df 93       	push	r29
    5330:	cf 93       	push	r28
    5332:	cd b7       	in	r28, 0x3d	; 61
    5334:	de b7       	in	r29, 0x3e	; 62
 ShaftCountRight++;  //increment right shaft position count
    5336:	80 91 d2 03 	lds	r24, 0x03D2
    533a:	90 91 d3 03 	lds	r25, 0x03D3
    533e:	a0 91 d4 03 	lds	r26, 0x03D4
    5342:	b0 91 d5 03 	lds	r27, 0x03D5
    5346:	01 96       	adiw	r24, 0x01	; 1
    5348:	a1 1d       	adc	r26, r1
    534a:	b1 1d       	adc	r27, r1
    534c:	80 93 d2 03 	sts	0x03D2, r24
    5350:	90 93 d3 03 	sts	0x03D3, r25
    5354:	a0 93 d4 03 	sts	0x03D4, r26
    5358:	b0 93 d5 03 	sts	0x03D5, r27
}
    535c:	cf 91       	pop	r28
    535e:	df 91       	pop	r29
    5360:	bf 91       	pop	r27
    5362:	af 91       	pop	r26
    5364:	9f 91       	pop	r25
    5366:	8f 91       	pop	r24
    5368:	0f 90       	pop	r0
    536a:	0f be       	out	0x3f, r0	; 63
    536c:	0f 90       	pop	r0
    536e:	1f 90       	pop	r1
    5370:	18 95       	reti

00005372 <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
    5372:	1f 92       	push	r1
    5374:	0f 92       	push	r0
    5376:	0f b6       	in	r0, 0x3f	; 63
    5378:	0f 92       	push	r0
    537a:	11 24       	eor	r1, r1
    537c:	8f 93       	push	r24
    537e:	9f 93       	push	r25
    5380:	af 93       	push	r26
    5382:	bf 93       	push	r27
    5384:	df 93       	push	r29
    5386:	cf 93       	push	r28
    5388:	cd b7       	in	r28, 0x3d	; 61
    538a:	de b7       	in	r29, 0x3e	; 62
 ShaftCountLeft++;  //increment left shaft position count
    538c:	80 91 ce 03 	lds	r24, 0x03CE
    5390:	90 91 cf 03 	lds	r25, 0x03CF
    5394:	a0 91 d0 03 	lds	r26, 0x03D0
    5398:	b0 91 d1 03 	lds	r27, 0x03D1
    539c:	01 96       	adiw	r24, 0x01	; 1
    539e:	a1 1d       	adc	r26, r1
    53a0:	b1 1d       	adc	r27, r1
    53a2:	80 93 ce 03 	sts	0x03CE, r24
    53a6:	90 93 cf 03 	sts	0x03CF, r25
    53aa:	a0 93 d0 03 	sts	0x03D0, r26
    53ae:	b0 93 d1 03 	sts	0x03D1, r27
}
    53b2:	cf 91       	pop	r28
    53b4:	df 91       	pop	r29
    53b6:	bf 91       	pop	r27
    53b8:	af 91       	pop	r26
    53ba:	9f 91       	pop	r25
    53bc:	8f 91       	pop	r24
    53be:	0f 90       	pop	r0
    53c0:	0f be       	out	0x3f, r0	; 63
    53c2:	0f 90       	pop	r0
    53c4:	1f 90       	pop	r1
    53c6:	18 95       	reti

000053c8 <motion_set>:
* Logic: 			Function used to set motion of the robot
* Example Call:		motion_Set();
*
*/
void motion_set (unsigned char Direction)
{
    53c8:	df 93       	push	r29
    53ca:	cf 93       	push	r28
    53cc:	0f 92       	push	r0
    53ce:	0f 92       	push	r0
    53d0:	cd b7       	in	r28, 0x3d	; 61
    53d2:	de b7       	in	r29, 0x3e	; 62
    53d4:	8a 83       	std	Y+2, r24	; 0x02
 unsigned char PortARestore = 0;
    53d6:	19 82       	std	Y+1, r1	; 0x01

 Direction &= 0x0F; 		// removing upper nibbel for the protection
    53d8:	8a 81       	ldd	r24, Y+2	; 0x02
    53da:	8f 70       	andi	r24, 0x0F	; 15
    53dc:	8a 83       	std	Y+2, r24	; 0x02
 PortARestore = PORTA; 		// reading the PORTA original status
    53de:	e2 e2       	ldi	r30, 0x22	; 34
    53e0:	f0 e0       	ldi	r31, 0x00	; 0
    53e2:	80 81       	ld	r24, Z
    53e4:	89 83       	std	Y+1, r24	; 0x01
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    53e6:	89 81       	ldd	r24, Y+1	; 0x01
    53e8:	80 7f       	andi	r24, 0xF0	; 240
    53ea:	89 83       	std	Y+1, r24	; 0x01
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
    53ec:	99 81       	ldd	r25, Y+1	; 0x01
    53ee:	8a 81       	ldd	r24, Y+2	; 0x02
    53f0:	89 2b       	or	r24, r25
    53f2:	89 83       	std	Y+1, r24	; 0x01
 PORTA = PortARestore; 		// executing the command
    53f4:	e2 e2       	ldi	r30, 0x22	; 34
    53f6:	f0 e0       	ldi	r31, 0x00	; 0
    53f8:	89 81       	ldd	r24, Y+1	; 0x01
    53fa:	80 83       	st	Z, r24
}
    53fc:	0f 90       	pop	r0
    53fe:	0f 90       	pop	r0
    5400:	cf 91       	pop	r28
    5402:	df 91       	pop	r29
    5404:	08 95       	ret

00005406 <forward>:


void forward (void) //used to move robot in forward direction
{
    5406:	df 93       	push	r29
    5408:	cf 93       	push	r28
    540a:	cd b7       	in	r28, 0x3d	; 61
    540c:	de b7       	in	r29, 0x3e	; 62
  motion_set (0x06);
    540e:	86 e0       	ldi	r24, 0x06	; 6
    5410:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    5414:	cf 91       	pop	r28
    5416:	df 91       	pop	r29
    5418:	08 95       	ret

0000541a <stop>:


void stop (void) //used to stop the robot
{
    541a:	df 93       	push	r29
    541c:	cf 93       	push	r28
    541e:	cd b7       	in	r28, 0x3d	; 61
    5420:	de b7       	in	r29, 0x3e	; 62
  motion_set (0x00);
    5422:	80 e0       	ldi	r24, 0x00	; 0
    5424:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    5428:	cf 91       	pop	r28
    542a:	df 91       	pop	r29
    542c:	08 95       	ret

0000542e <back>:


void back (void) //both wheels backward
{
    542e:	df 93       	push	r29
    5430:	cf 93       	push	r28
    5432:	cd b7       	in	r28, 0x3d	; 61
    5434:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x09);
    5436:	89 e0       	ldi	r24, 0x09	; 9
    5438:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    543c:	cf 91       	pop	r28
    543e:	df 91       	pop	r29
    5440:	08 95       	ret

00005442 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
    5442:	df 93       	push	r29
    5444:	cf 93       	push	r28
    5446:	cd b7       	in	r28, 0x3d	; 61
    5448:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x05);
    544a:	85 e0       	ldi	r24, 0x05	; 5
    544c:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    5450:	cf 91       	pop	r28
    5452:	df 91       	pop	r29
    5454:	08 95       	ret

00005456 <right>:

void right (void) //Left wheel forward, Right wheel backward
{
    5456:	df 93       	push	r29
    5458:	cf 93       	push	r28
    545a:	cd b7       	in	r28, 0x3d	; 61
    545c:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x0A);
    545e:	8a e0       	ldi	r24, 0x0A	; 10
    5460:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    5464:	cf 91       	pop	r28
    5466:	df 91       	pop	r29
    5468:	08 95       	ret

0000546a <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
    546a:	df 93       	push	r29
    546c:	cf 93       	push	r28
    546e:	cd b7       	in	r28, 0x3d	; 61
    5470:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x04);
    5472:	84 e0       	ldi	r24, 0x04	; 4
    5474:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    5478:	cf 91       	pop	r28
    547a:	df 91       	pop	r29
    547c:	08 95       	ret

0000547e <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
    547e:	df 93       	push	r29
    5480:	cf 93       	push	r28
    5482:	cd b7       	in	r28, 0x3d	; 61
    5484:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x02);
    5486:	82 e0       	ldi	r24, 0x02	; 2
    5488:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    548c:	cf 91       	pop	r28
    548e:	df 91       	pop	r29
    5490:	08 95       	ret

00005492 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
    5492:	df 93       	push	r29
    5494:	cf 93       	push	r28
    5496:	cd b7       	in	r28, 0x3d	; 61
    5498:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x01);
    549a:	81 e0       	ldi	r24, 0x01	; 1
    549c:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    54a0:	cf 91       	pop	r28
    54a2:	df 91       	pop	r29
    54a4:	08 95       	ret

000054a6 <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
    54a6:	df 93       	push	r29
    54a8:	cf 93       	push	r28
    54aa:	cd b7       	in	r28, 0x3d	; 61
    54ac:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x08);
    54ae:	88 e0       	ldi	r24, 0x08	; 8
    54b0:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <motion_set>
}
    54b4:	cf 91       	pop	r28
    54b6:	df 91       	pop	r29
    54b8:	08 95       	ret

000054ba <angle_rotate>:
* Logic: 			Function used to rotate the robot by specified degrees.
* Example Call:		angle_rotate(90);
*
*/
void angle_rotate(unsigned int Degrees)
{
    54ba:	df 93       	push	r29
    54bc:	cf 93       	push	r28
    54be:	cd b7       	in	r28, 0x3d	; 61
    54c0:	de b7       	in	r29, 0x3e	; 62
    54c2:	2c 97       	sbiw	r28, 0x0c	; 12
    54c4:	0f b6       	in	r0, 0x3f	; 63
    54c6:	f8 94       	cli
    54c8:	de bf       	out	0x3e, r29	; 62
    54ca:	0f be       	out	0x3f, r0	; 63
    54cc:	cd bf       	out	0x3d, r28	; 61
    54ce:	9a 87       	std	Y+10, r25	; 0x0a
    54d0:	89 87       	std	Y+9, r24	; 0x09
 float ReqdShaftCount = 0;
    54d2:	80 e0       	ldi	r24, 0x00	; 0
    54d4:	90 e0       	ldi	r25, 0x00	; 0
    54d6:	a0 e0       	ldi	r26, 0x00	; 0
    54d8:	b0 e0       	ldi	r27, 0x00	; 0
    54da:	8d 83       	std	Y+5, r24	; 0x05
    54dc:	9e 83       	std	Y+6, r25	; 0x06
    54de:	af 83       	std	Y+7, r26	; 0x07
    54e0:	b8 87       	std	Y+8, r27	; 0x08
 unsigned long int ReqdShaftCountInt = 0;
    54e2:	19 82       	std	Y+1, r1	; 0x01
    54e4:	1a 82       	std	Y+2, r1	; 0x02
    54e6:	1b 82       	std	Y+3, r1	; 0x03
    54e8:	1c 82       	std	Y+4, r1	; 0x04

 ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
    54ea:	89 85       	ldd	r24, Y+9	; 0x09
    54ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    54ee:	cc 01       	movw	r24, r24
    54f0:	a0 e0       	ldi	r26, 0x00	; 0
    54f2:	b0 e0       	ldi	r27, 0x00	; 0
    54f4:	bc 01       	movw	r22, r24
    54f6:	cd 01       	movw	r24, r26
    54f8:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <__floatunsisf>
    54fc:	dc 01       	movw	r26, r24
    54fe:	cb 01       	movw	r24, r22
    5500:	bc 01       	movw	r22, r24
    5502:	cd 01       	movw	r24, r26
    5504:	28 e4       	ldi	r18, 0x48	; 72
    5506:	31 ee       	ldi	r19, 0xE1	; 225
    5508:	42 e8       	ldi	r20, 0x82	; 130
    550a:	50 e4       	ldi	r21, 0x40	; 64
    550c:	0e 94 f2 3d 	call	0x7be4	; 0x7be4 <__divsf3>
    5510:	dc 01       	movw	r26, r24
    5512:	cb 01       	movw	r24, r22
    5514:	8d 83       	std	Y+5, r24	; 0x05
    5516:	9e 83       	std	Y+6, r25	; 0x06
    5518:	af 83       	std	Y+7, r26	; 0x07
    551a:	b8 87       	std	Y+8, r27	; 0x08
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    551c:	6d 81       	ldd	r22, Y+5	; 0x05
    551e:	7e 81       	ldd	r23, Y+6	; 0x06
    5520:	8f 81       	ldd	r24, Y+7	; 0x07
    5522:	98 85       	ldd	r25, Y+8	; 0x08
    5524:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5528:	dc 01       	movw	r26, r24
    552a:	cb 01       	movw	r24, r22
    552c:	cc 01       	movw	r24, r24
    552e:	a0 e0       	ldi	r26, 0x00	; 0
    5530:	b0 e0       	ldi	r27, 0x00	; 0
    5532:	89 83       	std	Y+1, r24	; 0x01
    5534:	9a 83       	std	Y+2, r25	; 0x02
    5536:	ab 83       	std	Y+3, r26	; 0x03
    5538:	bc 83       	std	Y+4, r27	; 0x04
 ShaftCountRight = 0; 
    553a:	10 92 d2 03 	sts	0x03D2, r1
    553e:	10 92 d3 03 	sts	0x03D3, r1
    5542:	10 92 d4 03 	sts	0x03D4, r1
    5546:	10 92 d5 03 	sts	0x03D5, r1
 ShaftCountLeft = 0; 
    554a:	10 92 ce 03 	sts	0x03CE, r1
    554e:	10 92 cf 03 	sts	0x03CF, r1
    5552:	10 92 d0 03 	sts	0x03D0, r1
    5556:	10 92 d1 03 	sts	0x03D1, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
    555a:	20 91 d2 03 	lds	r18, 0x03D2
    555e:	30 91 d3 03 	lds	r19, 0x03D3
    5562:	40 91 d4 03 	lds	r20, 0x03D4
    5566:	50 91 d5 03 	lds	r21, 0x03D5
    556a:	1c 86       	std	Y+12, r1	; 0x0c
    556c:	89 81       	ldd	r24, Y+1	; 0x01
    556e:	9a 81       	ldd	r25, Y+2	; 0x02
    5570:	ab 81       	ldd	r26, Y+3	; 0x03
    5572:	bc 81       	ldd	r27, Y+4	; 0x04
    5574:	28 17       	cp	r18, r24
    5576:	39 07       	cpc	r19, r25
    5578:	4a 07       	cpc	r20, r26
    557a:	5b 07       	cpc	r21, r27
    557c:	10 f0       	brcs	.+4      	; 0x5582 <angle_rotate+0xc8>
    557e:	81 e0       	ldi	r24, 0x01	; 1
    5580:	8c 87       	std	Y+12, r24	; 0x0c
    5582:	20 91 ce 03 	lds	r18, 0x03CE
    5586:	30 91 cf 03 	lds	r19, 0x03CF
    558a:	40 91 d0 03 	lds	r20, 0x03D0
    558e:	50 91 d1 03 	lds	r21, 0x03D1
    5592:	1b 86       	std	Y+11, r1	; 0x0b
    5594:	89 81       	ldd	r24, Y+1	; 0x01
    5596:	9a 81       	ldd	r25, Y+2	; 0x02
    5598:	ab 81       	ldd	r26, Y+3	; 0x03
    559a:	bc 81       	ldd	r27, Y+4	; 0x04
    559c:	28 17       	cp	r18, r24
    559e:	39 07       	cpc	r19, r25
    55a0:	4a 07       	cpc	r20, r26
    55a2:	5b 07       	cpc	r21, r27
    55a4:	10 f0       	brcs	.+4      	; 0x55aa <angle_rotate+0xf0>
    55a6:	91 e0       	ldi	r25, 0x01	; 1
    55a8:	9b 87       	std	Y+11, r25	; 0x0b
    55aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    55ac:	9b 85       	ldd	r25, Y+11	; 0x0b
    55ae:	89 2b       	or	r24, r25
    55b0:	88 23       	and	r24, r24
    55b2:	99 f2       	breq	.-90     	; 0x555a <angle_rotate+0xa0>
  break;
 }
 stop(); //Stop robot
    55b4:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
}
    55b8:	2c 96       	adiw	r28, 0x0c	; 12
    55ba:	0f b6       	in	r0, 0x3f	; 63
    55bc:	f8 94       	cli
    55be:	de bf       	out	0x3e, r29	; 62
    55c0:	0f be       	out	0x3f, r0	; 63
    55c2:	cd bf       	out	0x3d, r28	; 61
    55c4:	cf 91       	pop	r28
    55c6:	df 91       	pop	r29
    55c8:	08 95       	ret

000055ca <linear_distance_mm>:
* Logic: 			Function used for moving robot forward or backward by specified distance
* Example Call:		linear_distance_mm(30);
*
*/
void linear_distance_mm(unsigned int DistanceInMM)
{
    55ca:	df 93       	push	r29
    55cc:	cf 93       	push	r28
    55ce:	cd b7       	in	r28, 0x3d	; 61
    55d0:	de b7       	in	r29, 0x3e	; 62
    55d2:	2a 97       	sbiw	r28, 0x0a	; 10
    55d4:	0f b6       	in	r0, 0x3f	; 63
    55d6:	f8 94       	cli
    55d8:	de bf       	out	0x3e, r29	; 62
    55da:	0f be       	out	0x3f, r0	; 63
    55dc:	cd bf       	out	0x3d, r28	; 61
    55de:	9a 87       	std	Y+10, r25	; 0x0a
    55e0:	89 87       	std	Y+9, r24	; 0x09
 float ReqdShaftCount = 0;
    55e2:	80 e0       	ldi	r24, 0x00	; 0
    55e4:	90 e0       	ldi	r25, 0x00	; 0
    55e6:	a0 e0       	ldi	r26, 0x00	; 0
    55e8:	b0 e0       	ldi	r27, 0x00	; 0
    55ea:	8d 83       	std	Y+5, r24	; 0x05
    55ec:	9e 83       	std	Y+6, r25	; 0x06
    55ee:	af 83       	std	Y+7, r26	; 0x07
    55f0:	b8 87       	std	Y+8, r27	; 0x08
 unsigned long int ReqdShaftCountInt = 0;
    55f2:	19 82       	std	Y+1, r1	; 0x01
    55f4:	1a 82       	std	Y+2, r1	; 0x02
    55f6:	1b 82       	std	Y+3, r1	; 0x03
    55f8:	1c 82       	std	Y+4, r1	; 0x04

 ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
    55fa:	89 85       	ldd	r24, Y+9	; 0x09
    55fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    55fe:	cc 01       	movw	r24, r24
    5600:	a0 e0       	ldi	r26, 0x00	; 0
    5602:	b0 e0       	ldi	r27, 0x00	; 0
    5604:	bc 01       	movw	r22, r24
    5606:	cd 01       	movw	r24, r26
    5608:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <__floatunsisf>
    560c:	dc 01       	movw	r26, r24
    560e:	cb 01       	movw	r24, r22
    5610:	bc 01       	movw	r22, r24
    5612:	cd 01       	movw	r24, r26
    5614:	25 ee       	ldi	r18, 0xE5	; 229
    5616:	30 ed       	ldi	r19, 0xD0	; 208
    5618:	4a ea       	ldi	r20, 0xAA	; 170
    561a:	50 e4       	ldi	r21, 0x40	; 64
    561c:	0e 94 f2 3d 	call	0x7be4	; 0x7be4 <__divsf3>
    5620:	dc 01       	movw	r26, r24
    5622:	cb 01       	movw	r24, r22
    5624:	8d 83       	std	Y+5, r24	; 0x05
    5626:	9e 83       	std	Y+6, r25	; 0x06
    5628:	af 83       	std	Y+7, r26	; 0x07
    562a:	b8 87       	std	Y+8, r27	; 0x08
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
    562c:	6d 81       	ldd	r22, Y+5	; 0x05
    562e:	7e 81       	ldd	r23, Y+6	; 0x06
    5630:	8f 81       	ldd	r24, Y+7	; 0x07
    5632:	98 85       	ldd	r25, Y+8	; 0x08
    5634:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5638:	dc 01       	movw	r26, r24
    563a:	cb 01       	movw	r24, r22
    563c:	89 83       	std	Y+1, r24	; 0x01
    563e:	9a 83       	std	Y+2, r25	; 0x02
    5640:	ab 83       	std	Y+3, r26	; 0x03
    5642:	bc 83       	std	Y+4, r27	; 0x04
  
 ShaftCountRight = 0;
    5644:	10 92 d2 03 	sts	0x03D2, r1
    5648:	10 92 d3 03 	sts	0x03D3, r1
    564c:	10 92 d4 03 	sts	0x03D4, r1
    5650:	10 92 d5 03 	sts	0x03D5, r1
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
    5654:	20 91 d2 03 	lds	r18, 0x03D2
    5658:	30 91 d3 03 	lds	r19, 0x03D3
    565c:	40 91 d4 03 	lds	r20, 0x03D4
    5660:	50 91 d5 03 	lds	r21, 0x03D5
    5664:	89 81       	ldd	r24, Y+1	; 0x01
    5666:	9a 81       	ldd	r25, Y+2	; 0x02
    5668:	ab 81       	ldd	r26, Y+3	; 0x03
    566a:	bc 81       	ldd	r27, Y+4	; 0x04
    566c:	82 17       	cp	r24, r18
    566e:	93 07       	cpc	r25, r19
    5670:	a4 07       	cpc	r26, r20
    5672:	b5 07       	cpc	r27, r21
    5674:	78 f7       	brcc	.-34     	; 0x5654 <linear_distance_mm+0x8a>
  {
  	break;
  }
 } 
 stop(); //Stop robot
    5676:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
}
    567a:	2a 96       	adiw	r28, 0x0a	; 10
    567c:	0f b6       	in	r0, 0x3f	; 63
    567e:	f8 94       	cli
    5680:	de bf       	out	0x3e, r29	; 62
    5682:	0f be       	out	0x3f, r0	; 63
    5684:	cd bf       	out	0x3d, r28	; 61
    5686:	cf 91       	pop	r28
    5688:	df 91       	pop	r29
    568a:	08 95       	ret

0000568c <forward_mm>:
* Logic: 			Called if user wants to move the robot forward by specific distance
* Example Call:		forward_mm(30);
*
*/
void forward_mm(unsigned int DistanceInMM)
{
    568c:	df 93       	push	r29
    568e:	cf 93       	push	r28
    5690:	0f 92       	push	r0
    5692:	0f 92       	push	r0
    5694:	cd b7       	in	r28, 0x3d	; 61
    5696:	de b7       	in	r29, 0x3e	; 62
    5698:	9a 83       	std	Y+2, r25	; 0x02
    569a:	89 83       	std	Y+1, r24	; 0x01
 forward();
    569c:	0e 94 03 2a 	call	0x5406	; 0x5406 <forward>
 linear_distance_mm(DistanceInMM);
    56a0:	89 81       	ldd	r24, Y+1	; 0x01
    56a2:	9a 81       	ldd	r25, Y+2	; 0x02
    56a4:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <linear_distance_mm>
}
    56a8:	0f 90       	pop	r0
    56aa:	0f 90       	pop	r0
    56ac:	cf 91       	pop	r28
    56ae:	df 91       	pop	r29
    56b0:	08 95       	ret

000056b2 <back_mm>:
* Logic: 			Called if user wants to move robot backward by specific distance
* Example Call:		back_mm(30);
*
*/
void back_mm(unsigned int DistanceInMM)
{
    56b2:	df 93       	push	r29
    56b4:	cf 93       	push	r28
    56b6:	0f 92       	push	r0
    56b8:	0f 92       	push	r0
    56ba:	cd b7       	in	r28, 0x3d	; 61
    56bc:	de b7       	in	r29, 0x3e	; 62
    56be:	9a 83       	std	Y+2, r25	; 0x02
    56c0:	89 83       	std	Y+1, r24	; 0x01
 back();
    56c2:	0e 94 17 2a 	call	0x542e	; 0x542e <back>
 linear_distance_mm(DistanceInMM);
    56c6:	89 81       	ldd	r24, Y+1	; 0x01
    56c8:	9a 81       	ldd	r25, Y+2	; 0x02
    56ca:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <linear_distance_mm>
}
    56ce:	0f 90       	pop	r0
    56d0:	0f 90       	pop	r0
    56d2:	cf 91       	pop	r28
    56d4:	df 91       	pop	r29
    56d6:	08 95       	ret

000056d8 <left_degrees>:

void left_degrees(unsigned int Degrees)  //used to turn the robot left by specified degrees
{
    56d8:	df 93       	push	r29
    56da:	cf 93       	push	r28
    56dc:	0f 92       	push	r0
    56de:	0f 92       	push	r0
    56e0:	cd b7       	in	r28, 0x3d	; 61
    56e2:	de b7       	in	r29, 0x3e	; 62
    56e4:	9a 83       	std	Y+2, r25	; 0x02
    56e6:	89 83       	std	Y+1, r24	; 0x01
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 left(); //Turn left
    56e8:	0e 94 21 2a 	call	0x5442	; 0x5442 <left>
 angle_rotate(Degrees);
    56ec:	89 81       	ldd	r24, Y+1	; 0x01
    56ee:	9a 81       	ldd	r25, Y+2	; 0x02
    56f0:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <angle_rotate>
}
    56f4:	0f 90       	pop	r0
    56f6:	0f 90       	pop	r0
    56f8:	cf 91       	pop	r28
    56fa:	df 91       	pop	r29
    56fc:	08 95       	ret

000056fe <right_degrees>:


void right_degrees(unsigned int Degrees)	//used to turn the robot right by specified degrees
{
    56fe:	df 93       	push	r29
    5700:	cf 93       	push	r28
    5702:	0f 92       	push	r0
    5704:	0f 92       	push	r0
    5706:	cd b7       	in	r28, 0x3d	; 61
    5708:	de b7       	in	r29, 0x3e	; 62
    570a:	9a 83       	std	Y+2, r25	; 0x02
    570c:	89 83       	std	Y+1, r24	; 0x01
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 right(); //Turn right
    570e:	0e 94 2b 2a 	call	0x5456	; 0x5456 <right>
 angle_rotate(Degrees);
    5712:	89 81       	ldd	r24, Y+1	; 0x01
    5714:	9a 81       	ldd	r25, Y+2	; 0x02
    5716:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <angle_rotate>
}
    571a:	0f 90       	pop	r0
    571c:	0f 90       	pop	r0
    571e:	cf 91       	pop	r28
    5720:	df 91       	pop	r29
    5722:	08 95       	ret

00005724 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)	//used to turn the robot soft_left by specified degrees
{
    5724:	df 93       	push	r29
    5726:	cf 93       	push	r28
    5728:	0f 92       	push	r0
    572a:	0f 92       	push	r0
    572c:	cd b7       	in	r28, 0x3d	; 61
    572e:	de b7       	in	r29, 0x3e	; 62
    5730:	9a 83       	std	Y+2, r25	; 0x02
    5732:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left(); //Turn soft left
    5734:	0e 94 35 2a 	call	0x546a	; 0x546a <soft_left>
 Degrees=Degrees*2;
    5738:	89 81       	ldd	r24, Y+1	; 0x01
    573a:	9a 81       	ldd	r25, Y+2	; 0x02
    573c:	88 0f       	add	r24, r24
    573e:	99 1f       	adc	r25, r25
    5740:	9a 83       	std	Y+2, r25	; 0x02
    5742:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    5744:	89 81       	ldd	r24, Y+1	; 0x01
    5746:	9a 81       	ldd	r25, Y+2	; 0x02
    5748:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <angle_rotate>
}
    574c:	0f 90       	pop	r0
    574e:	0f 90       	pop	r0
    5750:	cf 91       	pop	r28
    5752:	df 91       	pop	r29
    5754:	08 95       	ret

00005756 <soft_right_degrees>:


void soft_right_degrees(unsigned int Degrees)	//used to turn the robot soft_right by specified degrees
{
    5756:	df 93       	push	r29
    5758:	cf 93       	push	r28
    575a:	0f 92       	push	r0
    575c:	0f 92       	push	r0
    575e:	cd b7       	in	r28, 0x3d	; 61
    5760:	de b7       	in	r29, 0x3e	; 62
    5762:	9a 83       	std	Y+2, r25	; 0x02
    5764:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right();  //Turn soft right
    5766:	0e 94 3f 2a 	call	0x547e	; 0x547e <soft_right>
 Degrees=Degrees*2;
    576a:	89 81       	ldd	r24, Y+1	; 0x01
    576c:	9a 81       	ldd	r25, Y+2	; 0x02
    576e:	88 0f       	add	r24, r24
    5770:	99 1f       	adc	r25, r25
    5772:	9a 83       	std	Y+2, r25	; 0x02
    5774:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    5776:	89 81       	ldd	r24, Y+1	; 0x01
    5778:	9a 81       	ldd	r25, Y+2	; 0x02
    577a:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <angle_rotate>
}
    577e:	0f 90       	pop	r0
    5780:	0f 90       	pop	r0
    5782:	cf 91       	pop	r28
    5784:	df 91       	pop	r29
    5786:	08 95       	ret

00005788 <soft_left_2_degrees>:


void soft_left_2_degrees(unsigned int Degrees)   //used to perform soft_left_2 motion by specified degrees
{
    5788:	df 93       	push	r29
    578a:	cf 93       	push	r28
    578c:	0f 92       	push	r0
    578e:	0f 92       	push	r0
    5790:	cd b7       	in	r28, 0x3d	; 61
    5792:	de b7       	in	r29, 0x3e	; 62
    5794:	9a 83       	std	Y+2, r25	; 0x02
    5796:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left_2(); //Turn reverse soft left
    5798:	0e 94 49 2a 	call	0x5492	; 0x5492 <soft_left_2>
 Degrees=Degrees*2;
    579c:	89 81       	ldd	r24, Y+1	; 0x01
    579e:	9a 81       	ldd	r25, Y+2	; 0x02
    57a0:	88 0f       	add	r24, r24
    57a2:	99 1f       	adc	r25, r25
    57a4:	9a 83       	std	Y+2, r25	; 0x02
    57a6:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    57a8:	89 81       	ldd	r24, Y+1	; 0x01
    57aa:	9a 81       	ldd	r25, Y+2	; 0x02
    57ac:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <angle_rotate>
}
    57b0:	0f 90       	pop	r0
    57b2:	0f 90       	pop	r0
    57b4:	cf 91       	pop	r28
    57b6:	df 91       	pop	r29
    57b8:	08 95       	ret

000057ba <soft_right_2_degrees>:


void soft_right_2_degrees(unsigned int Degrees)    //used to perform soft_left_2 motion by specified degrees
{
    57ba:	df 93       	push	r29
    57bc:	cf 93       	push	r28
    57be:	0f 92       	push	r0
    57c0:	0f 92       	push	r0
    57c2:	cd b7       	in	r28, 0x3d	; 61
    57c4:	de b7       	in	r29, 0x3e	; 62
    57c6:	9a 83       	std	Y+2, r25	; 0x02
    57c8:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right_2();  //Turn reverse soft right
    57ca:	0e 94 53 2a 	call	0x54a6	; 0x54a6 <soft_right_2>
 Degrees=Degrees*2;
    57ce:	89 81       	ldd	r24, Y+1	; 0x01
    57d0:	9a 81       	ldd	r25, Y+2	; 0x02
    57d2:	88 0f       	add	r24, r24
    57d4:	99 1f       	adc	r25, r25
    57d6:	9a 83       	std	Y+2, r25	; 0x02
    57d8:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    57da:	89 81       	ldd	r24, Y+1	; 0x01
    57dc:	9a 81       	ldd	r25, Y+2	; 0x02
    57de:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <angle_rotate>
}
    57e2:	0f 90       	pop	r0
    57e4:	0f 90       	pop	r0
    57e6:	cf 91       	pop	r28
    57e8:	df 91       	pop	r29
    57ea:	08 95       	ret

000057ec <init_devices>:
* Logic: 			Called in main() to initialise all the devices connected to the robot
* Example Call:		init_devices();
*
*/
void init_devices (void)
{
    57ec:	df 93       	push	r29
    57ee:	cf 93       	push	r28
    57f0:	cd b7       	in	r28, 0x3d	; 61
    57f2:	de b7       	in	r29, 0x3e	; 62
 	cli(); //Clears the global interrupts
    57f4:	f8 94       	cli
	port_init();
    57f6:	0e 94 33 26 	call	0x4c66	; 0x4c66 <port_init>
	uart2_init();
    57fa:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <uart2_init>
	adc_init();
    57fe:	0e 94 7f 28 	call	0x50fe	; 0x50fe <adc_init>
	timer5_init();
    5802:	0e 94 50 28 	call	0x50a0	; 0x50a0 <timer5_init>
	left_position_encoder_interrupt_init();
    5806:	0e 94 2f 29 	call	0x525e	; 0x525e <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
    580a:	0e 94 46 29 	call	0x528c	; 0x528c <right_position_encoder_interrupt_init>
	boot_key_interrupt_init();
    580e:	0e 94 5d 29 	call	0x52ba	; 0x52ba <boot_key_interrupt_init>
	GLCD_Init();
    5812:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <GLCD_Init>
	lcd_set_4bit();
    5816:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <lcd_set_4bit>
	lcd_init();
    581a:	0e 94 53 21 	call	0x42a6	; 0x42a6 <lcd_init>
	sei();   //Enables the global interrupts
    581e:	78 94       	sei
}
    5820:	cf 91       	pop	r28
    5822:	df 91       	pop	r29
    5824:	08 95       	ret

00005826 <black_line_follower>:
* Logic: 			detects the black line using the three white line sensors 
* Example Call:		black_line_follower();
*
*/
void black_line_follower()
{
    5826:	df 93       	push	r29
    5828:	cf 93       	push	r28
    582a:	cd b7       	in	r28, 0x3d	; 61
    582c:	de b7       	in	r29, 0x3e	; 62
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    582e:	83 e0       	ldi	r24, 0x03	; 3
    5830:	0e 94 98 28 	call	0x5130	; 0x5130 <ADC_Conversion>
    5834:	80 93 cb 03 	sts	0x03CB, r24
    Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    5838:	82 e0       	ldi	r24, 0x02	; 2
    583a:	0e 94 98 28 	call	0x5130	; 0x5130 <ADC_Conversion>
    583e:	80 93 cc 03 	sts	0x03CC, r24
    Right_white_line = ADC_Conversion(1);
    5842:	81 e0       	ldi	r24, 0x01	; 1
    5844:	0e 94 98 28 	call	0x5130	; 0x5130 <ADC_Conversion>
    5848:	80 93 cd 03 	sts	0x03CD, r24

	print_sensor(1,1,3);	//Prints value of White Line Sensor1
    584c:	81 e0       	ldi	r24, 0x01	; 1
    584e:	61 e0       	ldi	r22, 0x01	; 1
    5850:	43 e0       	ldi	r20, 0x03	; 3
    5852:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <print_sensor>
	print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    5856:	81 e0       	ldi	r24, 0x01	; 1
    5858:	65 e0       	ldi	r22, 0x05	; 5
    585a:	42 e0       	ldi	r20, 0x02	; 2
    585c:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <print_sensor>
	print_sensor(1,9,1);
    5860:	81 e0       	ldi	r24, 0x01	; 1
    5862:	69 e0       	ldi	r22, 0x09	; 9
    5864:	41 e0       	ldi	r20, 0x01	; 1
    5866:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <print_sensor>
	
	if(Center_white_line >=15)		// if centre sensor is on the black line then move forward
    586a:	80 91 cc 03 	lds	r24, 0x03CC
    586e:	8f 30       	cpi	r24, 0x0F	; 15
    5870:	30 f0       	brcs	.+12     	; 0x587e <black_line_follower+0x58>
	{
		forward();
    5872:	0e 94 03 2a 	call	0x5406	; 0x5406 <forward>
		velocity(115,125);
    5876:	83 e7       	ldi	r24, 0x73	; 115
    5878:	6d e7       	ldi	r22, 0x7D	; 125
    587a:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
	}
	if(Left_white_line >=15 && Center_white_line<15)  //if left sensor is on the black line then move forward with velocity(70,100)
    587e:	80 91 cb 03 	lds	r24, 0x03CB
    5882:	8f 30       	cpi	r24, 0x0F	; 15
    5884:	50 f0       	brcs	.+20     	; 0x589a <black_line_follower+0x74>
    5886:	80 91 cc 03 	lds	r24, 0x03CC
    588a:	8f 30       	cpi	r24, 0x0F	; 15
    588c:	30 f4       	brcc	.+12     	; 0x589a <black_line_follower+0x74>
	{
		//forward();
		//velocity(85,125);
		velocity(80,90);
    588e:	80 e5       	ldi	r24, 0x50	; 80
    5890:	6a e5       	ldi	r22, 0x5A	; 90
    5892:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
		left();
    5896:	0e 94 21 2a 	call	0x5442	; 0x5442 <left>
	}
	if(Right_white_line >=15 && Center_white_line<15)   //if right sensor is on the black line then move forward with velocity(100,70)
    589a:	80 91 cd 03 	lds	r24, 0x03CD
    589e:	8f 30       	cpi	r24, 0x0F	; 15
    58a0:	50 f0       	brcs	.+20     	; 0x58b6 <black_line_follower+0x90>
    58a2:	80 91 cc 03 	lds	r24, 0x03CC
    58a6:	8f 30       	cpi	r24, 0x0F	; 15
    58a8:	30 f4       	brcc	.+12     	; 0x58b6 <black_line_follower+0x90>
	{
		//forward();
		//velocity(125,85);
		velocity(80,90);
    58aa:	80 e5       	ldi	r24, 0x50	; 80
    58ac:	6a e5       	ldi	r22, 0x5A	; 90
    58ae:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
		right();
    58b2:	0e 94 2b 2a 	call	0x5456	; 0x5456 <right>
	}
	
	if (Center_white_line<15&& Right_white_line<15 && Left_white_line<15)
    58b6:	80 91 cc 03 	lds	r24, 0x03CC
    58ba:	8f 30       	cpi	r24, 0x0F	; 15
    58bc:	70 f4       	brcc	.+28     	; 0x58da <black_line_follower+0xb4>
    58be:	80 91 cd 03 	lds	r24, 0x03CD
    58c2:	8f 30       	cpi	r24, 0x0F	; 15
    58c4:	50 f4       	brcc	.+20     	; 0x58da <black_line_follower+0xb4>
    58c6:	80 91 cb 03 	lds	r24, 0x03CB
    58ca:	8f 30       	cpi	r24, 0x0F	; 15
    58cc:	30 f4       	brcc	.+12     	; 0x58da <black_line_follower+0xb4>
	{
		forward();
    58ce:	0e 94 03 2a 	call	0x5406	; 0x5406 <forward>
		velocity(115,125);
    58d2:	83 e7       	ldi	r24, 0x73	; 115
    58d4:	6d e7       	ldi	r22, 0x7D	; 125
    58d6:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
	}
}
    58da:	cf 91       	pop	r28
    58dc:	df 91       	pop	r29
    58de:	08 95       	ret

000058e0 <position_correcter>:
* Logic: 			Used to correct the motion of robot if it gets disturbed due to some reasons
* Example Call:		position_position_correcter(1);
*
*/
void position_correcter(int correct)
{
    58e0:	df 93       	push	r29
    58e2:	cf 93       	push	r28
    58e4:	00 d0       	rcall	.+0      	; 0x58e6 <position_correcter+0x6>
    58e6:	0f 92       	push	r0
    58e8:	cd b7       	in	r28, 0x3d	; 61
    58ea:	de b7       	in	r29, 0x3e	; 62
    58ec:	9c 83       	std	Y+4, r25	; 0x04
    58ee:	8b 83       	std	Y+3, r24	; 0x03
	int node=1;
    58f0:	81 e0       	ldi	r24, 0x01	; 1
    58f2:	90 e0       	ldi	r25, 0x00	; 0
    58f4:	9a 83       	std	Y+2, r25	; 0x02
    58f6:	89 83       	std	Y+1, r24	; 0x01
    58f8:	27 c0       	rjmp	.+78     	; 0x5948 <position_correcter+0x68>
	while(correct==1)
	{
		black_line_follower();
    58fa:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
		if(Center_white_line >30 && (Left_white_line >30 && Right_white_line >30))
    58fe:	80 91 cc 03 	lds	r24, 0x03CC
    5902:	8f 31       	cpi	r24, 0x1F	; 31
    5904:	a0 f0       	brcs	.+40     	; 0x592e <position_correcter+0x4e>
    5906:	80 91 cb 03 	lds	r24, 0x03CB
    590a:	8f 31       	cpi	r24, 0x1F	; 31
    590c:	80 f0       	brcs	.+32     	; 0x592e <position_correcter+0x4e>
    590e:	80 91 cd 03 	lds	r24, 0x03CD
    5912:	8f 31       	cpi	r24, 0x1F	; 31
    5914:	60 f0       	brcs	.+24     	; 0x592e <position_correcter+0x4e>
		{
			while(1)
			{
				black_line_follower();
    5916:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Left_white_line <30 || Right_white_line < 30)
    591a:	80 91 cb 03 	lds	r24, 0x03CB
    591e:	8e 31       	cpi	r24, 0x1E	; 30
    5920:	20 f0       	brcs	.+8      	; 0x592a <position_correcter+0x4a>
    5922:	80 91 cd 03 	lds	r24, 0x03CD
    5926:	8e 31       	cpi	r24, 0x1E	; 30
    5928:	b0 f7       	brcc	.-20     	; 0x5916 <position_correcter+0x36>
				{
					node=0;
    592a:	1a 82       	std	Y+2, r1	; 0x02
    592c:	19 82       	std	Y+1, r1	; 0x01
					break;
				}
			}
		}
		if(node==0)
    592e:	89 81       	ldd	r24, Y+1	; 0x01
    5930:	9a 81       	ldd	r25, Y+2	; 0x02
    5932:	00 97       	sbiw	r24, 0x00	; 0
    5934:	49 f4       	brne	.+18     	; 0x5948 <position_correcter+0x68>
		{
			velocity(115,125);
    5936:	83 e7       	ldi	r24, 0x73	; 115
    5938:	6d e7       	ldi	r22, 0x7D	; 125
    593a:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
			forward_mm(45);
    593e:	8d e2       	ldi	r24, 0x2D	; 45
    5940:	90 e0       	ldi	r25, 0x00	; 0
    5942:	0e 94 46 2b 	call	0x568c	; 0x568c <forward_mm>
    5946:	3a c0       	rjmp	.+116    	; 0x59bc <position_correcter+0xdc>
*
*/
void position_correcter(int correct)
{
	int node=1;
	while(correct==1)
    5948:	8b 81       	ldd	r24, Y+3	; 0x03
    594a:	9c 81       	ldd	r25, Y+4	; 0x04
    594c:	81 30       	cpi	r24, 0x01	; 1
    594e:	91 05       	cpc	r25, r1
    5950:	a1 f2       	breq	.-88     	; 0x58fa <position_correcter+0x1a>
			velocity(115,125);
			forward_mm(45);
			return;
		}
	}
	if(correct==0)
    5952:	8b 81       	ldd	r24, Y+3	; 0x03
    5954:	9c 81       	ldd	r25, Y+4	; 0x04
    5956:	00 97       	sbiw	r24, 0x00	; 0
    5958:	89 f5       	brne	.+98     	; 0x59bc <position_correcter+0xdc>
	{
		left_degrees(180);
    595a:	84 eb       	ldi	r24, 0xB4	; 180
    595c:	90 e0       	ldi	r25, 0x00	; 0
    595e:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
		back_mm(50);
    5962:	82 e3       	ldi	r24, 0x32	; 50
    5964:	90 e0       	ldi	r25, 0x00	; 0
    5966:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <back_mm>
		while(1)
		{
			black_line_follower();
    596a:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
			if(Center_white_line >30 && (Left_white_line >30 || Right_white_line >30))
    596e:	80 91 cc 03 	lds	r24, 0x03CC
    5972:	8f 31       	cpi	r24, 0x1F	; 31
    5974:	b8 f0       	brcs	.+46     	; 0x59a4 <position_correcter+0xc4>
    5976:	80 91 cb 03 	lds	r24, 0x03CB
    597a:	8f 31       	cpi	r24, 0x1F	; 31
    597c:	20 f4       	brcc	.+8      	; 0x5986 <position_correcter+0xa6>
    597e:	80 91 cd 03 	lds	r24, 0x03CD
    5982:	8f 31       	cpi	r24, 0x1F	; 31
    5984:	78 f0       	brcs	.+30     	; 0x59a4 <position_correcter+0xc4>
			{
				while(1)
				{
					black_line_follower();
    5986:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
					if(Left_white_line < 30 || Right_white_line <30)
    598a:	80 91 cb 03 	lds	r24, 0x03CB
    598e:	8e 31       	cpi	r24, 0x1E	; 30
    5990:	20 f0       	brcs	.+8      	; 0x599a <position_correcter+0xba>
    5992:	80 91 cd 03 	lds	r24, 0x03CD
    5996:	8e 31       	cpi	r24, 0x1E	; 30
    5998:	b0 f7       	brcc	.-20     	; 0x5986 <position_correcter+0xa6>
					{
						node--;
    599a:	89 81       	ldd	r24, Y+1	; 0x01
    599c:	9a 81       	ldd	r25, Y+2	; 0x02
    599e:	01 97       	sbiw	r24, 0x01	; 1
    59a0:	9a 83       	std	Y+2, r25	; 0x02
    59a2:	89 83       	std	Y+1, r24	; 0x01
						break;
					}
				}
			}
			if(node==0)
    59a4:	89 81       	ldd	r24, Y+1	; 0x01
    59a6:	9a 81       	ldd	r25, Y+2	; 0x02
    59a8:	00 97       	sbiw	r24, 0x00	; 0
    59aa:	f9 f6       	brne	.-66     	; 0x596a <position_correcter+0x8a>
			{
				velocity(115,125);
    59ac:	83 e7       	ldi	r24, 0x73	; 115
    59ae:	6d e7       	ldi	r22, 0x7D	; 125
    59b0:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
				forward_mm(45);
    59b4:	8d e2       	ldi	r24, 0x2D	; 45
    59b6:	90 e0       	ldi	r25, 0x00	; 0
    59b8:	0e 94 46 2b 	call	0x568c	; 0x568c <forward_mm>
				return;
			}
		}
	}
}
    59bc:	0f 90       	pop	r0
    59be:	0f 90       	pop	r0
    59c0:	0f 90       	pop	r0
    59c2:	0f 90       	pop	r0
    59c4:	cf 91       	pop	r28
    59c6:	df 91       	pop	r29
    59c8:	08 95       	ret

000059ca <move_y_first>:

* Example Call:		move_y_first(2,-1,3,4);
*
*/
void move_y_first(int x1,int y1,int x2,int y2)
{
    59ca:	df 93       	push	r29
    59cc:	cf 93       	push	r28
    59ce:	cd b7       	in	r28, 0x3d	; 61
    59d0:	de b7       	in	r29, 0x3e	; 62
    59d2:	c4 54       	subi	r28, 0x44	; 68
    59d4:	d0 40       	sbci	r29, 0x00	; 0
    59d6:	0f b6       	in	r0, 0x3f	; 63
    59d8:	f8 94       	cli
    59da:	de bf       	out	0x3e, r29	; 62
    59dc:	0f be       	out	0x3f, r0	; 63
    59de:	cd bf       	out	0x3d, r28	; 61
    59e0:	9e af       	std	Y+62, r25	; 0x3e
    59e2:	8d af       	std	Y+61, r24	; 0x3d
    59e4:	fe 01       	movw	r30, r28
    59e6:	ff 96       	adiw	r30, 0x3f	; 63
    59e8:	71 83       	std	Z+1, r23	; 0x01
    59ea:	60 83       	st	Z, r22
    59ec:	fe 01       	movw	r30, r28
    59ee:	ef 5b       	subi	r30, 0xBF	; 191
    59f0:	ff 4f       	sbci	r31, 0xFF	; 255
    59f2:	51 83       	std	Z+1, r21	; 0x01
    59f4:	40 83       	st	Z, r20
    59f6:	fe 01       	movw	r30, r28
    59f8:	ed 5b       	subi	r30, 0xBD	; 189
    59fa:	ff 4f       	sbci	r31, 0xFF	; 255
    59fc:	31 83       	std	Z+1, r19	; 0x01
    59fe:	20 83       	st	Z, r18
    
	int move_in_x_dir= x2-x1;  //stores the number of nodes robot has to traverse in x-direction
    5a00:	fe 01       	movw	r30, r28
    5a02:	ef 5b       	subi	r30, 0xBF	; 191
    5a04:	ff 4f       	sbci	r31, 0xFF	; 255
    5a06:	20 81       	ld	r18, Z
    5a08:	31 81       	ldd	r19, Z+1	; 0x01
    5a0a:	8d ad       	ldd	r24, Y+61	; 0x3d
    5a0c:	9e ad       	ldd	r25, Y+62	; 0x3e
    5a0e:	a9 01       	movw	r20, r18
    5a10:	48 1b       	sub	r20, r24
    5a12:	59 0b       	sbc	r21, r25
    5a14:	ca 01       	movw	r24, r20
    5a16:	9c af       	std	Y+60, r25	; 0x3c
    5a18:	8b af       	std	Y+59, r24	; 0x3b
	int move_in_y_dir= y2-y1;  //stores the number of nodes robot has to traverse in y-direction
    5a1a:	fe 01       	movw	r30, r28
    5a1c:	ed 5b       	subi	r30, 0xBD	; 189
    5a1e:	ff 4f       	sbci	r31, 0xFF	; 255
    5a20:	20 81       	ld	r18, Z
    5a22:	31 81       	ldd	r19, Z+1	; 0x01
    5a24:	fe 01       	movw	r30, r28
    5a26:	ff 96       	adiw	r30, 0x3f	; 63
    5a28:	80 81       	ld	r24, Z
    5a2a:	91 81       	ldd	r25, Z+1	; 0x01
    5a2c:	a9 01       	movw	r20, r18
    5a2e:	48 1b       	sub	r20, r24
    5a30:	59 0b       	sbc	r21, r25
    5a32:	ca 01       	movw	r24, r20
    5a34:	9a af       	std	Y+58, r25	; 0x3a
    5a36:	89 af       	std	Y+57, r24	; 0x39
	
	if(move_in_y_dir!=0)		
    5a38:	89 ad       	ldd	r24, Y+57	; 0x39
    5a3a:	9a ad       	ldd	r25, Y+58	; 0x3a
    5a3c:	00 97       	sbiw	r24, 0x00	; 0
    5a3e:	09 f4       	brne	.+2      	; 0x5a42 <move_y_first+0x78>
    5a40:	22 c1       	rjmp	.+580    	; 0x5c86 <move_y_first+0x2bc>
    5a42:	80 e0       	ldi	r24, 0x00	; 0
    5a44:	90 e0       	ldi	r25, 0x00	; 0
    5a46:	a0 e2       	ldi	r26, 0x20	; 32
    5a48:	b2 e4       	ldi	r27, 0x42	; 66
    5a4a:	8d ab       	std	Y+53, r24	; 0x35
    5a4c:	9e ab       	std	Y+54, r25	; 0x36
    5a4e:	af ab       	std	Y+55, r26	; 0x37
    5a50:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5a52:	6d a9       	ldd	r22, Y+53	; 0x35
    5a54:	7e a9       	ldd	r23, Y+54	; 0x36
    5a56:	8f a9       	ldd	r24, Y+55	; 0x37
    5a58:	98 ad       	ldd	r25, Y+56	; 0x38
    5a5a:	26 e6       	ldi	r18, 0x66	; 102
    5a5c:	36 e6       	ldi	r19, 0x66	; 102
    5a5e:	46 e6       	ldi	r20, 0x66	; 102
    5a60:	55 e4       	ldi	r21, 0x45	; 69
    5a62:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    5a66:	dc 01       	movw	r26, r24
    5a68:	cb 01       	movw	r24, r22
    5a6a:	89 ab       	std	Y+49, r24	; 0x31
    5a6c:	9a ab       	std	Y+50, r25	; 0x32
    5a6e:	ab ab       	std	Y+51, r26	; 0x33
    5a70:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    5a72:	69 a9       	ldd	r22, Y+49	; 0x31
    5a74:	7a a9       	ldd	r23, Y+50	; 0x32
    5a76:	8b a9       	ldd	r24, Y+51	; 0x33
    5a78:	9c a9       	ldd	r25, Y+52	; 0x34
    5a7a:	20 e0       	ldi	r18, 0x00	; 0
    5a7c:	30 e0       	ldi	r19, 0x00	; 0
    5a7e:	40 e8       	ldi	r20, 0x80	; 128
    5a80:	5f e3       	ldi	r21, 0x3F	; 63
    5a82:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    5a86:	88 23       	and	r24, r24
    5a88:	2c f4       	brge	.+10     	; 0x5a94 <move_y_first+0xca>
		__ticks = 1;
    5a8a:	81 e0       	ldi	r24, 0x01	; 1
    5a8c:	90 e0       	ldi	r25, 0x00	; 0
    5a8e:	98 ab       	std	Y+48, r25	; 0x30
    5a90:	8f a7       	std	Y+47, r24	; 0x2f
    5a92:	3f c0       	rjmp	.+126    	; 0x5b12 <move_y_first+0x148>
	else if (__tmp > 65535)
    5a94:	69 a9       	ldd	r22, Y+49	; 0x31
    5a96:	7a a9       	ldd	r23, Y+50	; 0x32
    5a98:	8b a9       	ldd	r24, Y+51	; 0x33
    5a9a:	9c a9       	ldd	r25, Y+52	; 0x34
    5a9c:	20 e0       	ldi	r18, 0x00	; 0
    5a9e:	3f ef       	ldi	r19, 0xFF	; 255
    5aa0:	4f e7       	ldi	r20, 0x7F	; 127
    5aa2:	57 e4       	ldi	r21, 0x47	; 71
    5aa4:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    5aa8:	18 16       	cp	r1, r24
    5aaa:	4c f5       	brge	.+82     	; 0x5afe <move_y_first+0x134>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5aac:	6d a9       	ldd	r22, Y+53	; 0x35
    5aae:	7e a9       	ldd	r23, Y+54	; 0x36
    5ab0:	8f a9       	ldd	r24, Y+55	; 0x37
    5ab2:	98 ad       	ldd	r25, Y+56	; 0x38
    5ab4:	20 e0       	ldi	r18, 0x00	; 0
    5ab6:	30 e0       	ldi	r19, 0x00	; 0
    5ab8:	40 e2       	ldi	r20, 0x20	; 32
    5aba:	51 e4       	ldi	r21, 0x41	; 65
    5abc:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    5ac0:	dc 01       	movw	r26, r24
    5ac2:	cb 01       	movw	r24, r22
    5ac4:	bc 01       	movw	r22, r24
    5ac6:	cd 01       	movw	r24, r26
    5ac8:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5acc:	dc 01       	movw	r26, r24
    5ace:	cb 01       	movw	r24, r22
    5ad0:	98 ab       	std	Y+48, r25	; 0x30
    5ad2:	8f a7       	std	Y+47, r24	; 0x2f
    5ad4:	0f c0       	rjmp	.+30     	; 0x5af4 <move_y_first+0x12a>
    5ad6:	80 e7       	ldi	r24, 0x70	; 112
    5ad8:	91 e0       	ldi	r25, 0x01	; 1
    5ada:	9e a7       	std	Y+46, r25	; 0x2e
    5adc:	8d a7       	std	Y+45, r24	; 0x2d
    5ade:	8d a5       	ldd	r24, Y+45	; 0x2d
    5ae0:	9e a5       	ldd	r25, Y+46	; 0x2e
    5ae2:	01 97       	sbiw	r24, 0x01	; 1
    5ae4:	f1 f7       	brne	.-4      	; 0x5ae2 <move_y_first+0x118>
    5ae6:	9e a7       	std	Y+46, r25	; 0x2e
    5ae8:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5aea:	8f a5       	ldd	r24, Y+47	; 0x2f
    5aec:	98 a9       	ldd	r25, Y+48	; 0x30
    5aee:	01 97       	sbiw	r24, 0x01	; 1
    5af0:	98 ab       	std	Y+48, r25	; 0x30
    5af2:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5af4:	8f a5       	ldd	r24, Y+47	; 0x2f
    5af6:	98 a9       	ldd	r25, Y+48	; 0x30
    5af8:	00 97       	sbiw	r24, 0x00	; 0
    5afa:	69 f7       	brne	.-38     	; 0x5ad6 <move_y_first+0x10c>
    5afc:	14 c0       	rjmp	.+40     	; 0x5b26 <move_y_first+0x15c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5afe:	69 a9       	ldd	r22, Y+49	; 0x31
    5b00:	7a a9       	ldd	r23, Y+50	; 0x32
    5b02:	8b a9       	ldd	r24, Y+51	; 0x33
    5b04:	9c a9       	ldd	r25, Y+52	; 0x34
    5b06:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5b0a:	dc 01       	movw	r26, r24
    5b0c:	cb 01       	movw	r24, r22
    5b0e:	98 ab       	std	Y+48, r25	; 0x30
    5b10:	8f a7       	std	Y+47, r24	; 0x2f
    5b12:	8f a5       	ldd	r24, Y+47	; 0x2f
    5b14:	98 a9       	ldd	r25, Y+48	; 0x30
    5b16:	9c a7       	std	Y+44, r25	; 0x2c
    5b18:	8b a7       	std	Y+43, r24	; 0x2b
    5b1a:	8b a5       	ldd	r24, Y+43	; 0x2b
    5b1c:	9c a5       	ldd	r25, Y+44	; 0x2c
    5b1e:	01 97       	sbiw	r24, 0x01	; 1
    5b20:	f1 f7       	brne	.-4      	; 0x5b1e <move_y_first+0x154>
    5b22:	9c a7       	std	Y+44, r25	; 0x2c
    5b24:	8b a7       	std	Y+43, r24	; 0x2b
	{
		_delay_ms(40);
		velocity(115,125);   
    5b26:	83 e7       	ldi	r24, 0x73	; 115
    5b28:	6d e7       	ldi	r22, 0x7D	; 125
    5b2a:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
		if(move_in_y_dir > 0)	 // if the value is +ve then move in North direction	
    5b2e:	89 ad       	ldd	r24, Y+57	; 0x39
    5b30:	9a ad       	ldd	r25, Y+58	; 0x3a
    5b32:	18 16       	cp	r1, r24
    5b34:	19 06       	cpc	r1, r25
    5b36:	0c f0       	brlt	.+2      	; 0x5b3a <move_y_first+0x170>
    5b38:	53 c0       	rjmp	.+166    	; 0x5be0 <move_y_first+0x216>
		{
			if(bot_dir==S)  //checks the bot direction
    5b3a:	80 91 00 02 	lds	r24, 0x0200
    5b3e:	83 30       	cpi	r24, 0x03	; 3
    5b40:	39 f4       	brne	.+14     	; 0x5b50 <move_y_first+0x186>
			{
				left_degrees(180);
    5b42:	84 eb       	ldi	r24, 0xB4	; 180
    5b44:	90 e0       	ldi	r25, 0x00	; 0
    5b46:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
				bot_dir=N;   //assigns bot direction to north
    5b4a:	81 e0       	ldi	r24, 0x01	; 1
    5b4c:	80 93 00 02 	sts	0x0200, r24
			}
			if(bot_dir==E)
    5b50:	80 91 00 02 	lds	r24, 0x0200
    5b54:	84 30       	cpi	r24, 0x04	; 4
    5b56:	59 f4       	brne	.+22     	; 0x5b6e <move_y_first+0x1a4>
			{
				position_correcter(1);   //refer to the function definition to know its use. 
    5b58:	81 e0       	ldi	r24, 0x01	; 1
    5b5a:	90 e0       	ldi	r25, 0x00	; 0
    5b5c:	0e 94 70 2c 	call	0x58e0	; 0x58e0 <position_correcter>
				left_degrees(102);
    5b60:	86 e6       	ldi	r24, 0x66	; 102
    5b62:	90 e0       	ldi	r25, 0x00	; 0
    5b64:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
				bot_dir=N;
    5b68:	81 e0       	ldi	r24, 0x01	; 1
    5b6a:	80 93 00 02 	sts	0x0200, r24
			}
			if(bot_dir==W)
    5b6e:	80 91 00 02 	lds	r24, 0x0200
    5b72:	82 30       	cpi	r24, 0x02	; 2
    5b74:	39 f4       	brne	.+14     	; 0x5b84 <move_y_first+0x1ba>
			{
				right_degrees(102);
    5b76:	86 e6       	ldi	r24, 0x66	; 102
    5b78:	90 e0       	ldi	r25, 0x00	; 0
    5b7a:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
				bot_dir=N;
    5b7e:	81 e0       	ldi	r24, 0x01	; 1
    5b80:	80 93 00 02 	sts	0x0200, r24
			}
			
			if(x1==2)                  
    5b84:	8d ad       	ldd	r24, Y+61	; 0x3d
    5b86:	9e ad       	ldd	r25, Y+62	; 0x3e
    5b88:	82 30       	cpi	r24, 0x02	; 2
    5b8a:	91 05       	cpc	r25, r1
    5b8c:	29 f4       	brne	.+10     	; 0x5b98 <move_y_first+0x1ce>
				move_in_y_dir++;	
    5b8e:	89 ad       	ldd	r24, Y+57	; 0x39
    5b90:	9a ad       	ldd	r25, Y+58	; 0x3a
    5b92:	01 96       	adiw	r24, 0x01	; 1
    5b94:	9a af       	std	Y+58, r25	; 0x3a
    5b96:	89 af       	std	Y+57, r24	; 0x39
		
			while(1)  // following while loop counts the node as the robot moves and breaks when required nodes in North direction are traversed.
			{
				black_line_follower();
    5b98:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)   // Node encountered while traversing Arena
    5b9c:	80 91 cc 03 	lds	r24, 0x03CC
    5ba0:	8e 31       	cpi	r24, 0x1E	; 30
    5ba2:	b8 f0       	brcs	.+46     	; 0x5bd2 <move_y_first+0x208>
    5ba4:	80 91 cb 03 	lds	r24, 0x03CB
    5ba8:	8e 31       	cpi	r24, 0x1E	; 30
    5baa:	98 f0       	brcs	.+38     	; 0x5bd2 <move_y_first+0x208>
    5bac:	80 91 cd 03 	lds	r24, 0x03CD
    5bb0:	8e 31       	cpi	r24, 0x1E	; 30
    5bb2:	78 f0       	brcs	.+30     	; 0x5bd2 <move_y_first+0x208>
				{
					while(1)
					{
						black_line_follower();
    5bb4:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
						if(Left_white_line <30 || Right_white_line < 30)   // when robot crosses node then no. of node is decremented by 1
    5bb8:	80 91 cb 03 	lds	r24, 0x03CB
    5bbc:	8e 31       	cpi	r24, 0x1E	; 30
    5bbe:	20 f0       	brcs	.+8      	; 0x5bc8 <move_y_first+0x1fe>
    5bc0:	80 91 cd 03 	lds	r24, 0x03CD
    5bc4:	8e 31       	cpi	r24, 0x1E	; 30
    5bc6:	b0 f7       	brcc	.-20     	; 0x5bb4 <move_y_first+0x1ea>
						{
							move_in_y_dir--;
    5bc8:	89 ad       	ldd	r24, Y+57	; 0x39
    5bca:	9a ad       	ldd	r25, Y+58	; 0x3a
    5bcc:	01 97       	sbiw	r24, 0x01	; 1
    5bce:	9a af       	std	Y+58, r25	; 0x3a
    5bd0:	89 af       	std	Y+57, r24	; 0x39
							break;
						}
						
					}
				}
				if(move_in_y_dir==0)  // when all nodes traversed in north direction then stop
    5bd2:	89 ad       	ldd	r24, Y+57	; 0x39
    5bd4:	9a ad       	ldd	r25, Y+58	; 0x3a
    5bd6:	00 97       	sbiw	r24, 0x00	; 0
    5bd8:	f9 f6       	brne	.-66     	; 0x5b98 <move_y_first+0x1ce>
				{
					stop();
    5bda:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
    5bde:	53 c0       	rjmp	.+166    	; 0x5c86 <move_y_first+0x2bc>
		/* almost same this is happpening in remaining function(only direction is changing) 
		so they are self explanatory once above comments are understood.
		*/
		else
		{
			if(bot_dir==N)
    5be0:	80 91 00 02 	lds	r24, 0x0200
    5be4:	81 30       	cpi	r24, 0x01	; 1
    5be6:	41 f4       	brne	.+16     	; 0x5bf8 <move_y_first+0x22e>
			{
				left_degrees(180);
    5be8:	84 eb       	ldi	r24, 0xB4	; 180
    5bea:	90 e0       	ldi	r25, 0x00	; 0
    5bec:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
				bot_dir=S;
    5bf0:	83 e0       	ldi	r24, 0x03	; 3
    5bf2:	80 93 00 02 	sts	0x0200, r24
    5bf6:	24 c0       	rjmp	.+72     	; 0x5c40 <move_y_first+0x276>
			}
			else if(bot_dir==E)
    5bf8:	80 91 00 02 	lds	r24, 0x0200
    5bfc:	84 30       	cpi	r24, 0x04	; 4
    5bfe:	61 f4       	brne	.+24     	; 0x5c18 <move_y_first+0x24e>
			{
				
				position_correcter(1);	
    5c00:	81 e0       	ldi	r24, 0x01	; 1
    5c02:	90 e0       	ldi	r25, 0x00	; 0
    5c04:	0e 94 70 2c 	call	0x58e0	; 0x58e0 <position_correcter>
				right_degrees(102);
    5c08:	86 e6       	ldi	r24, 0x66	; 102
    5c0a:	90 e0       	ldi	r25, 0x00	; 0
    5c0c:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
				bot_dir=S;
    5c10:	83 e0       	ldi	r24, 0x03	; 3
    5c12:	80 93 00 02 	sts	0x0200, r24
    5c16:	14 c0       	rjmp	.+40     	; 0x5c40 <move_y_first+0x276>
			}
			else if(bot_dir==W)
    5c18:	80 91 00 02 	lds	r24, 0x0200
    5c1c:	82 30       	cpi	r24, 0x02	; 2
    5c1e:	81 f4       	brne	.+32     	; 0x5c40 <move_y_first+0x276>
			{
					
				position_correcter(0);
    5c20:	80 e0       	ldi	r24, 0x00	; 0
    5c22:	90 e0       	ldi	r25, 0x00	; 0
    5c24:	0e 94 70 2c 	call	0x58e0	; 0x58e0 <position_correcter>
				move_in_x_dir--;
    5c28:	8b ad       	ldd	r24, Y+59	; 0x3b
    5c2a:	9c ad       	ldd	r25, Y+60	; 0x3c
    5c2c:	01 97       	sbiw	r24, 0x01	; 1
    5c2e:	9c af       	std	Y+60, r25	; 0x3c
    5c30:	8b af       	std	Y+59, r24	; 0x3b
				right_degrees(102);
    5c32:	86 e6       	ldi	r24, 0x66	; 102
    5c34:	90 e0       	ldi	r25, 0x00	; 0
    5c36:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
				bot_dir=S;
    5c3a:	83 e0       	ldi	r24, 0x03	; 3
    5c3c:	80 93 00 02 	sts	0x0200, r24
			}
			while(1)
			{
				black_line_follower();
    5c40:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >40 && Left_white_line>40 && Right_white_line >40) 
    5c44:	80 91 cc 03 	lds	r24, 0x03CC
    5c48:	89 32       	cpi	r24, 0x29	; 41
    5c4a:	b8 f0       	brcs	.+46     	; 0x5c7a <move_y_first+0x2b0>
    5c4c:	80 91 cb 03 	lds	r24, 0x03CB
    5c50:	89 32       	cpi	r24, 0x29	; 41
    5c52:	98 f0       	brcs	.+38     	; 0x5c7a <move_y_first+0x2b0>
    5c54:	80 91 cd 03 	lds	r24, 0x03CD
    5c58:	89 32       	cpi	r24, 0x29	; 41
    5c5a:	78 f0       	brcs	.+30     	; 0x5c7a <move_y_first+0x2b0>
				{
					while(1)
					{
						black_line_follower();
    5c5c:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
						if(Left_white_line <30 || Right_white_line < 30)
    5c60:	80 91 cb 03 	lds	r24, 0x03CB
    5c64:	8e 31       	cpi	r24, 0x1E	; 30
    5c66:	20 f0       	brcs	.+8      	; 0x5c70 <move_y_first+0x2a6>
    5c68:	80 91 cd 03 	lds	r24, 0x03CD
    5c6c:	8e 31       	cpi	r24, 0x1E	; 30
    5c6e:	b0 f7       	brcc	.-20     	; 0x5c5c <move_y_first+0x292>
						{
							move_in_y_dir++;
    5c70:	89 ad       	ldd	r24, Y+57	; 0x39
    5c72:	9a ad       	ldd	r25, Y+58	; 0x3a
    5c74:	01 96       	adiw	r24, 0x01	; 1
    5c76:	9a af       	std	Y+58, r25	; 0x3a
    5c78:	89 af       	std	Y+57, r24	; 0x39
							
							break;
						}
					}
				}
				if(move_in_y_dir==0)
    5c7a:	89 ad       	ldd	r24, Y+57	; 0x39
    5c7c:	9a ad       	ldd	r25, Y+58	; 0x3a
    5c7e:	00 97       	sbiw	r24, 0x00	; 0
    5c80:	f9 f6       	brne	.-66     	; 0x5c40 <move_y_first+0x276>
				{
					stop();
    5c82:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
					break;
				}
			}
		}
	}
	if(move_in_x_dir!=0)
    5c86:	8b ad       	ldd	r24, Y+59	; 0x3b
    5c88:	9c ad       	ldd	r25, Y+60	; 0x3c
    5c8a:	00 97       	sbiw	r24, 0x00	; 0
    5c8c:	09 f4       	brne	.+2      	; 0x5c90 <move_y_first+0x2c6>
    5c8e:	05 c2       	rjmp	.+1034   	; 0x609a <move_y_first+0x6d0>
    5c90:	80 e0       	ldi	r24, 0x00	; 0
    5c92:	90 e0       	ldi	r25, 0x00	; 0
    5c94:	a0 e2       	ldi	r26, 0x20	; 32
    5c96:	b2 e4       	ldi	r27, 0x42	; 66
    5c98:	8f a3       	std	Y+39, r24	; 0x27
    5c9a:	98 a7       	std	Y+40, r25	; 0x28
    5c9c:	a9 a7       	std	Y+41, r26	; 0x29
    5c9e:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5ca0:	6f a1       	ldd	r22, Y+39	; 0x27
    5ca2:	78 a5       	ldd	r23, Y+40	; 0x28
    5ca4:	89 a5       	ldd	r24, Y+41	; 0x29
    5ca6:	9a a5       	ldd	r25, Y+42	; 0x2a
    5ca8:	26 e6       	ldi	r18, 0x66	; 102
    5caa:	36 e6       	ldi	r19, 0x66	; 102
    5cac:	46 e6       	ldi	r20, 0x66	; 102
    5cae:	55 e4       	ldi	r21, 0x45	; 69
    5cb0:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    5cb4:	dc 01       	movw	r26, r24
    5cb6:	cb 01       	movw	r24, r22
    5cb8:	8b a3       	std	Y+35, r24	; 0x23
    5cba:	9c a3       	std	Y+36, r25	; 0x24
    5cbc:	ad a3       	std	Y+37, r26	; 0x25
    5cbe:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    5cc0:	6b a1       	ldd	r22, Y+35	; 0x23
    5cc2:	7c a1       	ldd	r23, Y+36	; 0x24
    5cc4:	8d a1       	ldd	r24, Y+37	; 0x25
    5cc6:	9e a1       	ldd	r25, Y+38	; 0x26
    5cc8:	20 e0       	ldi	r18, 0x00	; 0
    5cca:	30 e0       	ldi	r19, 0x00	; 0
    5ccc:	40 e8       	ldi	r20, 0x80	; 128
    5cce:	5f e3       	ldi	r21, 0x3F	; 63
    5cd0:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    5cd4:	88 23       	and	r24, r24
    5cd6:	2c f4       	brge	.+10     	; 0x5ce2 <move_y_first+0x318>
		__ticks = 1;
    5cd8:	81 e0       	ldi	r24, 0x01	; 1
    5cda:	90 e0       	ldi	r25, 0x00	; 0
    5cdc:	9a a3       	std	Y+34, r25	; 0x22
    5cde:	89 a3       	std	Y+33, r24	; 0x21
    5ce0:	3f c0       	rjmp	.+126    	; 0x5d60 <move_y_first+0x396>
	else if (__tmp > 65535)
    5ce2:	6b a1       	ldd	r22, Y+35	; 0x23
    5ce4:	7c a1       	ldd	r23, Y+36	; 0x24
    5ce6:	8d a1       	ldd	r24, Y+37	; 0x25
    5ce8:	9e a1       	ldd	r25, Y+38	; 0x26
    5cea:	20 e0       	ldi	r18, 0x00	; 0
    5cec:	3f ef       	ldi	r19, 0xFF	; 255
    5cee:	4f e7       	ldi	r20, 0x7F	; 127
    5cf0:	57 e4       	ldi	r21, 0x47	; 71
    5cf2:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    5cf6:	18 16       	cp	r1, r24
    5cf8:	4c f5       	brge	.+82     	; 0x5d4c <move_y_first+0x382>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5cfa:	6f a1       	ldd	r22, Y+39	; 0x27
    5cfc:	78 a5       	ldd	r23, Y+40	; 0x28
    5cfe:	89 a5       	ldd	r24, Y+41	; 0x29
    5d00:	9a a5       	ldd	r25, Y+42	; 0x2a
    5d02:	20 e0       	ldi	r18, 0x00	; 0
    5d04:	30 e0       	ldi	r19, 0x00	; 0
    5d06:	40 e2       	ldi	r20, 0x20	; 32
    5d08:	51 e4       	ldi	r21, 0x41	; 65
    5d0a:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    5d0e:	dc 01       	movw	r26, r24
    5d10:	cb 01       	movw	r24, r22
    5d12:	bc 01       	movw	r22, r24
    5d14:	cd 01       	movw	r24, r26
    5d16:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5d1a:	dc 01       	movw	r26, r24
    5d1c:	cb 01       	movw	r24, r22
    5d1e:	9a a3       	std	Y+34, r25	; 0x22
    5d20:	89 a3       	std	Y+33, r24	; 0x21
    5d22:	0f c0       	rjmp	.+30     	; 0x5d42 <move_y_first+0x378>
    5d24:	80 e7       	ldi	r24, 0x70	; 112
    5d26:	91 e0       	ldi	r25, 0x01	; 1
    5d28:	98 a3       	std	Y+32, r25	; 0x20
    5d2a:	8f 8f       	std	Y+31, r24	; 0x1f
    5d2c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    5d2e:	98 a1       	ldd	r25, Y+32	; 0x20
    5d30:	01 97       	sbiw	r24, 0x01	; 1
    5d32:	f1 f7       	brne	.-4      	; 0x5d30 <move_y_first+0x366>
    5d34:	98 a3       	std	Y+32, r25	; 0x20
    5d36:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5d38:	89 a1       	ldd	r24, Y+33	; 0x21
    5d3a:	9a a1       	ldd	r25, Y+34	; 0x22
    5d3c:	01 97       	sbiw	r24, 0x01	; 1
    5d3e:	9a a3       	std	Y+34, r25	; 0x22
    5d40:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5d42:	89 a1       	ldd	r24, Y+33	; 0x21
    5d44:	9a a1       	ldd	r25, Y+34	; 0x22
    5d46:	00 97       	sbiw	r24, 0x00	; 0
    5d48:	69 f7       	brne	.-38     	; 0x5d24 <move_y_first+0x35a>
    5d4a:	14 c0       	rjmp	.+40     	; 0x5d74 <move_y_first+0x3aa>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5d4c:	6b a1       	ldd	r22, Y+35	; 0x23
    5d4e:	7c a1       	ldd	r23, Y+36	; 0x24
    5d50:	8d a1       	ldd	r24, Y+37	; 0x25
    5d52:	9e a1       	ldd	r25, Y+38	; 0x26
    5d54:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5d58:	dc 01       	movw	r26, r24
    5d5a:	cb 01       	movw	r24, r22
    5d5c:	9a a3       	std	Y+34, r25	; 0x22
    5d5e:	89 a3       	std	Y+33, r24	; 0x21
    5d60:	89 a1       	ldd	r24, Y+33	; 0x21
    5d62:	9a a1       	ldd	r25, Y+34	; 0x22
    5d64:	9e 8f       	std	Y+30, r25	; 0x1e
    5d66:	8d 8f       	std	Y+29, r24	; 0x1d
    5d68:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5d6a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5d6c:	01 97       	sbiw	r24, 0x01	; 1
    5d6e:	f1 f7       	brne	.-4      	; 0x5d6c <move_y_first+0x3a2>
    5d70:	9e 8f       	std	Y+30, r25	; 0x1e
    5d72:	8d 8f       	std	Y+29, r24	; 0x1d
	{
		_delay_ms(40);
		velocity(115,125);
    5d74:	83 e7       	ldi	r24, 0x73	; 115
    5d76:	6d e7       	ldi	r22, 0x7D	; 125
    5d78:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
		if((y2-y1) != 0)   
    5d7c:	fe 01       	movw	r30, r28
    5d7e:	ed 5b       	subi	r30, 0xBD	; 189
    5d80:	ff 4f       	sbci	r31, 0xFF	; 255
    5d82:	20 81       	ld	r18, Z
    5d84:	31 81       	ldd	r19, Z+1	; 0x01
    5d86:	fe 01       	movw	r30, r28
    5d88:	ff 96       	adiw	r30, 0x3f	; 63
    5d8a:	80 81       	ld	r24, Z
    5d8c:	91 81       	ldd	r25, Z+1	; 0x01
    5d8e:	28 17       	cp	r18, r24
    5d90:	39 07       	cpc	r19, r25
    5d92:	21 f0       	breq	.+8      	; 0x5d9c <move_y_first+0x3d2>
			forward_mm(45);   // if bot traversed in Y direction then executed
    5d94:	8d e2       	ldi	r24, 0x2D	; 45
    5d96:	90 e0       	ldi	r25, 0x00	; 0
    5d98:	0e 94 46 2b 	call	0x568c	; 0x568c <forward_mm>
		
		if(move_in_x_dir < 0)
    5d9c:	8b ad       	ldd	r24, Y+59	; 0x3b
    5d9e:	9c ad       	ldd	r25, Y+60	; 0x3c
    5da0:	99 23       	and	r25, r25
    5da2:	0c f0       	brlt	.+2      	; 0x5da6 <move_y_first+0x3dc>
    5da4:	ba c0       	rjmp	.+372    	; 0x5f1a <move_y_first+0x550>
		{	
			if(bot_dir==N)
    5da6:	80 91 00 02 	lds	r24, 0x0200
    5daa:	81 30       	cpi	r24, 0x01	; 1
    5dac:	29 f4       	brne	.+10     	; 0x5db8 <move_y_first+0x3ee>
			{
				left_degrees(102);
    5dae:	86 e6       	ldi	r24, 0x66	; 102
    5db0:	90 e0       	ldi	r25, 0x00	; 0
    5db2:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
    5db6:	11 c0       	rjmp	.+34     	; 0x5dda <move_y_first+0x410>
			}
			else if(bot_dir==S)
    5db8:	80 91 00 02 	lds	r24, 0x0200
    5dbc:	83 30       	cpi	r24, 0x03	; 3
    5dbe:	29 f4       	brne	.+10     	; 0x5dca <move_y_first+0x400>
			{
				right_degrees(102);
    5dc0:	86 e6       	ldi	r24, 0x66	; 102
    5dc2:	90 e0       	ldi	r25, 0x00	; 0
    5dc4:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
    5dc8:	08 c0       	rjmp	.+16     	; 0x5dda <move_y_first+0x410>
			}
			else if(bot_dir==E)
    5dca:	80 91 00 02 	lds	r24, 0x0200
    5dce:	84 30       	cpi	r24, 0x04	; 4
    5dd0:	21 f4       	brne	.+8      	; 0x5dda <move_y_first+0x410>
			{
				left_degrees(180);
    5dd2:	84 eb       	ldi	r24, 0xB4	; 180
    5dd4:	90 e0       	ldi	r25, 0x00	; 0
    5dd6:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
			}
			
			bot_dir=W;  // W for west
    5dda:	82 e0       	ldi	r24, 0x02	; 2
    5ddc:	80 93 00 02 	sts	0x0200, r24
			
			while(1)  
			{
				black_line_follower();
    5de0:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)  
    5de4:	80 91 cc 03 	lds	r24, 0x03CC
    5de8:	8e 31       	cpi	r24, 0x1E	; 30
    5dea:	b8 f0       	brcs	.+46     	; 0x5e1a <move_y_first+0x450>
    5dec:	80 91 cb 03 	lds	r24, 0x03CB
    5df0:	8e 31       	cpi	r24, 0x1E	; 30
    5df2:	98 f0       	brcs	.+38     	; 0x5e1a <move_y_first+0x450>
    5df4:	80 91 cd 03 	lds	r24, 0x03CD
    5df8:	8e 31       	cpi	r24, 0x1E	; 30
    5dfa:	78 f0       	brcs	.+30     	; 0x5e1a <move_y_first+0x450>
				{
					while(1)
					{
						
						black_line_follower();
    5dfc:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
						if(Left_white_line <30 || Right_white_line < 30)
    5e00:	80 91 cb 03 	lds	r24, 0x03CB
    5e04:	8e 31       	cpi	r24, 0x1E	; 30
    5e06:	20 f0       	brcs	.+8      	; 0x5e10 <move_y_first+0x446>
    5e08:	80 91 cd 03 	lds	r24, 0x03CD
    5e0c:	8e 31       	cpi	r24, 0x1E	; 30
    5e0e:	b0 f7       	brcc	.-20     	; 0x5dfc <move_y_first+0x432>
						{
							move_in_x_dir++;
    5e10:	8b ad       	ldd	r24, Y+59	; 0x3b
    5e12:	9c ad       	ldd	r25, Y+60	; 0x3c
    5e14:	01 96       	adiw	r24, 0x01	; 1
    5e16:	9c af       	std	Y+60, r25	; 0x3c
    5e18:	8b af       	std	Y+59, r24	; 0x3b
							
							break;
						}
					}
				}
				if(move_in_x_dir==0)
    5e1a:	8b ad       	ldd	r24, Y+59	; 0x3b
    5e1c:	9c ad       	ldd	r25, Y+60	; 0x3c
    5e1e:	00 97       	sbiw	r24, 0x00	; 0
    5e20:	f9 f6       	brne	.-66     	; 0x5de0 <move_y_first+0x416>
				{
					velocity(115,125);
    5e22:	83 e7       	ldi	r24, 0x73	; 115
    5e24:	6d e7       	ldi	r22, 0x7D	; 125
    5e26:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
					back_mm(75);
    5e2a:	8b e4       	ldi	r24, 0x4B	; 75
    5e2c:	90 e0       	ldi	r25, 0x00	; 0
    5e2e:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <back_mm>
					stop();
    5e32:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
    5e36:	80 e0       	ldi	r24, 0x00	; 0
    5e38:	90 e0       	ldi	r25, 0x00	; 0
    5e3a:	a0 e8       	ldi	r26, 0x80	; 128
    5e3c:	bf e3       	ldi	r27, 0x3F	; 63
    5e3e:	89 8f       	std	Y+25, r24	; 0x19
    5e40:	9a 8f       	std	Y+26, r25	; 0x1a
    5e42:	ab 8f       	std	Y+27, r26	; 0x1b
    5e44:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5e46:	69 8d       	ldd	r22, Y+25	; 0x19
    5e48:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5e4a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5e4c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5e4e:	26 e6       	ldi	r18, 0x66	; 102
    5e50:	36 e6       	ldi	r19, 0x66	; 102
    5e52:	46 e6       	ldi	r20, 0x66	; 102
    5e54:	55 e4       	ldi	r21, 0x45	; 69
    5e56:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    5e5a:	dc 01       	movw	r26, r24
    5e5c:	cb 01       	movw	r24, r22
    5e5e:	8d 8b       	std	Y+21, r24	; 0x15
    5e60:	9e 8b       	std	Y+22, r25	; 0x16
    5e62:	af 8b       	std	Y+23, r26	; 0x17
    5e64:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5e66:	6d 89       	ldd	r22, Y+21	; 0x15
    5e68:	7e 89       	ldd	r23, Y+22	; 0x16
    5e6a:	8f 89       	ldd	r24, Y+23	; 0x17
    5e6c:	98 8d       	ldd	r25, Y+24	; 0x18
    5e6e:	20 e0       	ldi	r18, 0x00	; 0
    5e70:	30 e0       	ldi	r19, 0x00	; 0
    5e72:	40 e8       	ldi	r20, 0x80	; 128
    5e74:	5f e3       	ldi	r21, 0x3F	; 63
    5e76:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    5e7a:	88 23       	and	r24, r24
    5e7c:	2c f4       	brge	.+10     	; 0x5e88 <move_y_first+0x4be>
		__ticks = 1;
    5e7e:	81 e0       	ldi	r24, 0x01	; 1
    5e80:	90 e0       	ldi	r25, 0x00	; 0
    5e82:	9c 8b       	std	Y+20, r25	; 0x14
    5e84:	8b 8b       	std	Y+19, r24	; 0x13
    5e86:	3f c0       	rjmp	.+126    	; 0x5f06 <move_y_first+0x53c>
	else if (__tmp > 65535)
    5e88:	6d 89       	ldd	r22, Y+21	; 0x15
    5e8a:	7e 89       	ldd	r23, Y+22	; 0x16
    5e8c:	8f 89       	ldd	r24, Y+23	; 0x17
    5e8e:	98 8d       	ldd	r25, Y+24	; 0x18
    5e90:	20 e0       	ldi	r18, 0x00	; 0
    5e92:	3f ef       	ldi	r19, 0xFF	; 255
    5e94:	4f e7       	ldi	r20, 0x7F	; 127
    5e96:	57 e4       	ldi	r21, 0x47	; 71
    5e98:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    5e9c:	18 16       	cp	r1, r24
    5e9e:	4c f5       	brge	.+82     	; 0x5ef2 <move_y_first+0x528>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5ea0:	69 8d       	ldd	r22, Y+25	; 0x19
    5ea2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5ea4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5ea6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5ea8:	20 e0       	ldi	r18, 0x00	; 0
    5eaa:	30 e0       	ldi	r19, 0x00	; 0
    5eac:	40 e2       	ldi	r20, 0x20	; 32
    5eae:	51 e4       	ldi	r21, 0x41	; 65
    5eb0:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    5eb4:	dc 01       	movw	r26, r24
    5eb6:	cb 01       	movw	r24, r22
    5eb8:	bc 01       	movw	r22, r24
    5eba:	cd 01       	movw	r24, r26
    5ebc:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5ec0:	dc 01       	movw	r26, r24
    5ec2:	cb 01       	movw	r24, r22
    5ec4:	9c 8b       	std	Y+20, r25	; 0x14
    5ec6:	8b 8b       	std	Y+19, r24	; 0x13
    5ec8:	0f c0       	rjmp	.+30     	; 0x5ee8 <move_y_first+0x51e>
    5eca:	80 e7       	ldi	r24, 0x70	; 112
    5ecc:	91 e0       	ldi	r25, 0x01	; 1
    5ece:	9a 8b       	std	Y+18, r25	; 0x12
    5ed0:	89 8b       	std	Y+17, r24	; 0x11
    5ed2:	89 89       	ldd	r24, Y+17	; 0x11
    5ed4:	9a 89       	ldd	r25, Y+18	; 0x12
    5ed6:	01 97       	sbiw	r24, 0x01	; 1
    5ed8:	f1 f7       	brne	.-4      	; 0x5ed6 <move_y_first+0x50c>
    5eda:	9a 8b       	std	Y+18, r25	; 0x12
    5edc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5ede:	8b 89       	ldd	r24, Y+19	; 0x13
    5ee0:	9c 89       	ldd	r25, Y+20	; 0x14
    5ee2:	01 97       	sbiw	r24, 0x01	; 1
    5ee4:	9c 8b       	std	Y+20, r25	; 0x14
    5ee6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5ee8:	8b 89       	ldd	r24, Y+19	; 0x13
    5eea:	9c 89       	ldd	r25, Y+20	; 0x14
    5eec:	00 97       	sbiw	r24, 0x00	; 0
    5eee:	69 f7       	brne	.-38     	; 0x5eca <move_y_first+0x500>
    5ef0:	14 c0       	rjmp	.+40     	; 0x5f1a <move_y_first+0x550>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5ef2:	6d 89       	ldd	r22, Y+21	; 0x15
    5ef4:	7e 89       	ldd	r23, Y+22	; 0x16
    5ef6:	8f 89       	ldd	r24, Y+23	; 0x17
    5ef8:	98 8d       	ldd	r25, Y+24	; 0x18
    5efa:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    5efe:	dc 01       	movw	r26, r24
    5f00:	cb 01       	movw	r24, r22
    5f02:	9c 8b       	std	Y+20, r25	; 0x14
    5f04:	8b 8b       	std	Y+19, r24	; 0x13
    5f06:	8b 89       	ldd	r24, Y+19	; 0x13
    5f08:	9c 89       	ldd	r25, Y+20	; 0x14
    5f0a:	98 8b       	std	Y+16, r25	; 0x10
    5f0c:	8f 87       	std	Y+15, r24	; 0x0f
    5f0e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5f10:	98 89       	ldd	r25, Y+16	; 0x10
    5f12:	01 97       	sbiw	r24, 0x01	; 1
    5f14:	f1 f7       	brne	.-4      	; 0x5f12 <move_y_first+0x548>
    5f16:	98 8b       	std	Y+16, r25	; 0x10
    5f18:	8f 87       	std	Y+15, r24	; 0x0f
					break;
					
				}
			}
		}
		if(move_in_x_dir>0)
    5f1a:	8b ad       	ldd	r24, Y+59	; 0x3b
    5f1c:	9c ad       	ldd	r25, Y+60	; 0x3c
    5f1e:	18 16       	cp	r1, r24
    5f20:	19 06       	cpc	r1, r25
    5f22:	0c f0       	brlt	.+2      	; 0x5f26 <move_y_first+0x55c>
    5f24:	ba c0       	rjmp	.+372    	; 0x609a <move_y_first+0x6d0>
		{
			if(bot_dir==N)
    5f26:	80 91 00 02 	lds	r24, 0x0200
    5f2a:	81 30       	cpi	r24, 0x01	; 1
    5f2c:	29 f4       	brne	.+10     	; 0x5f38 <move_y_first+0x56e>
			{
				right_degrees(102);
    5f2e:	86 e6       	ldi	r24, 0x66	; 102
    5f30:	90 e0       	ldi	r25, 0x00	; 0
    5f32:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
    5f36:	11 c0       	rjmp	.+34     	; 0x5f5a <move_y_first+0x590>
			}
			else if(bot_dir==S)
    5f38:	80 91 00 02 	lds	r24, 0x0200
    5f3c:	83 30       	cpi	r24, 0x03	; 3
    5f3e:	29 f4       	brne	.+10     	; 0x5f4a <move_y_first+0x580>
			{
				left_degrees(102);
    5f40:	86 e6       	ldi	r24, 0x66	; 102
    5f42:	90 e0       	ldi	r25, 0x00	; 0
    5f44:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
    5f48:	08 c0       	rjmp	.+16     	; 0x5f5a <move_y_first+0x590>
			}
			else if(bot_dir==W)
    5f4a:	80 91 00 02 	lds	r24, 0x0200
    5f4e:	82 30       	cpi	r24, 0x02	; 2
    5f50:	21 f4       	brne	.+8      	; 0x5f5a <move_y_first+0x590>
			{
				left_degrees(180);
    5f52:	84 eb       	ldi	r24, 0xB4	; 180
    5f54:	90 e0       	ldi	r25, 0x00	; 0
    5f56:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
			}
				
			bot_dir=E;  //E for east
    5f5a:	84 e0       	ldi	r24, 0x04	; 4
    5f5c:	80 93 00 02 	sts	0x0200, r24
			while(1)
			{
				black_line_follower();
    5f60:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)  
    5f64:	80 91 cc 03 	lds	r24, 0x03CC
    5f68:	8e 31       	cpi	r24, 0x1E	; 30
    5f6a:	b8 f0       	brcs	.+46     	; 0x5f9a <move_y_first+0x5d0>
    5f6c:	80 91 cb 03 	lds	r24, 0x03CB
    5f70:	8e 31       	cpi	r24, 0x1E	; 30
    5f72:	98 f0       	brcs	.+38     	; 0x5f9a <move_y_first+0x5d0>
    5f74:	80 91 cd 03 	lds	r24, 0x03CD
    5f78:	8e 31       	cpi	r24, 0x1E	; 30
    5f7a:	78 f0       	brcs	.+30     	; 0x5f9a <move_y_first+0x5d0>
				{
					while(1)
					{
						black_line_follower();
    5f7c:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
						if(Left_white_line <30 || Right_white_line < 30)
    5f80:	80 91 cb 03 	lds	r24, 0x03CB
    5f84:	8e 31       	cpi	r24, 0x1E	; 30
    5f86:	20 f0       	brcs	.+8      	; 0x5f90 <move_y_first+0x5c6>
    5f88:	80 91 cd 03 	lds	r24, 0x03CD
    5f8c:	8e 31       	cpi	r24, 0x1E	; 30
    5f8e:	b0 f7       	brcc	.-20     	; 0x5f7c <move_y_first+0x5b2>
						{
							move_in_x_dir--;
    5f90:	8b ad       	ldd	r24, Y+59	; 0x3b
    5f92:	9c ad       	ldd	r25, Y+60	; 0x3c
    5f94:	01 97       	sbiw	r24, 0x01	; 1
    5f96:	9c af       	std	Y+60, r25	; 0x3c
    5f98:	8b af       	std	Y+59, r24	; 0x3b
							
							break;
						}
					}
				}
				if(move_in_x_dir==0)
    5f9a:	8b ad       	ldd	r24, Y+59	; 0x3b
    5f9c:	9c ad       	ldd	r25, Y+60	; 0x3c
    5f9e:	00 97       	sbiw	r24, 0x00	; 0
    5fa0:	f9 f6       	brne	.-66     	; 0x5f60 <move_y_first+0x596>
				{
					velocity(115,125);
    5fa2:	83 e7       	ldi	r24, 0x73	; 115
    5fa4:	6d e7       	ldi	r22, 0x7D	; 125
    5fa6:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
					back_mm(75);
    5faa:	8b e4       	ldi	r24, 0x4B	; 75
    5fac:	90 e0       	ldi	r25, 0x00	; 0
    5fae:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <back_mm>
					stop();
    5fb2:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
    5fb6:	80 e0       	ldi	r24, 0x00	; 0
    5fb8:	90 e0       	ldi	r25, 0x00	; 0
    5fba:	a0 e8       	ldi	r26, 0x80	; 128
    5fbc:	bf e3       	ldi	r27, 0x3F	; 63
    5fbe:	8b 87       	std	Y+11, r24	; 0x0b
    5fc0:	9c 87       	std	Y+12, r25	; 0x0c
    5fc2:	ad 87       	std	Y+13, r26	; 0x0d
    5fc4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5fc6:	6b 85       	ldd	r22, Y+11	; 0x0b
    5fc8:	7c 85       	ldd	r23, Y+12	; 0x0c
    5fca:	8d 85       	ldd	r24, Y+13	; 0x0d
    5fcc:	9e 85       	ldd	r25, Y+14	; 0x0e
    5fce:	26 e6       	ldi	r18, 0x66	; 102
    5fd0:	36 e6       	ldi	r19, 0x66	; 102
    5fd2:	46 e6       	ldi	r20, 0x66	; 102
    5fd4:	55 e4       	ldi	r21, 0x45	; 69
    5fd6:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    5fda:	dc 01       	movw	r26, r24
    5fdc:	cb 01       	movw	r24, r22
    5fde:	8f 83       	std	Y+7, r24	; 0x07
    5fe0:	98 87       	std	Y+8, r25	; 0x08
    5fe2:	a9 87       	std	Y+9, r26	; 0x09
    5fe4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5fe6:	6f 81       	ldd	r22, Y+7	; 0x07
    5fe8:	78 85       	ldd	r23, Y+8	; 0x08
    5fea:	89 85       	ldd	r24, Y+9	; 0x09
    5fec:	9a 85       	ldd	r25, Y+10	; 0x0a
    5fee:	20 e0       	ldi	r18, 0x00	; 0
    5ff0:	30 e0       	ldi	r19, 0x00	; 0
    5ff2:	40 e8       	ldi	r20, 0x80	; 128
    5ff4:	5f e3       	ldi	r21, 0x3F	; 63
    5ff6:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    5ffa:	88 23       	and	r24, r24
    5ffc:	2c f4       	brge	.+10     	; 0x6008 <move_y_first+0x63e>
		__ticks = 1;
    5ffe:	81 e0       	ldi	r24, 0x01	; 1
    6000:	90 e0       	ldi	r25, 0x00	; 0
    6002:	9e 83       	std	Y+6, r25	; 0x06
    6004:	8d 83       	std	Y+5, r24	; 0x05
    6006:	3f c0       	rjmp	.+126    	; 0x6086 <move_y_first+0x6bc>
	else if (__tmp > 65535)
    6008:	6f 81       	ldd	r22, Y+7	; 0x07
    600a:	78 85       	ldd	r23, Y+8	; 0x08
    600c:	89 85       	ldd	r24, Y+9	; 0x09
    600e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6010:	20 e0       	ldi	r18, 0x00	; 0
    6012:	3f ef       	ldi	r19, 0xFF	; 255
    6014:	4f e7       	ldi	r20, 0x7F	; 127
    6016:	57 e4       	ldi	r21, 0x47	; 71
    6018:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    601c:	18 16       	cp	r1, r24
    601e:	4c f5       	brge	.+82     	; 0x6072 <move_y_first+0x6a8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6020:	6b 85       	ldd	r22, Y+11	; 0x0b
    6022:	7c 85       	ldd	r23, Y+12	; 0x0c
    6024:	8d 85       	ldd	r24, Y+13	; 0x0d
    6026:	9e 85       	ldd	r25, Y+14	; 0x0e
    6028:	20 e0       	ldi	r18, 0x00	; 0
    602a:	30 e0       	ldi	r19, 0x00	; 0
    602c:	40 e2       	ldi	r20, 0x20	; 32
    602e:	51 e4       	ldi	r21, 0x41	; 65
    6030:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6034:	dc 01       	movw	r26, r24
    6036:	cb 01       	movw	r24, r22
    6038:	bc 01       	movw	r22, r24
    603a:	cd 01       	movw	r24, r26
    603c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    6040:	dc 01       	movw	r26, r24
    6042:	cb 01       	movw	r24, r22
    6044:	9e 83       	std	Y+6, r25	; 0x06
    6046:	8d 83       	std	Y+5, r24	; 0x05
    6048:	0f c0       	rjmp	.+30     	; 0x6068 <move_y_first+0x69e>
    604a:	80 e7       	ldi	r24, 0x70	; 112
    604c:	91 e0       	ldi	r25, 0x01	; 1
    604e:	9c 83       	std	Y+4, r25	; 0x04
    6050:	8b 83       	std	Y+3, r24	; 0x03
    6052:	8b 81       	ldd	r24, Y+3	; 0x03
    6054:	9c 81       	ldd	r25, Y+4	; 0x04
    6056:	01 97       	sbiw	r24, 0x01	; 1
    6058:	f1 f7       	brne	.-4      	; 0x6056 <move_y_first+0x68c>
    605a:	9c 83       	std	Y+4, r25	; 0x04
    605c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    605e:	8d 81       	ldd	r24, Y+5	; 0x05
    6060:	9e 81       	ldd	r25, Y+6	; 0x06
    6062:	01 97       	sbiw	r24, 0x01	; 1
    6064:	9e 83       	std	Y+6, r25	; 0x06
    6066:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6068:	8d 81       	ldd	r24, Y+5	; 0x05
    606a:	9e 81       	ldd	r25, Y+6	; 0x06
    606c:	00 97       	sbiw	r24, 0x00	; 0
    606e:	69 f7       	brne	.-38     	; 0x604a <move_y_first+0x680>
    6070:	14 c0       	rjmp	.+40     	; 0x609a <move_y_first+0x6d0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6072:	6f 81       	ldd	r22, Y+7	; 0x07
    6074:	78 85       	ldd	r23, Y+8	; 0x08
    6076:	89 85       	ldd	r24, Y+9	; 0x09
    6078:	9a 85       	ldd	r25, Y+10	; 0x0a
    607a:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    607e:	dc 01       	movw	r26, r24
    6080:	cb 01       	movw	r24, r22
    6082:	9e 83       	std	Y+6, r25	; 0x06
    6084:	8d 83       	std	Y+5, r24	; 0x05
    6086:	8d 81       	ldd	r24, Y+5	; 0x05
    6088:	9e 81       	ldd	r25, Y+6	; 0x06
    608a:	9a 83       	std	Y+2, r25	; 0x02
    608c:	89 83       	std	Y+1, r24	; 0x01
    608e:	89 81       	ldd	r24, Y+1	; 0x01
    6090:	9a 81       	ldd	r25, Y+2	; 0x02
    6092:	01 97       	sbiw	r24, 0x01	; 1
    6094:	f1 f7       	brne	.-4      	; 0x6092 <move_y_first+0x6c8>
    6096:	9a 83       	std	Y+2, r25	; 0x02
    6098:	89 83       	std	Y+1, r24	; 0x01
				
			}
		}
	}
	
}
    609a:	cc 5b       	subi	r28, 0xBC	; 188
    609c:	df 4f       	sbci	r29, 0xFF	; 255
    609e:	0f b6       	in	r0, 0x3f	; 63
    60a0:	f8 94       	cli
    60a2:	de bf       	out	0x3e, r29	; 62
    60a4:	0f be       	out	0x3f, r0	; 63
    60a6:	cd bf       	out	0x3d, r28	; 61
    60a8:	cf 91       	pop	r28
    60aa:	df 91       	pop	r29
    60ac:	08 95       	ret

000060ae <move_x_first>:

* Example Call:		move_y_first(2,-1,3,4);
*
*/	
void move_x_first(int x1,int y1,int x2,int y2)
{
    60ae:	0f 93       	push	r16
    60b0:	1f 93       	push	r17
    60b2:	df 93       	push	r29
    60b4:	cf 93       	push	r28
    60b6:	cd b7       	in	r28, 0x3d	; 61
    60b8:	de b7       	in	r29, 0x3e	; 62
    60ba:	c2 55       	subi	r28, 0x52	; 82
    60bc:	d0 40       	sbci	r29, 0x00	; 0
    60be:	0f b6       	in	r0, 0x3f	; 63
    60c0:	f8 94       	cli
    60c2:	de bf       	out	0x3e, r29	; 62
    60c4:	0f be       	out	0x3f, r0	; 63
    60c6:	cd bf       	out	0x3d, r28	; 61
    60c8:	fe 01       	movw	r30, r28
    60ca:	e5 5b       	subi	r30, 0xB5	; 181
    60cc:	ff 4f       	sbci	r31, 0xFF	; 255
    60ce:	91 83       	std	Z+1, r25	; 0x01
    60d0:	80 83       	st	Z, r24
    60d2:	fe 01       	movw	r30, r28
    60d4:	e3 5b       	subi	r30, 0xB3	; 179
    60d6:	ff 4f       	sbci	r31, 0xFF	; 255
    60d8:	71 83       	std	Z+1, r23	; 0x01
    60da:	60 83       	st	Z, r22
    60dc:	fe 01       	movw	r30, r28
    60de:	e1 5b       	subi	r30, 0xB1	; 177
    60e0:	ff 4f       	sbci	r31, 0xFF	; 255
    60e2:	51 83       	std	Z+1, r21	; 0x01
    60e4:	40 83       	st	Z, r20
    60e6:	fe 01       	movw	r30, r28
    60e8:	ef 5a       	subi	r30, 0xAF	; 175
    60ea:	ff 4f       	sbci	r31, 0xFF	; 255
    60ec:	31 83       	std	Z+1, r19	; 0x01
    60ee:	20 83       	st	Z, r18
	int move_in_x_dir=x2-x1;
    60f0:	ae 01       	movw	r20, r28
    60f2:	47 5b       	subi	r20, 0xB7	; 183
    60f4:	5f 4f       	sbci	r21, 0xFF	; 255
    60f6:	fe 01       	movw	r30, r28
    60f8:	e1 5b       	subi	r30, 0xB1	; 177
    60fa:	ff 4f       	sbci	r31, 0xFF	; 255
    60fc:	de 01       	movw	r26, r28
    60fe:	a5 5b       	subi	r26, 0xB5	; 181
    6100:	bf 4f       	sbci	r27, 0xFF	; 255
    6102:	20 81       	ld	r18, Z
    6104:	31 81       	ldd	r19, Z+1	; 0x01
    6106:	8d 91       	ld	r24, X+
    6108:	9c 91       	ld	r25, X
    610a:	b9 01       	movw	r22, r18
    610c:	68 1b       	sub	r22, r24
    610e:	79 0b       	sbc	r23, r25
    6110:	cb 01       	movw	r24, r22
    6112:	fa 01       	movw	r30, r20
    6114:	91 83       	std	Z+1, r25	; 0x01
    6116:	80 83       	st	Z, r24
	int move_in_y_dir=y2-y1;
    6118:	ae 01       	movw	r20, r28
    611a:	49 5b       	subi	r20, 0xB9	; 185
    611c:	5f 4f       	sbci	r21, 0xFF	; 255
    611e:	fe 01       	movw	r30, r28
    6120:	ef 5a       	subi	r30, 0xAF	; 175
    6122:	ff 4f       	sbci	r31, 0xFF	; 255
    6124:	de 01       	movw	r26, r28
    6126:	a3 5b       	subi	r26, 0xB3	; 179
    6128:	bf 4f       	sbci	r27, 0xFF	; 255
    612a:	20 81       	ld	r18, Z
    612c:	31 81       	ldd	r19, Z+1	; 0x01
    612e:	8d 91       	ld	r24, X+
    6130:	9c 91       	ld	r25, X
    6132:	11 97       	sbiw	r26, 0x01	; 1
    6134:	b9 01       	movw	r22, r18
    6136:	68 1b       	sub	r22, r24
    6138:	79 0b       	sbc	r23, r25
    613a:	cb 01       	movw	r24, r22
    613c:	fa 01       	movw	r30, r20
    613e:	91 83       	std	Z+1, r25	; 0x01
    6140:	80 83       	st	Z, r24

	if(move_in_x_dir!=0)
    6142:	fe 01       	movw	r30, r28
    6144:	e7 5b       	subi	r30, 0xB7	; 183
    6146:	ff 4f       	sbci	r31, 0xFF	; 255
    6148:	80 81       	ld	r24, Z
    614a:	91 81       	ldd	r25, Z+1	; 0x01
    614c:	00 97       	sbiw	r24, 0x00	; 0
    614e:	09 f4       	brne	.+2      	; 0x6152 <move_x_first+0xa4>
    6150:	32 c1       	rjmp	.+612    	; 0x63b6 <move_x_first+0x308>
    6152:	fe 01       	movw	r30, r28
    6154:	ed 5b       	subi	r30, 0xBD	; 189
    6156:	ff 4f       	sbci	r31, 0xFF	; 255
    6158:	80 e0       	ldi	r24, 0x00	; 0
    615a:	90 e0       	ldi	r25, 0x00	; 0
    615c:	a0 e2       	ldi	r26, 0x20	; 32
    615e:	b2 e4       	ldi	r27, 0x42	; 66
    6160:	80 83       	st	Z, r24
    6162:	91 83       	std	Z+1, r25	; 0x01
    6164:	a2 83       	std	Z+2, r26	; 0x02
    6166:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6168:	8e 01       	movw	r16, r28
    616a:	01 5c       	subi	r16, 0xC1	; 193
    616c:	1f 4f       	sbci	r17, 0xFF	; 255
    616e:	fe 01       	movw	r30, r28
    6170:	ed 5b       	subi	r30, 0xBD	; 189
    6172:	ff 4f       	sbci	r31, 0xFF	; 255
    6174:	60 81       	ld	r22, Z
    6176:	71 81       	ldd	r23, Z+1	; 0x01
    6178:	82 81       	ldd	r24, Z+2	; 0x02
    617a:	93 81       	ldd	r25, Z+3	; 0x03
    617c:	26 e6       	ldi	r18, 0x66	; 102
    617e:	36 e6       	ldi	r19, 0x66	; 102
    6180:	46 e6       	ldi	r20, 0x66	; 102
    6182:	55 e4       	ldi	r21, 0x45	; 69
    6184:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6188:	dc 01       	movw	r26, r24
    618a:	cb 01       	movw	r24, r22
    618c:	f8 01       	movw	r30, r16
    618e:	80 83       	st	Z, r24
    6190:	91 83       	std	Z+1, r25	; 0x01
    6192:	a2 83       	std	Z+2, r26	; 0x02
    6194:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    6196:	fe 01       	movw	r30, r28
    6198:	ff 96       	adiw	r30, 0x3f	; 63
    619a:	60 81       	ld	r22, Z
    619c:	71 81       	ldd	r23, Z+1	; 0x01
    619e:	82 81       	ldd	r24, Z+2	; 0x02
    61a0:	93 81       	ldd	r25, Z+3	; 0x03
    61a2:	20 e0       	ldi	r18, 0x00	; 0
    61a4:	30 e0       	ldi	r19, 0x00	; 0
    61a6:	40 e8       	ldi	r20, 0x80	; 128
    61a8:	5f e3       	ldi	r21, 0x3F	; 63
    61aa:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    61ae:	88 23       	and	r24, r24
    61b0:	2c f4       	brge	.+10     	; 0x61bc <move_x_first+0x10e>
		__ticks = 1;
    61b2:	81 e0       	ldi	r24, 0x01	; 1
    61b4:	90 e0       	ldi	r25, 0x00	; 0
    61b6:	9e af       	std	Y+62, r25	; 0x3e
    61b8:	8d af       	std	Y+61, r24	; 0x3d
    61ba:	46 c0       	rjmp	.+140    	; 0x6248 <move_x_first+0x19a>
	else if (__tmp > 65535)
    61bc:	fe 01       	movw	r30, r28
    61be:	ff 96       	adiw	r30, 0x3f	; 63
    61c0:	60 81       	ld	r22, Z
    61c2:	71 81       	ldd	r23, Z+1	; 0x01
    61c4:	82 81       	ldd	r24, Z+2	; 0x02
    61c6:	93 81       	ldd	r25, Z+3	; 0x03
    61c8:	20 e0       	ldi	r18, 0x00	; 0
    61ca:	3f ef       	ldi	r19, 0xFF	; 255
    61cc:	4f e7       	ldi	r20, 0x7F	; 127
    61ce:	57 e4       	ldi	r21, 0x47	; 71
    61d0:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    61d4:	18 16       	cp	r1, r24
    61d6:	64 f5       	brge	.+88     	; 0x6230 <move_x_first+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    61d8:	fe 01       	movw	r30, r28
    61da:	ed 5b       	subi	r30, 0xBD	; 189
    61dc:	ff 4f       	sbci	r31, 0xFF	; 255
    61de:	60 81       	ld	r22, Z
    61e0:	71 81       	ldd	r23, Z+1	; 0x01
    61e2:	82 81       	ldd	r24, Z+2	; 0x02
    61e4:	93 81       	ldd	r25, Z+3	; 0x03
    61e6:	20 e0       	ldi	r18, 0x00	; 0
    61e8:	30 e0       	ldi	r19, 0x00	; 0
    61ea:	40 e2       	ldi	r20, 0x20	; 32
    61ec:	51 e4       	ldi	r21, 0x41	; 65
    61ee:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    61f2:	dc 01       	movw	r26, r24
    61f4:	cb 01       	movw	r24, r22
    61f6:	bc 01       	movw	r22, r24
    61f8:	cd 01       	movw	r24, r26
    61fa:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    61fe:	dc 01       	movw	r26, r24
    6200:	cb 01       	movw	r24, r22
    6202:	9e af       	std	Y+62, r25	; 0x3e
    6204:	8d af       	std	Y+61, r24	; 0x3d
    6206:	0f c0       	rjmp	.+30     	; 0x6226 <move_x_first+0x178>
    6208:	80 e7       	ldi	r24, 0x70	; 112
    620a:	91 e0       	ldi	r25, 0x01	; 1
    620c:	9c af       	std	Y+60, r25	; 0x3c
    620e:	8b af       	std	Y+59, r24	; 0x3b
    6210:	8b ad       	ldd	r24, Y+59	; 0x3b
    6212:	9c ad       	ldd	r25, Y+60	; 0x3c
    6214:	01 97       	sbiw	r24, 0x01	; 1
    6216:	f1 f7       	brne	.-4      	; 0x6214 <move_x_first+0x166>
    6218:	9c af       	std	Y+60, r25	; 0x3c
    621a:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    621c:	8d ad       	ldd	r24, Y+61	; 0x3d
    621e:	9e ad       	ldd	r25, Y+62	; 0x3e
    6220:	01 97       	sbiw	r24, 0x01	; 1
    6222:	9e af       	std	Y+62, r25	; 0x3e
    6224:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6226:	8d ad       	ldd	r24, Y+61	; 0x3d
    6228:	9e ad       	ldd	r25, Y+62	; 0x3e
    622a:	00 97       	sbiw	r24, 0x00	; 0
    622c:	69 f7       	brne	.-38     	; 0x6208 <move_x_first+0x15a>
    622e:	16 c0       	rjmp	.+44     	; 0x625c <move_x_first+0x1ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6230:	fe 01       	movw	r30, r28
    6232:	ff 96       	adiw	r30, 0x3f	; 63
    6234:	60 81       	ld	r22, Z
    6236:	71 81       	ldd	r23, Z+1	; 0x01
    6238:	82 81       	ldd	r24, Z+2	; 0x02
    623a:	93 81       	ldd	r25, Z+3	; 0x03
    623c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    6240:	dc 01       	movw	r26, r24
    6242:	cb 01       	movw	r24, r22
    6244:	9e af       	std	Y+62, r25	; 0x3e
    6246:	8d af       	std	Y+61, r24	; 0x3d
    6248:	8d ad       	ldd	r24, Y+61	; 0x3d
    624a:	9e ad       	ldd	r25, Y+62	; 0x3e
    624c:	9a af       	std	Y+58, r25	; 0x3a
    624e:	89 af       	std	Y+57, r24	; 0x39
    6250:	89 ad       	ldd	r24, Y+57	; 0x39
    6252:	9a ad       	ldd	r25, Y+58	; 0x3a
    6254:	01 97       	sbiw	r24, 0x01	; 1
    6256:	f1 f7       	brne	.-4      	; 0x6254 <move_x_first+0x1a6>
    6258:	9a af       	std	Y+58, r25	; 0x3a
    625a:	89 af       	std	Y+57, r24	; 0x39
	{
		_delay_ms(40);
		velocity(115,125);
    625c:	83 e7       	ldi	r24, 0x73	; 115
    625e:	6d e7       	ldi	r22, 0x7D	; 125
    6260:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
		if(move_in_x_dir<0) // if the value is -ve then move in West direction
    6264:	fe 01       	movw	r30, r28
    6266:	e7 5b       	subi	r30, 0xB7	; 183
    6268:	ff 4f       	sbci	r31, 0xFF	; 255
    626a:	80 81       	ld	r24, Z
    626c:	91 81       	ldd	r25, Z+1	; 0x01
    626e:	99 23       	and	r25, r25
    6270:	0c f0       	brlt	.+2      	; 0x6274 <move_x_first+0x1c6>
    6272:	55 c0       	rjmp	.+170    	; 0x631e <move_x_first+0x270>
		{	
			if(bot_dir==N)
    6274:	80 91 00 02 	lds	r24, 0x0200
    6278:	81 30       	cpi	r24, 0x01	; 1
    627a:	21 f4       	brne	.+8      	; 0x6284 <move_x_first+0x1d6>
			{
				left_degrees(102);
    627c:	86 e6       	ldi	r24, 0x66	; 102
    627e:	90 e0       	ldi	r25, 0x00	; 0
    6280:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
			}
			if(bot_dir==S)
    6284:	80 91 00 02 	lds	r24, 0x0200
    6288:	83 30       	cpi	r24, 0x03	; 3
    628a:	21 f4       	brne	.+8      	; 0x6294 <move_x_first+0x1e6>
			{
				right_degrees(102);
    628c:	86 e6       	ldi	r24, 0x66	; 102
    628e:	90 e0       	ldi	r25, 0x00	; 0
    6290:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
			}
			if(bot_dir==E)
    6294:	80 91 00 02 	lds	r24, 0x0200
    6298:	84 30       	cpi	r24, 0x04	; 4
    629a:	29 f4       	brne	.+10     	; 0x62a6 <move_x_first+0x1f8>
			{
				left_degrees(180);
    629c:	84 eb       	ldi	r24, 0xB4	; 180
    629e:	90 e0       	ldi	r25, 0x00	; 0
    62a0:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
    62a4:	0b c0       	rjmp	.+22     	; 0x62bc <move_x_first+0x20e>
			}
			else
			{
				move_in_x_dir--;
    62a6:	de 01       	movw	r26, r28
    62a8:	a7 5b       	subi	r26, 0xB7	; 183
    62aa:	bf 4f       	sbci	r27, 0xFF	; 255
    62ac:	fe 01       	movw	r30, r28
    62ae:	e7 5b       	subi	r30, 0xB7	; 183
    62b0:	ff 4f       	sbci	r31, 0xFF	; 255
    62b2:	80 81       	ld	r24, Z
    62b4:	91 81       	ldd	r25, Z+1	; 0x01
    62b6:	01 97       	sbiw	r24, 0x01	; 1
    62b8:	8d 93       	st	X+, r24
    62ba:	9c 93       	st	X, r25
			}
			bot_dir=W;   // W for west
    62bc:	82 e0       	ldi	r24, 0x02	; 2
    62be:	80 93 00 02 	sts	0x0200, r24
			
			while(1)     // following while loop counts the node as the robot moves and breaks when required nodes in West direction are traversed.
			{
				black_line_follower();
    62c2:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)    // counts node 
    62c6:	80 91 cc 03 	lds	r24, 0x03CC
    62ca:	8e 31       	cpi	r24, 0x1E	; 30
    62cc:	f0 f0       	brcs	.+60     	; 0x630a <move_x_first+0x25c>
    62ce:	80 91 cb 03 	lds	r24, 0x03CB
    62d2:	8e 31       	cpi	r24, 0x1E	; 30
    62d4:	d0 f0       	brcs	.+52     	; 0x630a <move_x_first+0x25c>
    62d6:	80 91 cd 03 	lds	r24, 0x03CD
    62da:	8e 31       	cpi	r24, 0x1E	; 30
    62dc:	b0 f0       	brcs	.+44     	; 0x630a <move_x_first+0x25c>
				{
					while(1)
					{
						
						black_line_follower();
    62de:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
						if(Left_white_line <30 || Right_white_line < 30)     // detects when robot has crossed a node 
    62e2:	80 91 cb 03 	lds	r24, 0x03CB
    62e6:	8e 31       	cpi	r24, 0x1E	; 30
    62e8:	20 f0       	brcs	.+8      	; 0x62f2 <move_x_first+0x244>
    62ea:	80 91 cd 03 	lds	r24, 0x03CD
    62ee:	8e 31       	cpi	r24, 0x1E	; 30
    62f0:	b0 f7       	brcc	.-20     	; 0x62de <move_x_first+0x230>
						{
							move_in_x_dir++;
    62f2:	de 01       	movw	r26, r28
    62f4:	a7 5b       	subi	r26, 0xB7	; 183
    62f6:	bf 4f       	sbci	r27, 0xFF	; 255
    62f8:	fe 01       	movw	r30, r28
    62fa:	e7 5b       	subi	r30, 0xB7	; 183
    62fc:	ff 4f       	sbci	r31, 0xFF	; 255
    62fe:	80 81       	ld	r24, Z
    6300:	91 81       	ldd	r25, Z+1	; 0x01
    6302:	01 96       	adiw	r24, 0x01	; 1
    6304:	11 96       	adiw	r26, 0x01	; 1
    6306:	9c 93       	st	X, r25
    6308:	8e 93       	st	-X, r24
							
							break;
						}
					}
				}
				if(move_in_x_dir==0)  // if required node traversed then stop
    630a:	fe 01       	movw	r30, r28
    630c:	e7 5b       	subi	r30, 0xB7	; 183
    630e:	ff 4f       	sbci	r31, 0xFF	; 255
    6310:	80 81       	ld	r24, Z
    6312:	91 81       	ldd	r25, Z+1	; 0x01
    6314:	00 97       	sbiw	r24, 0x00	; 0
    6316:	a9 f6       	brne	.-86     	; 0x62c2 <move_x_first+0x214>
				{
					stop();
    6318:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
    631c:	4c c0       	rjmp	.+152    	; 0x63b6 <move_x_first+0x308>
		/* almost same this is happpening in remaining function(only direction is changing) 
		so they are self explanatory once above comments are understood.
		*/
		else
		{
			if(bot_dir==N)
    631e:	80 91 00 02 	lds	r24, 0x0200
    6322:	81 30       	cpi	r24, 0x01	; 1
    6324:	29 f4       	brne	.+10     	; 0x6330 <move_x_first+0x282>
			{
				right_degrees(102);
    6326:	86 e6       	ldi	r24, 0x66	; 102
    6328:	90 e0       	ldi	r25, 0x00	; 0
    632a:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
    632e:	11 c0       	rjmp	.+34     	; 0x6352 <move_x_first+0x2a4>
			}
			else if(bot_dir==S)
    6330:	80 91 00 02 	lds	r24, 0x0200
    6334:	83 30       	cpi	r24, 0x03	; 3
    6336:	29 f4       	brne	.+10     	; 0x6342 <move_x_first+0x294>
			{
				left_degrees(102);
    6338:	86 e6       	ldi	r24, 0x66	; 102
    633a:	90 e0       	ldi	r25, 0x00	; 0
    633c:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
    6340:	08 c0       	rjmp	.+16     	; 0x6352 <move_x_first+0x2a4>
			}
			else if(bot_dir==W)
    6342:	80 91 00 02 	lds	r24, 0x0200
    6346:	82 30       	cpi	r24, 0x02	; 2
    6348:	21 f4       	brne	.+8      	; 0x6352 <move_x_first+0x2a4>
			{
				left_degrees(180);
    634a:	84 eb       	ldi	r24, 0xB4	; 180
    634c:	90 e0       	ldi	r25, 0x00	; 0
    634e:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
			}
			
			bot_dir=E;   // E for east
    6352:	84 e0       	ldi	r24, 0x04	; 4
    6354:	80 93 00 02 	sts	0x0200, r24
			while(1)
			{
				black_line_follower();
    6358:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)  
    635c:	80 91 cc 03 	lds	r24, 0x03CC
    6360:	8e 31       	cpi	r24, 0x1E	; 30
    6362:	f0 f0       	brcs	.+60     	; 0x63a0 <move_x_first+0x2f2>
    6364:	80 91 cb 03 	lds	r24, 0x03CB
    6368:	8e 31       	cpi	r24, 0x1E	; 30
    636a:	d0 f0       	brcs	.+52     	; 0x63a0 <move_x_first+0x2f2>
    636c:	80 91 cd 03 	lds	r24, 0x03CD
    6370:	8e 31       	cpi	r24, 0x1E	; 30
    6372:	b0 f0       	brcs	.+44     	; 0x63a0 <move_x_first+0x2f2>
				{
					while(1)
					{
						black_line_follower();
    6374:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>

						if(Left_white_line <30 || Right_white_line < 30)
    6378:	80 91 cb 03 	lds	r24, 0x03CB
    637c:	8e 31       	cpi	r24, 0x1E	; 30
    637e:	20 f0       	brcs	.+8      	; 0x6388 <move_x_first+0x2da>
    6380:	80 91 cd 03 	lds	r24, 0x03CD
    6384:	8e 31       	cpi	r24, 0x1E	; 30
    6386:	b0 f7       	brcc	.-20     	; 0x6374 <move_x_first+0x2c6>
						{
							move_in_x_dir--;
    6388:	de 01       	movw	r26, r28
    638a:	a7 5b       	subi	r26, 0xB7	; 183
    638c:	bf 4f       	sbci	r27, 0xFF	; 255
    638e:	fe 01       	movw	r30, r28
    6390:	e7 5b       	subi	r30, 0xB7	; 183
    6392:	ff 4f       	sbci	r31, 0xFF	; 255
    6394:	80 81       	ld	r24, Z
    6396:	91 81       	ldd	r25, Z+1	; 0x01
    6398:	01 97       	sbiw	r24, 0x01	; 1
    639a:	11 96       	adiw	r26, 0x01	; 1
    639c:	9c 93       	st	X, r25
    639e:	8e 93       	st	-X, r24
							
							break;
						}
					}
				}
				if(move_in_x_dir==-1) 
    63a0:	fe 01       	movw	r30, r28
    63a2:	e7 5b       	subi	r30, 0xB7	; 183
    63a4:	ff 4f       	sbci	r31, 0xFF	; 255
    63a6:	80 81       	ld	r24, Z
    63a8:	91 81       	ldd	r25, Z+1	; 0x01
    63aa:	ff ef       	ldi	r31, 0xFF	; 255
    63ac:	8f 3f       	cpi	r24, 0xFF	; 255
    63ae:	9f 07       	cpc	r25, r31
    63b0:	99 f6       	brne	.-90     	; 0x6358 <move_x_first+0x2aa>
				{
					stop();
    63b2:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
				}
				
			}
		}
	}
	if(move_in_y_dir!=0)
    63b6:	fe 01       	movw	r30, r28
    63b8:	e9 5b       	subi	r30, 0xB9	; 185
    63ba:	ff 4f       	sbci	r31, 0xFF	; 255
    63bc:	80 81       	ld	r24, Z
    63be:	91 81       	ldd	r25, Z+1	; 0x01
    63c0:	00 97       	sbiw	r24, 0x00	; 0
    63c2:	09 f4       	brne	.+2      	; 0x63c6 <move_x_first+0x318>
    63c4:	16 c2       	rjmp	.+1068   	; 0x67f2 <move_x_first+0x744>
    63c6:	80 e0       	ldi	r24, 0x00	; 0
    63c8:	90 e0       	ldi	r25, 0x00	; 0
    63ca:	a0 e2       	ldi	r26, 0x20	; 32
    63cc:	b2 e4       	ldi	r27, 0x42	; 66
    63ce:	8d ab       	std	Y+53, r24	; 0x35
    63d0:	9e ab       	std	Y+54, r25	; 0x36
    63d2:	af ab       	std	Y+55, r26	; 0x37
    63d4:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    63d6:	6d a9       	ldd	r22, Y+53	; 0x35
    63d8:	7e a9       	ldd	r23, Y+54	; 0x36
    63da:	8f a9       	ldd	r24, Y+55	; 0x37
    63dc:	98 ad       	ldd	r25, Y+56	; 0x38
    63de:	26 e6       	ldi	r18, 0x66	; 102
    63e0:	36 e6       	ldi	r19, 0x66	; 102
    63e2:	46 e6       	ldi	r20, 0x66	; 102
    63e4:	55 e4       	ldi	r21, 0x45	; 69
    63e6:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    63ea:	dc 01       	movw	r26, r24
    63ec:	cb 01       	movw	r24, r22
    63ee:	89 ab       	std	Y+49, r24	; 0x31
    63f0:	9a ab       	std	Y+50, r25	; 0x32
    63f2:	ab ab       	std	Y+51, r26	; 0x33
    63f4:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    63f6:	69 a9       	ldd	r22, Y+49	; 0x31
    63f8:	7a a9       	ldd	r23, Y+50	; 0x32
    63fa:	8b a9       	ldd	r24, Y+51	; 0x33
    63fc:	9c a9       	ldd	r25, Y+52	; 0x34
    63fe:	20 e0       	ldi	r18, 0x00	; 0
    6400:	30 e0       	ldi	r19, 0x00	; 0
    6402:	40 e8       	ldi	r20, 0x80	; 128
    6404:	5f e3       	ldi	r21, 0x3F	; 63
    6406:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    640a:	88 23       	and	r24, r24
    640c:	2c f4       	brge	.+10     	; 0x6418 <move_x_first+0x36a>
		__ticks = 1;
    640e:	81 e0       	ldi	r24, 0x01	; 1
    6410:	90 e0       	ldi	r25, 0x00	; 0
    6412:	98 ab       	std	Y+48, r25	; 0x30
    6414:	8f a7       	std	Y+47, r24	; 0x2f
    6416:	3f c0       	rjmp	.+126    	; 0x6496 <move_x_first+0x3e8>
	else if (__tmp > 65535)
    6418:	69 a9       	ldd	r22, Y+49	; 0x31
    641a:	7a a9       	ldd	r23, Y+50	; 0x32
    641c:	8b a9       	ldd	r24, Y+51	; 0x33
    641e:	9c a9       	ldd	r25, Y+52	; 0x34
    6420:	20 e0       	ldi	r18, 0x00	; 0
    6422:	3f ef       	ldi	r19, 0xFF	; 255
    6424:	4f e7       	ldi	r20, 0x7F	; 127
    6426:	57 e4       	ldi	r21, 0x47	; 71
    6428:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    642c:	18 16       	cp	r1, r24
    642e:	4c f5       	brge	.+82     	; 0x6482 <move_x_first+0x3d4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6430:	6d a9       	ldd	r22, Y+53	; 0x35
    6432:	7e a9       	ldd	r23, Y+54	; 0x36
    6434:	8f a9       	ldd	r24, Y+55	; 0x37
    6436:	98 ad       	ldd	r25, Y+56	; 0x38
    6438:	20 e0       	ldi	r18, 0x00	; 0
    643a:	30 e0       	ldi	r19, 0x00	; 0
    643c:	40 e2       	ldi	r20, 0x20	; 32
    643e:	51 e4       	ldi	r21, 0x41	; 65
    6440:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6444:	dc 01       	movw	r26, r24
    6446:	cb 01       	movw	r24, r22
    6448:	bc 01       	movw	r22, r24
    644a:	cd 01       	movw	r24, r26
    644c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    6450:	dc 01       	movw	r26, r24
    6452:	cb 01       	movw	r24, r22
    6454:	98 ab       	std	Y+48, r25	; 0x30
    6456:	8f a7       	std	Y+47, r24	; 0x2f
    6458:	0f c0       	rjmp	.+30     	; 0x6478 <move_x_first+0x3ca>
    645a:	80 e7       	ldi	r24, 0x70	; 112
    645c:	91 e0       	ldi	r25, 0x01	; 1
    645e:	9e a7       	std	Y+46, r25	; 0x2e
    6460:	8d a7       	std	Y+45, r24	; 0x2d
    6462:	8d a5       	ldd	r24, Y+45	; 0x2d
    6464:	9e a5       	ldd	r25, Y+46	; 0x2e
    6466:	01 97       	sbiw	r24, 0x01	; 1
    6468:	f1 f7       	brne	.-4      	; 0x6466 <move_x_first+0x3b8>
    646a:	9e a7       	std	Y+46, r25	; 0x2e
    646c:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    646e:	8f a5       	ldd	r24, Y+47	; 0x2f
    6470:	98 a9       	ldd	r25, Y+48	; 0x30
    6472:	01 97       	sbiw	r24, 0x01	; 1
    6474:	98 ab       	std	Y+48, r25	; 0x30
    6476:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6478:	8f a5       	ldd	r24, Y+47	; 0x2f
    647a:	98 a9       	ldd	r25, Y+48	; 0x30
    647c:	00 97       	sbiw	r24, 0x00	; 0
    647e:	69 f7       	brne	.-38     	; 0x645a <move_x_first+0x3ac>
    6480:	14 c0       	rjmp	.+40     	; 0x64aa <move_x_first+0x3fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6482:	69 a9       	ldd	r22, Y+49	; 0x31
    6484:	7a a9       	ldd	r23, Y+50	; 0x32
    6486:	8b a9       	ldd	r24, Y+51	; 0x33
    6488:	9c a9       	ldd	r25, Y+52	; 0x34
    648a:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    648e:	dc 01       	movw	r26, r24
    6490:	cb 01       	movw	r24, r22
    6492:	98 ab       	std	Y+48, r25	; 0x30
    6494:	8f a7       	std	Y+47, r24	; 0x2f
    6496:	8f a5       	ldd	r24, Y+47	; 0x2f
    6498:	98 a9       	ldd	r25, Y+48	; 0x30
    649a:	9c a7       	std	Y+44, r25	; 0x2c
    649c:	8b a7       	std	Y+43, r24	; 0x2b
    649e:	8b a5       	ldd	r24, Y+43	; 0x2b
    64a0:	9c a5       	ldd	r25, Y+44	; 0x2c
    64a2:	01 97       	sbiw	r24, 0x01	; 1
    64a4:	f1 f7       	brne	.-4      	; 0x64a2 <move_x_first+0x3f4>
    64a6:	9c a7       	std	Y+44, r25	; 0x2c
    64a8:	8b a7       	std	Y+43, r24	; 0x2b
	{
		_delay_ms(40);
		velocity(115,125);
    64aa:	83 e7       	ldi	r24, 0x73	; 115
    64ac:	6d e7       	ldi	r22, 0x7D	; 125
    64ae:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
		forward_mm(45);  //adjusting the position of robot
    64b2:	8d e2       	ldi	r24, 0x2D	; 45
    64b4:	90 e0       	ldi	r25, 0x00	; 0
    64b6:	0e 94 46 2b 	call	0x568c	; 0x568c <forward_mm>
    64ba:	80 e0       	ldi	r24, 0x00	; 0
    64bc:	90 e0       	ldi	r25, 0x00	; 0
    64be:	a0 ea       	ldi	r26, 0xA0	; 160
    64c0:	b1 e4       	ldi	r27, 0x41	; 65
    64c2:	8f a3       	std	Y+39, r24	; 0x27
    64c4:	98 a7       	std	Y+40, r25	; 0x28
    64c6:	a9 a7       	std	Y+41, r26	; 0x29
    64c8:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    64ca:	6f a1       	ldd	r22, Y+39	; 0x27
    64cc:	78 a5       	ldd	r23, Y+40	; 0x28
    64ce:	89 a5       	ldd	r24, Y+41	; 0x29
    64d0:	9a a5       	ldd	r25, Y+42	; 0x2a
    64d2:	26 e6       	ldi	r18, 0x66	; 102
    64d4:	36 e6       	ldi	r19, 0x66	; 102
    64d6:	46 e6       	ldi	r20, 0x66	; 102
    64d8:	55 e4       	ldi	r21, 0x45	; 69
    64da:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    64de:	dc 01       	movw	r26, r24
    64e0:	cb 01       	movw	r24, r22
    64e2:	8b a3       	std	Y+35, r24	; 0x23
    64e4:	9c a3       	std	Y+36, r25	; 0x24
    64e6:	ad a3       	std	Y+37, r26	; 0x25
    64e8:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    64ea:	6b a1       	ldd	r22, Y+35	; 0x23
    64ec:	7c a1       	ldd	r23, Y+36	; 0x24
    64ee:	8d a1       	ldd	r24, Y+37	; 0x25
    64f0:	9e a1       	ldd	r25, Y+38	; 0x26
    64f2:	20 e0       	ldi	r18, 0x00	; 0
    64f4:	30 e0       	ldi	r19, 0x00	; 0
    64f6:	40 e8       	ldi	r20, 0x80	; 128
    64f8:	5f e3       	ldi	r21, 0x3F	; 63
    64fa:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    64fe:	88 23       	and	r24, r24
    6500:	2c f4       	brge	.+10     	; 0x650c <move_x_first+0x45e>
		__ticks = 1;
    6502:	81 e0       	ldi	r24, 0x01	; 1
    6504:	90 e0       	ldi	r25, 0x00	; 0
    6506:	9a a3       	std	Y+34, r25	; 0x22
    6508:	89 a3       	std	Y+33, r24	; 0x21
    650a:	3f c0       	rjmp	.+126    	; 0x658a <move_x_first+0x4dc>
	else if (__tmp > 65535)
    650c:	6b a1       	ldd	r22, Y+35	; 0x23
    650e:	7c a1       	ldd	r23, Y+36	; 0x24
    6510:	8d a1       	ldd	r24, Y+37	; 0x25
    6512:	9e a1       	ldd	r25, Y+38	; 0x26
    6514:	20 e0       	ldi	r18, 0x00	; 0
    6516:	3f ef       	ldi	r19, 0xFF	; 255
    6518:	4f e7       	ldi	r20, 0x7F	; 127
    651a:	57 e4       	ldi	r21, 0x47	; 71
    651c:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    6520:	18 16       	cp	r1, r24
    6522:	4c f5       	brge	.+82     	; 0x6576 <move_x_first+0x4c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6524:	6f a1       	ldd	r22, Y+39	; 0x27
    6526:	78 a5       	ldd	r23, Y+40	; 0x28
    6528:	89 a5       	ldd	r24, Y+41	; 0x29
    652a:	9a a5       	ldd	r25, Y+42	; 0x2a
    652c:	20 e0       	ldi	r18, 0x00	; 0
    652e:	30 e0       	ldi	r19, 0x00	; 0
    6530:	40 e2       	ldi	r20, 0x20	; 32
    6532:	51 e4       	ldi	r21, 0x41	; 65
    6534:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6538:	dc 01       	movw	r26, r24
    653a:	cb 01       	movw	r24, r22
    653c:	bc 01       	movw	r22, r24
    653e:	cd 01       	movw	r24, r26
    6540:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    6544:	dc 01       	movw	r26, r24
    6546:	cb 01       	movw	r24, r22
    6548:	9a a3       	std	Y+34, r25	; 0x22
    654a:	89 a3       	std	Y+33, r24	; 0x21
    654c:	0f c0       	rjmp	.+30     	; 0x656c <move_x_first+0x4be>
    654e:	80 e7       	ldi	r24, 0x70	; 112
    6550:	91 e0       	ldi	r25, 0x01	; 1
    6552:	98 a3       	std	Y+32, r25	; 0x20
    6554:	8f 8f       	std	Y+31, r24	; 0x1f
    6556:	8f 8d       	ldd	r24, Y+31	; 0x1f
    6558:	98 a1       	ldd	r25, Y+32	; 0x20
    655a:	01 97       	sbiw	r24, 0x01	; 1
    655c:	f1 f7       	brne	.-4      	; 0x655a <move_x_first+0x4ac>
    655e:	98 a3       	std	Y+32, r25	; 0x20
    6560:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6562:	89 a1       	ldd	r24, Y+33	; 0x21
    6564:	9a a1       	ldd	r25, Y+34	; 0x22
    6566:	01 97       	sbiw	r24, 0x01	; 1
    6568:	9a a3       	std	Y+34, r25	; 0x22
    656a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    656c:	89 a1       	ldd	r24, Y+33	; 0x21
    656e:	9a a1       	ldd	r25, Y+34	; 0x22
    6570:	00 97       	sbiw	r24, 0x00	; 0
    6572:	69 f7       	brne	.-38     	; 0x654e <move_x_first+0x4a0>
    6574:	14 c0       	rjmp	.+40     	; 0x659e <move_x_first+0x4f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6576:	6b a1       	ldd	r22, Y+35	; 0x23
    6578:	7c a1       	ldd	r23, Y+36	; 0x24
    657a:	8d a1       	ldd	r24, Y+37	; 0x25
    657c:	9e a1       	ldd	r25, Y+38	; 0x26
    657e:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    6582:	dc 01       	movw	r26, r24
    6584:	cb 01       	movw	r24, r22
    6586:	9a a3       	std	Y+34, r25	; 0x22
    6588:	89 a3       	std	Y+33, r24	; 0x21
    658a:	89 a1       	ldd	r24, Y+33	; 0x21
    658c:	9a a1       	ldd	r25, Y+34	; 0x22
    658e:	9e 8f       	std	Y+30, r25	; 0x1e
    6590:	8d 8f       	std	Y+29, r24	; 0x1d
    6592:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6594:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6596:	01 97       	sbiw	r24, 0x01	; 1
    6598:	f1 f7       	brne	.-4      	; 0x6596 <move_x_first+0x4e8>
    659a:	9e 8f       	std	Y+30, r25	; 0x1e
    659c:	8d 8f       	std	Y+29, r24	; 0x1d
		_delay_ms(20);
		if(move_in_y_dir > 0)
    659e:	fe 01       	movw	r30, r28
    65a0:	e9 5b       	subi	r30, 0xB9	; 185
    65a2:	ff 4f       	sbci	r31, 0xFF	; 255
    65a4:	80 81       	ld	r24, Z
    65a6:	91 81       	ldd	r25, Z+1	; 0x01
    65a8:	18 16       	cp	r1, r24
    65aa:	19 06       	cpc	r1, r25
    65ac:	0c f0       	brlt	.+2      	; 0x65b0 <move_x_first+0x502>
    65ae:	cd c0       	rjmp	.+410    	; 0x674a <move_x_first+0x69c>
		{
			if(bot_dir==S)
    65b0:	80 91 00 02 	lds	r24, 0x0200
    65b4:	83 30       	cpi	r24, 0x03	; 3
    65b6:	41 f4       	brne	.+16     	; 0x65c8 <move_x_first+0x51a>
			{
				left_degrees(180);
    65b8:	84 eb       	ldi	r24, 0xB4	; 180
    65ba:	90 e0       	ldi	r25, 0x00	; 0
    65bc:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
				bot_dir=N;
    65c0:	81 e0       	ldi	r24, 0x01	; 1
    65c2:	80 93 00 02 	sts	0x0200, r24
    65c6:	17 c0       	rjmp	.+46     	; 0x65f6 <move_x_first+0x548>
			}
			else if(bot_dir==E)
    65c8:	80 91 00 02 	lds	r24, 0x0200
    65cc:	84 30       	cpi	r24, 0x04	; 4
    65ce:	41 f4       	brne	.+16     	; 0x65e0 <move_x_first+0x532>
			{
				
				left_degrees(102);
    65d0:	86 e6       	ldi	r24, 0x66	; 102
    65d2:	90 e0       	ldi	r25, 0x00	; 0
    65d4:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
				bot_dir=N;
    65d8:	81 e0       	ldi	r24, 0x01	; 1
    65da:	80 93 00 02 	sts	0x0200, r24
    65de:	0b c0       	rjmp	.+22     	; 0x65f6 <move_x_first+0x548>
			}
			else if(bot_dir==W)
    65e0:	80 91 00 02 	lds	r24, 0x0200
    65e4:	82 30       	cpi	r24, 0x02	; 2
    65e6:	39 f4       	brne	.+14     	; 0x65f6 <move_x_first+0x548>
			{
				right_degrees(102);
    65e8:	86 e6       	ldi	r24, 0x66	; 102
    65ea:	90 e0       	ldi	r25, 0x00	; 0
    65ec:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
				bot_dir=N;
    65f0:	81 e0       	ldi	r24, 0x01	; 1
    65f2:	80 93 00 02 	sts	0x0200, r24
			}
		
			while(1)
			{
				black_line_follower();
    65f6:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)  
    65fa:	80 91 cc 03 	lds	r24, 0x03CC
    65fe:	8e 31       	cpi	r24, 0x1E	; 30
    6600:	f0 f0       	brcs	.+60     	; 0x663e <move_x_first+0x590>
    6602:	80 91 cb 03 	lds	r24, 0x03CB
    6606:	8e 31       	cpi	r24, 0x1E	; 30
    6608:	d0 f0       	brcs	.+52     	; 0x663e <move_x_first+0x590>
    660a:	80 91 cd 03 	lds	r24, 0x03CD
    660e:	8e 31       	cpi	r24, 0x1E	; 30
    6610:	b0 f0       	brcs	.+44     	; 0x663e <move_x_first+0x590>
				{
					while(1)
					{
						black_line_follower();
    6612:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
						if(Left_white_line <30 || Right_white_line < 30 )
    6616:	80 91 cb 03 	lds	r24, 0x03CB
    661a:	8e 31       	cpi	r24, 0x1E	; 30
    661c:	20 f0       	brcs	.+8      	; 0x6626 <move_x_first+0x578>
    661e:	80 91 cd 03 	lds	r24, 0x03CD
    6622:	8e 31       	cpi	r24, 0x1E	; 30
    6624:	b0 f7       	brcc	.-20     	; 0x6612 <move_x_first+0x564>
						{
							move_in_y_dir--;
    6626:	de 01       	movw	r26, r28
    6628:	a9 5b       	subi	r26, 0xB9	; 185
    662a:	bf 4f       	sbci	r27, 0xFF	; 255
    662c:	fe 01       	movw	r30, r28
    662e:	e9 5b       	subi	r30, 0xB9	; 185
    6630:	ff 4f       	sbci	r31, 0xFF	; 255
    6632:	80 81       	ld	r24, Z
    6634:	91 81       	ldd	r25, Z+1	; 0x01
    6636:	01 97       	sbiw	r24, 0x01	; 1
    6638:	11 96       	adiw	r26, 0x01	; 1
    663a:	9c 93       	st	X, r25
    663c:	8e 93       	st	-X, r24
							
							break;
						}
					}
				}
				if(move_in_y_dir==-1)
    663e:	fe 01       	movw	r30, r28
    6640:	e9 5b       	subi	r30, 0xB9	; 185
    6642:	ff 4f       	sbci	r31, 0xFF	; 255
    6644:	80 81       	ld	r24, Z
    6646:	91 81       	ldd	r25, Z+1	; 0x01
    6648:	2f ef       	ldi	r18, 0xFF	; 255
    664a:	8f 3f       	cpi	r24, 0xFF	; 255
    664c:	92 07       	cpc	r25, r18
    664e:	99 f6       	brne	.-90     	; 0x65f6 <move_x_first+0x548>
				{
					stop();
    6650:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
					velocity(115,125);
    6654:	83 e7       	ldi	r24, 0x73	; 115
    6656:	6d e7       	ldi	r22, 0x7D	; 125
    6658:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
					back_mm(75);
    665c:	8b e4       	ldi	r24, 0x4B	; 75
    665e:	90 e0       	ldi	r25, 0x00	; 0
    6660:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <back_mm>
    6664:	80 e0       	ldi	r24, 0x00	; 0
    6666:	90 e0       	ldi	r25, 0x00	; 0
    6668:	a8 ec       	ldi	r26, 0xC8	; 200
    666a:	b2 e4       	ldi	r27, 0x42	; 66
    666c:	89 8f       	std	Y+25, r24	; 0x19
    666e:	9a 8f       	std	Y+26, r25	; 0x1a
    6670:	ab 8f       	std	Y+27, r26	; 0x1b
    6672:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6674:	69 8d       	ldd	r22, Y+25	; 0x19
    6676:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6678:	8b 8d       	ldd	r24, Y+27	; 0x1b
    667a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    667c:	26 e6       	ldi	r18, 0x66	; 102
    667e:	36 e6       	ldi	r19, 0x66	; 102
    6680:	46 e6       	ldi	r20, 0x66	; 102
    6682:	55 e4       	ldi	r21, 0x45	; 69
    6684:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6688:	dc 01       	movw	r26, r24
    668a:	cb 01       	movw	r24, r22
    668c:	8d 8b       	std	Y+21, r24	; 0x15
    668e:	9e 8b       	std	Y+22, r25	; 0x16
    6690:	af 8b       	std	Y+23, r26	; 0x17
    6692:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    6694:	6d 89       	ldd	r22, Y+21	; 0x15
    6696:	7e 89       	ldd	r23, Y+22	; 0x16
    6698:	8f 89       	ldd	r24, Y+23	; 0x17
    669a:	98 8d       	ldd	r25, Y+24	; 0x18
    669c:	20 e0       	ldi	r18, 0x00	; 0
    669e:	30 e0       	ldi	r19, 0x00	; 0
    66a0:	40 e8       	ldi	r20, 0x80	; 128
    66a2:	5f e3       	ldi	r21, 0x3F	; 63
    66a4:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    66a8:	88 23       	and	r24, r24
    66aa:	2c f4       	brge	.+10     	; 0x66b6 <move_x_first+0x608>
		__ticks = 1;
    66ac:	81 e0       	ldi	r24, 0x01	; 1
    66ae:	90 e0       	ldi	r25, 0x00	; 0
    66b0:	9c 8b       	std	Y+20, r25	; 0x14
    66b2:	8b 8b       	std	Y+19, r24	; 0x13
    66b4:	3f c0       	rjmp	.+126    	; 0x6734 <move_x_first+0x686>
	else if (__tmp > 65535)
    66b6:	6d 89       	ldd	r22, Y+21	; 0x15
    66b8:	7e 89       	ldd	r23, Y+22	; 0x16
    66ba:	8f 89       	ldd	r24, Y+23	; 0x17
    66bc:	98 8d       	ldd	r25, Y+24	; 0x18
    66be:	20 e0       	ldi	r18, 0x00	; 0
    66c0:	3f ef       	ldi	r19, 0xFF	; 255
    66c2:	4f e7       	ldi	r20, 0x7F	; 127
    66c4:	57 e4       	ldi	r21, 0x47	; 71
    66c6:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    66ca:	18 16       	cp	r1, r24
    66cc:	4c f5       	brge	.+82     	; 0x6720 <move_x_first+0x672>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    66ce:	69 8d       	ldd	r22, Y+25	; 0x19
    66d0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    66d2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    66d4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    66d6:	20 e0       	ldi	r18, 0x00	; 0
    66d8:	30 e0       	ldi	r19, 0x00	; 0
    66da:	40 e2       	ldi	r20, 0x20	; 32
    66dc:	51 e4       	ldi	r21, 0x41	; 65
    66de:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    66e2:	dc 01       	movw	r26, r24
    66e4:	cb 01       	movw	r24, r22
    66e6:	bc 01       	movw	r22, r24
    66e8:	cd 01       	movw	r24, r26
    66ea:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    66ee:	dc 01       	movw	r26, r24
    66f0:	cb 01       	movw	r24, r22
    66f2:	9c 8b       	std	Y+20, r25	; 0x14
    66f4:	8b 8b       	std	Y+19, r24	; 0x13
    66f6:	0f c0       	rjmp	.+30     	; 0x6716 <move_x_first+0x668>
    66f8:	80 e7       	ldi	r24, 0x70	; 112
    66fa:	91 e0       	ldi	r25, 0x01	; 1
    66fc:	9a 8b       	std	Y+18, r25	; 0x12
    66fe:	89 8b       	std	Y+17, r24	; 0x11
    6700:	89 89       	ldd	r24, Y+17	; 0x11
    6702:	9a 89       	ldd	r25, Y+18	; 0x12
    6704:	01 97       	sbiw	r24, 0x01	; 1
    6706:	f1 f7       	brne	.-4      	; 0x6704 <move_x_first+0x656>
    6708:	9a 8b       	std	Y+18, r25	; 0x12
    670a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    670c:	8b 89       	ldd	r24, Y+19	; 0x13
    670e:	9c 89       	ldd	r25, Y+20	; 0x14
    6710:	01 97       	sbiw	r24, 0x01	; 1
    6712:	9c 8b       	std	Y+20, r25	; 0x14
    6714:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6716:	8b 89       	ldd	r24, Y+19	; 0x13
    6718:	9c 89       	ldd	r25, Y+20	; 0x14
    671a:	00 97       	sbiw	r24, 0x00	; 0
    671c:	69 f7       	brne	.-38     	; 0x66f8 <move_x_first+0x64a>
    671e:	f2 c0       	rjmp	.+484    	; 0x6904 <move_x_first+0x856>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6720:	6d 89       	ldd	r22, Y+21	; 0x15
    6722:	7e 89       	ldd	r23, Y+22	; 0x16
    6724:	8f 89       	ldd	r24, Y+23	; 0x17
    6726:	98 8d       	ldd	r25, Y+24	; 0x18
    6728:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    672c:	dc 01       	movw	r26, r24
    672e:	cb 01       	movw	r24, r22
    6730:	9c 8b       	std	Y+20, r25	; 0x14
    6732:	8b 8b       	std	Y+19, r24	; 0x13
    6734:	8b 89       	ldd	r24, Y+19	; 0x13
    6736:	9c 89       	ldd	r25, Y+20	; 0x14
    6738:	98 8b       	std	Y+16, r25	; 0x10
    673a:	8f 87       	std	Y+15, r24	; 0x0f
    673c:	8f 85       	ldd	r24, Y+15	; 0x0f
    673e:	98 89       	ldd	r25, Y+16	; 0x10
    6740:	01 97       	sbiw	r24, 0x01	; 1
    6742:	f1 f7       	brne	.-4      	; 0x6740 <move_x_first+0x692>
    6744:	98 8b       	std	Y+16, r25	; 0x10
    6746:	8f 87       	std	Y+15, r24	; 0x0f
    6748:	dd c0       	rjmp	.+442    	; 0x6904 <move_x_first+0x856>
		}
		else
		{
			
			
			if(bot_dir==N)
    674a:	80 91 00 02 	lds	r24, 0x0200
    674e:	81 30       	cpi	r24, 0x01	; 1
    6750:	29 f4       	brne	.+10     	; 0x675c <move_x_first+0x6ae>
			{
				left_degrees(180);
    6752:	84 eb       	ldi	r24, 0xB4	; 180
    6754:	90 e0       	ldi	r25, 0x00	; 0
    6756:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
    675a:	11 c0       	rjmp	.+34     	; 0x677e <move_x_first+0x6d0>
			}
			else if(bot_dir==E)
    675c:	80 91 00 02 	lds	r24, 0x0200
    6760:	84 30       	cpi	r24, 0x04	; 4
    6762:	29 f4       	brne	.+10     	; 0x676e <move_x_first+0x6c0>
			{
				right_degrees(102);
    6764:	86 e6       	ldi	r24, 0x66	; 102
    6766:	90 e0       	ldi	r25, 0x00	; 0
    6768:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
    676c:	08 c0       	rjmp	.+16     	; 0x677e <move_x_first+0x6d0>
			}
			else if(bot_dir==W)
    676e:	80 91 00 02 	lds	r24, 0x0200
    6772:	82 30       	cpi	r24, 0x02	; 2
    6774:	21 f4       	brne	.+8      	; 0x677e <move_x_first+0x6d0>
			{
				right_degrees(102);
    6776:	86 e6       	ldi	r24, 0x66	; 102
    6778:	90 e0       	ldi	r25, 0x00	; 0
    677a:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <right_degrees>
			}

			bot_dir=S;  // S for south
    677e:	83 e0       	ldi	r24, 0x03	; 3
    6780:	80 93 00 02 	sts	0x0200, r24
			while(1)
			{
				black_line_follower(); 
    6784:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)  
    6788:	80 91 cc 03 	lds	r24, 0x03CC
    678c:	8e 31       	cpi	r24, 0x1E	; 30
    678e:	f0 f0       	brcs	.+60     	; 0x67cc <move_x_first+0x71e>
    6790:	80 91 cb 03 	lds	r24, 0x03CB
    6794:	8e 31       	cpi	r24, 0x1E	; 30
    6796:	d0 f0       	brcs	.+52     	; 0x67cc <move_x_first+0x71e>
    6798:	80 91 cd 03 	lds	r24, 0x03CD
    679c:	8e 31       	cpi	r24, 0x1E	; 30
    679e:	b0 f0       	brcs	.+44     	; 0x67cc <move_x_first+0x71e>
				{
					while(1)
					{
						black_line_follower(); 
    67a0:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
						if(Left_white_line <30 || Right_white_line < 30)
    67a4:	80 91 cb 03 	lds	r24, 0x03CB
    67a8:	8e 31       	cpi	r24, 0x1E	; 30
    67aa:	20 f0       	brcs	.+8      	; 0x67b4 <move_x_first+0x706>
    67ac:	80 91 cd 03 	lds	r24, 0x03CD
    67b0:	8e 31       	cpi	r24, 0x1E	; 30
    67b2:	b0 f7       	brcc	.-20     	; 0x67a0 <move_x_first+0x6f2>
						{
							move_in_y_dir++;
    67b4:	de 01       	movw	r26, r28
    67b6:	a9 5b       	subi	r26, 0xB9	; 185
    67b8:	bf 4f       	sbci	r27, 0xFF	; 255
    67ba:	fe 01       	movw	r30, r28
    67bc:	e9 5b       	subi	r30, 0xB9	; 185
    67be:	ff 4f       	sbci	r31, 0xFF	; 255
    67c0:	80 81       	ld	r24, Z
    67c2:	91 81       	ldd	r25, Z+1	; 0x01
    67c4:	01 96       	adiw	r24, 0x01	; 1
    67c6:	11 96       	adiw	r26, 0x01	; 1
    67c8:	9c 93       	st	X, r25
    67ca:	8e 93       	st	-X, r24
							
							break;
						}
					}
				}
				if(move_in_y_dir==1)
    67cc:	fe 01       	movw	r30, r28
    67ce:	e9 5b       	subi	r30, 0xB9	; 185
    67d0:	ff 4f       	sbci	r31, 0xFF	; 255
    67d2:	80 81       	ld	r24, Z
    67d4:	91 81       	ldd	r25, Z+1	; 0x01
    67d6:	81 30       	cpi	r24, 0x01	; 1
    67d8:	91 05       	cpc	r25, r1
    67da:	a1 f6       	brne	.-88     	; 0x6784 <move_x_first+0x6d6>
				{
					stop();
    67dc:	0e 94 0d 2a 	call	0x541a	; 0x541a <stop>
					velocity(115,125);
    67e0:	83 e7       	ldi	r24, 0x73	; 115
    67e2:	6d e7       	ldi	r22, 0x7D	; 125
    67e4:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
					back_mm(75);
    67e8:	8b e4       	ldi	r24, 0x4B	; 75
    67ea:	90 e0       	ldi	r25, 0x00	; 0
    67ec:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <back_mm>
    67f0:	89 c0       	rjmp	.+274    	; 0x6904 <move_x_first+0x856>
				}
			}
		}
	}
	//  if robot moved in X direction but not Y direction then executed
	else if((x2-x1)!=0)
    67f2:	fe 01       	movw	r30, r28
    67f4:	e1 5b       	subi	r30, 0xB1	; 177
    67f6:	ff 4f       	sbci	r31, 0xFF	; 255
    67f8:	de 01       	movw	r26, r28
    67fa:	a5 5b       	subi	r26, 0xB5	; 181
    67fc:	bf 4f       	sbci	r27, 0xFF	; 255
    67fe:	20 81       	ld	r18, Z
    6800:	31 81       	ldd	r19, Z+1	; 0x01
    6802:	8d 91       	ld	r24, X+
    6804:	9c 91       	ld	r25, X
    6806:	11 97       	sbiw	r26, 0x01	; 1
    6808:	28 17       	cp	r18, r24
    680a:	39 07       	cpc	r19, r25
    680c:	09 f4       	brne	.+2      	; 0x6810 <move_x_first+0x762>
    680e:	7a c0       	rjmp	.+244    	; 0x6904 <move_x_first+0x856>
    6810:	80 e0       	ldi	r24, 0x00	; 0
    6812:	90 e0       	ldi	r25, 0x00	; 0
    6814:	a0 ea       	ldi	r26, 0xA0	; 160
    6816:	b1 e4       	ldi	r27, 0x41	; 65
    6818:	8b 87       	std	Y+11, r24	; 0x0b
    681a:	9c 87       	std	Y+12, r25	; 0x0c
    681c:	ad 87       	std	Y+13, r26	; 0x0d
    681e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6820:	6b 85       	ldd	r22, Y+11	; 0x0b
    6822:	7c 85       	ldd	r23, Y+12	; 0x0c
    6824:	8d 85       	ldd	r24, Y+13	; 0x0d
    6826:	9e 85       	ldd	r25, Y+14	; 0x0e
    6828:	26 e6       	ldi	r18, 0x66	; 102
    682a:	36 e6       	ldi	r19, 0x66	; 102
    682c:	46 e6       	ldi	r20, 0x66	; 102
    682e:	55 e4       	ldi	r21, 0x45	; 69
    6830:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6834:	dc 01       	movw	r26, r24
    6836:	cb 01       	movw	r24, r22
    6838:	8f 83       	std	Y+7, r24	; 0x07
    683a:	98 87       	std	Y+8, r25	; 0x08
    683c:	a9 87       	std	Y+9, r26	; 0x09
    683e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6840:	6f 81       	ldd	r22, Y+7	; 0x07
    6842:	78 85       	ldd	r23, Y+8	; 0x08
    6844:	89 85       	ldd	r24, Y+9	; 0x09
    6846:	9a 85       	ldd	r25, Y+10	; 0x0a
    6848:	20 e0       	ldi	r18, 0x00	; 0
    684a:	30 e0       	ldi	r19, 0x00	; 0
    684c:	40 e8       	ldi	r20, 0x80	; 128
    684e:	5f e3       	ldi	r21, 0x3F	; 63
    6850:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    6854:	88 23       	and	r24, r24
    6856:	2c f4       	brge	.+10     	; 0x6862 <move_x_first+0x7b4>
		__ticks = 1;
    6858:	81 e0       	ldi	r24, 0x01	; 1
    685a:	90 e0       	ldi	r25, 0x00	; 0
    685c:	9e 83       	std	Y+6, r25	; 0x06
    685e:	8d 83       	std	Y+5, r24	; 0x05
    6860:	3f c0       	rjmp	.+126    	; 0x68e0 <move_x_first+0x832>
	else if (__tmp > 65535)
    6862:	6f 81       	ldd	r22, Y+7	; 0x07
    6864:	78 85       	ldd	r23, Y+8	; 0x08
    6866:	89 85       	ldd	r24, Y+9	; 0x09
    6868:	9a 85       	ldd	r25, Y+10	; 0x0a
    686a:	20 e0       	ldi	r18, 0x00	; 0
    686c:	3f ef       	ldi	r19, 0xFF	; 255
    686e:	4f e7       	ldi	r20, 0x7F	; 127
    6870:	57 e4       	ldi	r21, 0x47	; 71
    6872:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    6876:	18 16       	cp	r1, r24
    6878:	4c f5       	brge	.+82     	; 0x68cc <move_x_first+0x81e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    687a:	6b 85       	ldd	r22, Y+11	; 0x0b
    687c:	7c 85       	ldd	r23, Y+12	; 0x0c
    687e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6880:	9e 85       	ldd	r25, Y+14	; 0x0e
    6882:	20 e0       	ldi	r18, 0x00	; 0
    6884:	30 e0       	ldi	r19, 0x00	; 0
    6886:	40 e2       	ldi	r20, 0x20	; 32
    6888:	51 e4       	ldi	r21, 0x41	; 65
    688a:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    688e:	dc 01       	movw	r26, r24
    6890:	cb 01       	movw	r24, r22
    6892:	bc 01       	movw	r22, r24
    6894:	cd 01       	movw	r24, r26
    6896:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    689a:	dc 01       	movw	r26, r24
    689c:	cb 01       	movw	r24, r22
    689e:	9e 83       	std	Y+6, r25	; 0x06
    68a0:	8d 83       	std	Y+5, r24	; 0x05
    68a2:	0f c0       	rjmp	.+30     	; 0x68c2 <move_x_first+0x814>
    68a4:	80 e7       	ldi	r24, 0x70	; 112
    68a6:	91 e0       	ldi	r25, 0x01	; 1
    68a8:	9c 83       	std	Y+4, r25	; 0x04
    68aa:	8b 83       	std	Y+3, r24	; 0x03
    68ac:	8b 81       	ldd	r24, Y+3	; 0x03
    68ae:	9c 81       	ldd	r25, Y+4	; 0x04
    68b0:	01 97       	sbiw	r24, 0x01	; 1
    68b2:	f1 f7       	brne	.-4      	; 0x68b0 <move_x_first+0x802>
    68b4:	9c 83       	std	Y+4, r25	; 0x04
    68b6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    68b8:	8d 81       	ldd	r24, Y+5	; 0x05
    68ba:	9e 81       	ldd	r25, Y+6	; 0x06
    68bc:	01 97       	sbiw	r24, 0x01	; 1
    68be:	9e 83       	std	Y+6, r25	; 0x06
    68c0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    68c2:	8d 81       	ldd	r24, Y+5	; 0x05
    68c4:	9e 81       	ldd	r25, Y+6	; 0x06
    68c6:	00 97       	sbiw	r24, 0x00	; 0
    68c8:	69 f7       	brne	.-38     	; 0x68a4 <move_x_first+0x7f6>
    68ca:	14 c0       	rjmp	.+40     	; 0x68f4 <move_x_first+0x846>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    68cc:	6f 81       	ldd	r22, Y+7	; 0x07
    68ce:	78 85       	ldd	r23, Y+8	; 0x08
    68d0:	89 85       	ldd	r24, Y+9	; 0x09
    68d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    68d4:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    68d8:	dc 01       	movw	r26, r24
    68da:	cb 01       	movw	r24, r22
    68dc:	9e 83       	std	Y+6, r25	; 0x06
    68de:	8d 83       	std	Y+5, r24	; 0x05
    68e0:	8d 81       	ldd	r24, Y+5	; 0x05
    68e2:	9e 81       	ldd	r25, Y+6	; 0x06
    68e4:	9a 83       	std	Y+2, r25	; 0x02
    68e6:	89 83       	std	Y+1, r24	; 0x01
    68e8:	89 81       	ldd	r24, Y+1	; 0x01
    68ea:	9a 81       	ldd	r25, Y+2	; 0x02
    68ec:	01 97       	sbiw	r24, 0x01	; 1
    68ee:	f1 f7       	brne	.-4      	; 0x68ec <move_x_first+0x83e>
    68f0:	9a 83       	std	Y+2, r25	; 0x02
    68f2:	89 83       	std	Y+1, r24	; 0x01
	{
		_delay_ms(20);
		
		velocity(115,125);
    68f4:	83 e7       	ldi	r24, 0x73	; 115
    68f6:	6d e7       	ldi	r22, 0x7D	; 125
    68f8:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
		
		back_mm(75);
    68fc:	8b e4       	ldi	r24, 0x4B	; 75
    68fe:	90 e0       	ldi	r25, 0x00	; 0
    6900:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <back_mm>
		
	}
}
    6904:	ce 5a       	subi	r28, 0xAE	; 174
    6906:	df 4f       	sbci	r29, 0xFF	; 255
    6908:	0f b6       	in	r0, 0x3f	; 63
    690a:	f8 94       	cli
    690c:	de bf       	out	0x3e, r29	; 62
    690e:	0f be       	out	0x3f, r0	; 63
    6910:	cd bf       	out	0x3d, r28	; 61
    6912:	cf 91       	pop	r28
    6914:	df 91       	pop	r29
    6916:	1f 91       	pop	r17
    6918:	0f 91       	pop	r16
    691a:	08 95       	ret

0000691c <Select_font>:
* Logic: 			selects the fonts from deposit.h file include with "glcd.c" library
* Example Call:		Select_font(5);
*
*/
uint8_t *Select_font(int font)
{
    691c:	df 93       	push	r29
    691e:	cf 93       	push	r28
    6920:	00 d0       	rcall	.+0      	; 0x6922 <Select_font+0x6>
    6922:	00 d0       	rcall	.+0      	; 0x6924 <Select_font+0x8>
    6924:	cd b7       	in	r28, 0x3d	; 61
    6926:	de b7       	in	r29, 0x3e	; 62
    6928:	9a 83       	std	Y+2, r25	; 0x02
    692a:	89 83       	std	Y+1, r24	; 0x01
	if(font==0)
    692c:	89 81       	ldd	r24, Y+1	; 0x01
    692e:	9a 81       	ldd	r25, Y+2	; 0x02
    6930:	00 97       	sbiw	r24, 0x00	; 0
    6932:	29 f4       	brne	.+10     	; 0x693e <Select_font+0x22>
		return &font0; // font for number 0
    6934:	84 ee       	ldi	r24, 0xE4	; 228
    6936:	94 e0       	ldi	r25, 0x04	; 4
    6938:	9c 83       	std	Y+4, r25	; 0x04
    693a:	8b 83       	std	Y+3, r24	; 0x03
    693c:	65 c0       	rjmp	.+202    	; 0x6a08 <Select_font+0xec>
	if(font==1)
    693e:	89 81       	ldd	r24, Y+1	; 0x01
    6940:	9a 81       	ldd	r25, Y+2	; 0x02
    6942:	81 30       	cpi	r24, 0x01	; 1
    6944:	91 05       	cpc	r25, r1
    6946:	29 f4       	brne	.+10     	; 0x6952 <Select_font+0x36>
		return &font1; // font for number 1
    6948:	84 ee       	ldi	r24, 0xE4	; 228
    694a:	98 e0       	ldi	r25, 0x08	; 8
    694c:	9c 83       	std	Y+4, r25	; 0x04
    694e:	8b 83       	std	Y+3, r24	; 0x03
    6950:	5b c0       	rjmp	.+182    	; 0x6a08 <Select_font+0xec>
	if(font==2)
    6952:	89 81       	ldd	r24, Y+1	; 0x01
    6954:	9a 81       	ldd	r25, Y+2	; 0x02
    6956:	82 30       	cpi	r24, 0x02	; 2
    6958:	91 05       	cpc	r25, r1
    695a:	29 f4       	brne	.+10     	; 0x6966 <Select_font+0x4a>
		return &font2; // font for number 2
    695c:	84 ee       	ldi	r24, 0xE4	; 228
    695e:	9c e0       	ldi	r25, 0x0C	; 12
    6960:	9c 83       	std	Y+4, r25	; 0x04
    6962:	8b 83       	std	Y+3, r24	; 0x03
    6964:	51 c0       	rjmp	.+162    	; 0x6a08 <Select_font+0xec>
	if(font==3)
    6966:	89 81       	ldd	r24, Y+1	; 0x01
    6968:	9a 81       	ldd	r25, Y+2	; 0x02
    696a:	83 30       	cpi	r24, 0x03	; 3
    696c:	91 05       	cpc	r25, r1
    696e:	29 f4       	brne	.+10     	; 0x697a <Select_font+0x5e>
		return &font3; // font for number 3
    6970:	84 ee       	ldi	r24, 0xE4	; 228
    6972:	90 e1       	ldi	r25, 0x10	; 16
    6974:	9c 83       	std	Y+4, r25	; 0x04
    6976:	8b 83       	std	Y+3, r24	; 0x03
    6978:	47 c0       	rjmp	.+142    	; 0x6a08 <Select_font+0xec>
	if(font==4)
    697a:	89 81       	ldd	r24, Y+1	; 0x01
    697c:	9a 81       	ldd	r25, Y+2	; 0x02
    697e:	84 30       	cpi	r24, 0x04	; 4
    6980:	91 05       	cpc	r25, r1
    6982:	29 f4       	brne	.+10     	; 0x698e <Select_font+0x72>
		return &font4; // font for number 4
    6984:	84 ee       	ldi	r24, 0xE4	; 228
    6986:	94 e1       	ldi	r25, 0x14	; 20
    6988:	9c 83       	std	Y+4, r25	; 0x04
    698a:	8b 83       	std	Y+3, r24	; 0x03
    698c:	3d c0       	rjmp	.+122    	; 0x6a08 <Select_font+0xec>
	if(font==5)
    698e:	89 81       	ldd	r24, Y+1	; 0x01
    6990:	9a 81       	ldd	r25, Y+2	; 0x02
    6992:	85 30       	cpi	r24, 0x05	; 5
    6994:	91 05       	cpc	r25, r1
    6996:	29 f4       	brne	.+10     	; 0x69a2 <Select_font+0x86>
		return &font5; // font for number 5
    6998:	84 ee       	ldi	r24, 0xE4	; 228
    699a:	98 e1       	ldi	r25, 0x18	; 24
    699c:	9c 83       	std	Y+4, r25	; 0x04
    699e:	8b 83       	std	Y+3, r24	; 0x03
    69a0:	33 c0       	rjmp	.+102    	; 0x6a08 <Select_font+0xec>
	if(font==6)
    69a2:	89 81       	ldd	r24, Y+1	; 0x01
    69a4:	9a 81       	ldd	r25, Y+2	; 0x02
    69a6:	86 30       	cpi	r24, 0x06	; 6
    69a8:	91 05       	cpc	r25, r1
    69aa:	29 f4       	brne	.+10     	; 0x69b6 <Select_font+0x9a>
		return &font6; // font for number 6
    69ac:	84 ee       	ldi	r24, 0xE4	; 228
    69ae:	9c e1       	ldi	r25, 0x1C	; 28
    69b0:	9c 83       	std	Y+4, r25	; 0x04
    69b2:	8b 83       	std	Y+3, r24	; 0x03
    69b4:	29 c0       	rjmp	.+82     	; 0x6a08 <Select_font+0xec>
	if(font==7)
    69b6:	89 81       	ldd	r24, Y+1	; 0x01
    69b8:	9a 81       	ldd	r25, Y+2	; 0x02
    69ba:	87 30       	cpi	r24, 0x07	; 7
    69bc:	91 05       	cpc	r25, r1
    69be:	29 f4       	brne	.+10     	; 0x69ca <Select_font+0xae>
		return &font7; // font for number 7
    69c0:	84 ee       	ldi	r24, 0xE4	; 228
    69c2:	90 e2       	ldi	r25, 0x20	; 32
    69c4:	9c 83       	std	Y+4, r25	; 0x04
    69c6:	8b 83       	std	Y+3, r24	; 0x03
    69c8:	1f c0       	rjmp	.+62     	; 0x6a08 <Select_font+0xec>
	if(font==8)
    69ca:	89 81       	ldd	r24, Y+1	; 0x01
    69cc:	9a 81       	ldd	r25, Y+2	; 0x02
    69ce:	88 30       	cpi	r24, 0x08	; 8
    69d0:	91 05       	cpc	r25, r1
    69d2:	29 f4       	brne	.+10     	; 0x69de <Select_font+0xc2>
		return &font8; // font for number 8
    69d4:	84 ee       	ldi	r24, 0xE4	; 228
    69d6:	94 e2       	ldi	r25, 0x24	; 36
    69d8:	9c 83       	std	Y+4, r25	; 0x04
    69da:	8b 83       	std	Y+3, r24	; 0x03
    69dc:	15 c0       	rjmp	.+42     	; 0x6a08 <Select_font+0xec>
	if(font==9)
    69de:	89 81       	ldd	r24, Y+1	; 0x01
    69e0:	9a 81       	ldd	r25, Y+2	; 0x02
    69e2:	89 30       	cpi	r24, 0x09	; 9
    69e4:	91 05       	cpc	r25, r1
    69e6:	29 f4       	brne	.+10     	; 0x69f2 <Select_font+0xd6>
		return &font9; // font for number 9
    69e8:	84 ee       	ldi	r24, 0xE4	; 228
    69ea:	98 e2       	ldi	r25, 0x28	; 40
    69ec:	9c 83       	std	Y+4, r25	; 0x04
    69ee:	8b 83       	std	Y+3, r24	; 0x03
    69f0:	0b c0       	rjmp	.+22     	; 0x6a08 <Select_font+0xec>
	if(font==10)
    69f2:	89 81       	ldd	r24, Y+1	; 0x01
    69f4:	9a 81       	ldd	r25, Y+2	; 0x02
    69f6:	8a 30       	cpi	r24, 0x0A	; 10
    69f8:	91 05       	cpc	r25, r1
    69fa:	29 f4       	brne	.+10     	; 0x6a06 <Select_font+0xea>
		return &Deposit; // font for message "DEPOSITED"
    69fc:	84 ee       	ldi	r24, 0xE4	; 228
    69fe:	90 e0       	ldi	r25, 0x00	; 0
    6a00:	9c 83       	std	Y+4, r25	; 0x04
    6a02:	8b 83       	std	Y+3, r24	; 0x03
    6a04:	01 c0       	rjmp	.+2      	; 0x6a08 <Select_font+0xec>
    6a06:	04 c0       	rjmp	.+8      	; 0x6a10 <Select_font+0xf4>
}
    6a08:	8b 81       	ldd	r24, Y+3	; 0x03
    6a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    6a0c:	9e 83       	std	Y+6, r25	; 0x06
    6a0e:	8d 83       	std	Y+5, r24	; 0x05
    6a10:	8d 81       	ldd	r24, Y+5	; 0x05
    6a12:	9e 81       	ldd	r25, Y+6	; 0x06
    6a14:	26 96       	adiw	r28, 0x06	; 6
    6a16:	0f b6       	in	r0, 0x3f	; 63
    6a18:	f8 94       	cli
    6a1a:	de bf       	out	0x3e, r29	; 62
    6a1c:	0f be       	out	0x3f, r0	; 63
    6a1e:	cd bf       	out	0x3d, r28	; 61
    6a20:	cf 91       	pop	r28
    6a22:	df 91       	pop	r29
    6a24:	08 95       	ret

00006a26 <Glcd_display>:
* Output: 		    none
* Logic: 			Prints the number on GLCD using the data saved in "deposit.h" file in "glcd.c" library.
* Example Call:		Glcd_display(5);
*
*/
int Glcd_display(int font){
    6a26:	df 93       	push	r29
    6a28:	cf 93       	push	r28
    6a2a:	cd b7       	in	r28, 0x3d	; 61
    6a2c:	de b7       	in	r29, 0x3e	; 62
    6a2e:	2e 97       	sbiw	r28, 0x0e	; 14
    6a30:	0f b6       	in	r0, 0x3f	; 63
    6a32:	f8 94       	cli
    6a34:	de bf       	out	0x3e, r29	; 62
    6a36:	0f be       	out	0x3f, r0	; 63
    6a38:	cd bf       	out	0x3d, r28	; 61
    6a3a:	9c 87       	std	Y+12, r25	; 0x0c
    6a3c:	8b 87       	std	Y+11, r24	; 0x0b
	GLCD_Init();
    6a3e:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <GLCD_Init>
	/* ptr1 and ptr2 are pointers to point to arrays of font information stored in "deposit.h" while dat1 
	is used to  read data from where the pointer is pointing.
	*/
	uint8_t line,cursor,*ptr1,*ptr2,dat1;
	ptr1=Select_font(font);
    6a42:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a44:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a46:	0e 94 8e 34 	call	0x691c	; 0x691c <Select_font>
    6a4a:	98 87       	std	Y+8, r25	; 0x08
    6a4c:	8f 83       	std	Y+7, r24	; 0x07
	ptr2=ptr1;
    6a4e:	8f 81       	ldd	r24, Y+7	; 0x07
    6a50:	98 85       	ldd	r25, Y+8	; 0x08
    6a52:	9e 83       	std	Y+6, r25	; 0x06
    6a54:	8d 83       	std	Y+5, r24	; 0x05
    for(line=0;line<8;line++) {
    6a56:	1a 86       	std	Y+10, r1	; 0x0a
    6a58:	2f c0       	rjmp	.+94     	; 0x6ab8 <Glcd_display+0x92>
         GLCD_GoToLine(line);  
    6a5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    6a5c:	0e 94 ed 17 	call	0x2fda	; 0x2fda <GLCD_GoToLine>
        
        for(cursor=0;cursor<128;cursor++){
    6a60:	19 86       	std	Y+9, r1	; 0x09
    6a62:	1b c0       	rjmp	.+54     	; 0x6a9a <Glcd_display+0x74>
            if(cursor==64){
    6a64:	89 85       	ldd	r24, Y+9	; 0x09
    6a66:	80 34       	cpi	r24, 0x40	; 64
    6a68:	19 f4       	brne	.+6      	; 0x6a70 <Glcd_display+0x4a>
                GLCD_GoToPage(1); 
    6a6a:	81 e0       	ldi	r24, 0x01	; 1
    6a6c:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <GLCD_GoToPage>
                
            }
			
			dat1=pgm_read_byte(ptr1);
    6a70:	8f 81       	ldd	r24, Y+7	; 0x07
    6a72:	98 85       	ldd	r25, Y+8	; 0x08
    6a74:	9b 83       	std	Y+3, r25	; 0x03
    6a76:	8a 83       	std	Y+2, r24	; 0x02
    6a78:	ea 81       	ldd	r30, Y+2	; 0x02
    6a7a:	fb 81       	ldd	r31, Y+3	; 0x03
    6a7c:	84 91       	lpm	r24, Z+
    6a7e:	89 83       	std	Y+1, r24	; 0x01
    6a80:	89 81       	ldd	r24, Y+1	; 0x01
    6a82:	8c 83       	std	Y+4, r24	; 0x04
			glcd_DataWrite(dat1);
    6a84:	8c 81       	ldd	r24, Y+4	; 0x04
    6a86:	0e 94 71 19 	call	0x32e2	; 0x32e2 <glcd_DataWrite>
			ptr1=ptr1+8; 
    6a8a:	8f 81       	ldd	r24, Y+7	; 0x07
    6a8c:	98 85       	ldd	r25, Y+8	; 0x08
    6a8e:	08 96       	adiw	r24, 0x08	; 8
    6a90:	98 87       	std	Y+8, r25	; 0x08
    6a92:	8f 83       	std	Y+7, r24	; 0x07
	ptr1=Select_font(font);
	ptr2=ptr1;
    for(line=0;line<8;line++) {
         GLCD_GoToLine(line);  
        
        for(cursor=0;cursor<128;cursor++){
    6a94:	89 85       	ldd	r24, Y+9	; 0x09
    6a96:	8f 5f       	subi	r24, 0xFF	; 255
    6a98:	89 87       	std	Y+9, r24	; 0x09
    6a9a:	89 85       	ldd	r24, Y+9	; 0x09
    6a9c:	88 23       	and	r24, r24
    6a9e:	14 f7       	brge	.-60     	; 0x6a64 <Glcd_display+0x3e>
			
			dat1=pgm_read_byte(ptr1);
			glcd_DataWrite(dat1);
			ptr1=ptr1+8; 
        }
		ptr1=++ptr2;
    6aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    6aa2:	9e 81       	ldd	r25, Y+6	; 0x06
    6aa4:	01 96       	adiw	r24, 0x01	; 1
    6aa6:	9e 83       	std	Y+6, r25	; 0x06
    6aa8:	8d 83       	std	Y+5, r24	; 0x05
    6aaa:	8d 81       	ldd	r24, Y+5	; 0x05
    6aac:	9e 81       	ldd	r25, Y+6	; 0x06
    6aae:	98 87       	std	Y+8, r25	; 0x08
    6ab0:	8f 83       	std	Y+7, r24	; 0x07
	is used to  read data from where the pointer is pointing.
	*/
	uint8_t line,cursor,*ptr1,*ptr2,dat1;
	ptr1=Select_font(font);
	ptr2=ptr1;
    for(line=0;line<8;line++) {
    6ab2:	8a 85       	ldd	r24, Y+10	; 0x0a
    6ab4:	8f 5f       	subi	r24, 0xFF	; 255
    6ab6:	8a 87       	std	Y+10, r24	; 0x0a
    6ab8:	8a 85       	ldd	r24, Y+10	; 0x0a
    6aba:	88 30       	cpi	r24, 0x08	; 8
    6abc:	70 f2       	brcs	.-100    	; 0x6a5a <Glcd_display+0x34>
			ptr1=ptr1+8; 
        }
		ptr1=++ptr2;
	}
	
}
    6abe:	2e 96       	adiw	r28, 0x0e	; 14
    6ac0:	0f b6       	in	r0, 0x3f	; 63
    6ac2:	f8 94       	cli
    6ac4:	de bf       	out	0x3e, r29	; 62
    6ac6:	0f be       	out	0x3f, r0	; 63
    6ac8:	cd bf       	out	0x3d, r28	; 61
    6aca:	cf 91       	pop	r28
    6acc:	df 91       	pop	r29
    6ace:	08 95       	ret

00006ad0 <Led_on>:
* Logic: 			simply "GLOW" the led facing the number that is going to be picked up(displayed on GLCD).Only execute once i.e. when robot picks first number.
* Example Call:		Led_on(4);
*
*/
void Led_on(int pos)
{
    6ad0:	df 93       	push	r29
    6ad2:	cf 93       	push	r28
    6ad4:	0f 92       	push	r0
    6ad6:	0f 92       	push	r0
    6ad8:	cd b7       	in	r28, 0x3d	; 61
    6ada:	de b7       	in	r29, 0x3e	; 62
    6adc:	9a 83       	std	Y+2, r25	; 0x02
    6ade:	89 83       	std	Y+1, r24	; 0x01
	if(pos==0 || pos==1 || pos==4 || pos==5 || pos==8 || pos==9) // led will glow according to which cell no. is being referred
    6ae0:	89 81       	ldd	r24, Y+1	; 0x01
    6ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    6ae4:	00 97       	sbiw	r24, 0x00	; 0
    6ae6:	c9 f0       	breq	.+50     	; 0x6b1a <Led_on+0x4a>
    6ae8:	89 81       	ldd	r24, Y+1	; 0x01
    6aea:	9a 81       	ldd	r25, Y+2	; 0x02
    6aec:	81 30       	cpi	r24, 0x01	; 1
    6aee:	91 05       	cpc	r25, r1
    6af0:	a1 f0       	breq	.+40     	; 0x6b1a <Led_on+0x4a>
    6af2:	89 81       	ldd	r24, Y+1	; 0x01
    6af4:	9a 81       	ldd	r25, Y+2	; 0x02
    6af6:	84 30       	cpi	r24, 0x04	; 4
    6af8:	91 05       	cpc	r25, r1
    6afa:	79 f0       	breq	.+30     	; 0x6b1a <Led_on+0x4a>
    6afc:	89 81       	ldd	r24, Y+1	; 0x01
    6afe:	9a 81       	ldd	r25, Y+2	; 0x02
    6b00:	85 30       	cpi	r24, 0x05	; 5
    6b02:	91 05       	cpc	r25, r1
    6b04:	51 f0       	breq	.+20     	; 0x6b1a <Led_on+0x4a>
    6b06:	89 81       	ldd	r24, Y+1	; 0x01
    6b08:	9a 81       	ldd	r25, Y+2	; 0x02
    6b0a:	88 30       	cpi	r24, 0x08	; 8
    6b0c:	91 05       	cpc	r25, r1
    6b0e:	29 f0       	breq	.+10     	; 0x6b1a <Led_on+0x4a>
    6b10:	89 81       	ldd	r24, Y+1	; 0x01
    6b12:	9a 81       	ldd	r25, Y+2	; 0x02
    6b14:	89 30       	cpi	r24, 0x09	; 9
    6b16:	91 05       	cpc	r25, r1
    6b18:	49 f4       	brne	.+18     	; 0x6b2c <Led_on+0x5c>
	{
		Right_led_on();//right led
    6b1a:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <Right_led_on>
		LED_right=1;
    6b1e:	81 e0       	ldi	r24, 0x01	; 1
    6b20:	90 e0       	ldi	r25, 0x00	; 0
    6b22:	90 93 e1 03 	sts	0x03E1, r25
    6b26:	80 93 e0 03 	sts	0x03E0, r24
    6b2a:	08 c0       	rjmp	.+16     	; 0x6b3c <Led_on+0x6c>
		
	}
	else
	{
		Left_led_on();//left led
    6b2c:	0e 94 ab 26 	call	0x4d56	; 0x4d56 <Left_led_on>
		LED_left=1;
    6b30:	81 e0       	ldi	r24, 0x01	; 1
    6b32:	90 e0       	ldi	r25, 0x00	; 0
    6b34:	90 93 e3 03 	sts	0x03E3, r25
    6b38:	80 93 e2 03 	sts	0x03E2, r24
		
	}
}
    6b3c:	0f 90       	pop	r0
    6b3e:	0f 90       	pop	r0
    6b40:	cf 91       	pop	r28
    6b42:	df 91       	pop	r29
    6b44:	08 95       	ret

00006b46 <Led_on1>:
					to move_y_first algorithm and rest of the numbers picked up from grid 1 are reached using move_x_first algo.
					So robot reaches a cell no. in different position for the same cell no. and hence this function is used.
* Example Call:		Led_on1(6);
*
*/
void Led_on1(int pos){
    6b46:	df 93       	push	r29
    6b48:	cf 93       	push	r28
    6b4a:	0f 92       	push	r0
    6b4c:	0f 92       	push	r0
    6b4e:	cd b7       	in	r28, 0x3d	; 61
    6b50:	de b7       	in	r29, 0x3e	; 62
    6b52:	9a 83       	std	Y+2, r25	; 0x02
    6b54:	89 83       	std	Y+1, r24	; 0x01
	if(pos==1 || pos==3 || pos==4 || pos==5 || pos==6 || pos==7){
    6b56:	89 81       	ldd	r24, Y+1	; 0x01
    6b58:	9a 81       	ldd	r25, Y+2	; 0x02
    6b5a:	81 30       	cpi	r24, 0x01	; 1
    6b5c:	91 05       	cpc	r25, r1
    6b5e:	c9 f0       	breq	.+50     	; 0x6b92 <Led_on1+0x4c>
    6b60:	89 81       	ldd	r24, Y+1	; 0x01
    6b62:	9a 81       	ldd	r25, Y+2	; 0x02
    6b64:	83 30       	cpi	r24, 0x03	; 3
    6b66:	91 05       	cpc	r25, r1
    6b68:	a1 f0       	breq	.+40     	; 0x6b92 <Led_on1+0x4c>
    6b6a:	89 81       	ldd	r24, Y+1	; 0x01
    6b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    6b6e:	84 30       	cpi	r24, 0x04	; 4
    6b70:	91 05       	cpc	r25, r1
    6b72:	79 f0       	breq	.+30     	; 0x6b92 <Led_on1+0x4c>
    6b74:	89 81       	ldd	r24, Y+1	; 0x01
    6b76:	9a 81       	ldd	r25, Y+2	; 0x02
    6b78:	85 30       	cpi	r24, 0x05	; 5
    6b7a:	91 05       	cpc	r25, r1
    6b7c:	51 f0       	breq	.+20     	; 0x6b92 <Led_on1+0x4c>
    6b7e:	89 81       	ldd	r24, Y+1	; 0x01
    6b80:	9a 81       	ldd	r25, Y+2	; 0x02
    6b82:	86 30       	cpi	r24, 0x06	; 6
    6b84:	91 05       	cpc	r25, r1
    6b86:	29 f0       	breq	.+10     	; 0x6b92 <Led_on1+0x4c>
    6b88:	89 81       	ldd	r24, Y+1	; 0x01
    6b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    6b8c:	87 30       	cpi	r24, 0x07	; 7
    6b8e:	91 05       	cpc	r25, r1
    6b90:	49 f4       	brne	.+18     	; 0x6ba4 <Led_on1+0x5e>
		Right_led_on();//right led
    6b92:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <Right_led_on>
		LED_right=1;
    6b96:	81 e0       	ldi	r24, 0x01	; 1
    6b98:	90 e0       	ldi	r25, 0x00	; 0
    6b9a:	90 93 e1 03 	sts	0x03E1, r25
    6b9e:	80 93 e0 03 	sts	0x03E0, r24
    6ba2:	08 c0       	rjmp	.+16     	; 0x6bb4 <Led_on1+0x6e>
	}
	else{
		Left_led_on();//left led
    6ba4:	0e 94 ab 26 	call	0x4d56	; 0x4d56 <Left_led_on>
		LED_left=1;
    6ba8:	81 e0       	ldi	r24, 0x01	; 1
    6baa:	90 e0       	ldi	r25, 0x00	; 0
    6bac:	90 93 e3 03 	sts	0x03E3, r25
    6bb0:	80 93 e2 03 	sts	0x03E2, r24
	}
}
    6bb4:	0f 90       	pop	r0
    6bb6:	0f 90       	pop	r0
    6bb8:	cf 91       	pop	r28
    6bba:	df 91       	pop	r29
    6bbc:	08 95       	ret

00006bbe <about_turn>:
* Logic: 			Called if the robot reaches the target_number in Grid 2 but "glowing led" is not facing that number(glowing led is on opposite side).
					This function will turn the robot such as the led faces the number while deposition is done.
* Example Call:		about_turn();
*
*/
void about_turn() {
    6bbe:	df 93       	push	r29
    6bc0:	cf 93       	push	r28
    6bc2:	cd b7       	in	r28, 0x3d	; 61
    6bc4:	de b7       	in	r29, 0x3e	; 62
    6bc6:	60 97       	sbiw	r28, 0x10	; 16
    6bc8:	0f b6       	in	r0, 0x3f	; 63
    6bca:	f8 94       	cli
    6bcc:	de bf       	out	0x3e, r29	; 62
    6bce:	0f be       	out	0x3f, r0	; 63
    6bd0:	cd bf       	out	0x3d, r28	; 61
	int node=1;      	//robot searches for 1 node in the grid in forward direction,when found node becomes 0 and hence rotation of robot takes place.
    6bd2:	81 e0       	ldi	r24, 0x01	; 1
    6bd4:	90 e0       	ldi	r25, 0x00	; 0
    6bd6:	98 8b       	std	Y+16, r25	; 0x10
    6bd8:	8f 87       	std	Y+15, r24	; 0x0f
	while(1) {
		black_line_follower();
    6bda:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
		if(Center_white_line >=30 && Left_white_line >=30 && Right_white_line >=30)  {
    6bde:	80 91 cc 03 	lds	r24, 0x03CC
    6be2:	8e 31       	cpi	r24, 0x1E	; 30
    6be4:	b8 f0       	brcs	.+46     	; 0x6c14 <about_turn+0x56>
    6be6:	80 91 cb 03 	lds	r24, 0x03CB
    6bea:	8e 31       	cpi	r24, 0x1E	; 30
    6bec:	98 f0       	brcs	.+38     	; 0x6c14 <about_turn+0x56>
    6bee:	80 91 cd 03 	lds	r24, 0x03CD
    6bf2:	8e 31       	cpi	r24, 0x1E	; 30
    6bf4:	78 f0       	brcs	.+30     	; 0x6c14 <about_turn+0x56>
			while(1) {
				black_line_follower(); 
    6bf6:	0e 94 13 2c 	call	0x5826	; 0x5826 <black_line_follower>
				if(Left_white_line <30 || Right_white_line < 30){
    6bfa:	80 91 cb 03 	lds	r24, 0x03CB
    6bfe:	8e 31       	cpi	r24, 0x1E	; 30
    6c00:	20 f0       	brcs	.+8      	; 0x6c0a <about_turn+0x4c>
    6c02:	80 91 cd 03 	lds	r24, 0x03CD
    6c06:	8e 31       	cpi	r24, 0x1E	; 30
    6c08:	b0 f7       	brcc	.-20     	; 0x6bf6 <about_turn+0x38>
					node--;	//node found so decrement node
    6c0a:	8f 85       	ldd	r24, Y+15	; 0x0f
    6c0c:	98 89       	ldd	r25, Y+16	; 0x10
    6c0e:	01 97       	sbiw	r24, 0x01	; 1
    6c10:	98 8b       	std	Y+16, r25	; 0x10
    6c12:	8f 87       	std	Y+15, r24	; 0x0f
					break;
				}
			}
		}
		//if node found then "about turn" the robot.
		if(node==0) {          
    6c14:	8f 85       	ldd	r24, Y+15	; 0x0f
    6c16:	98 89       	ldd	r25, Y+16	; 0x10
    6c18:	00 97       	sbiw	r24, 0x00	; 0
    6c1a:	f9 f6       	brne	.-66     	; 0x6bda <about_turn+0x1c>
			velocity(115,125);//ensuring both wheels have same speed(in our case the two wheels had velocity difference of 10mm/sec so this command will equal their speed)
    6c1c:	83 e7       	ldi	r24, 0x73	; 115
    6c1e:	6d e7       	ldi	r22, 0x7D	; 125
    6c20:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
			forward_mm(20);  //before performing about turn move robot a little forward.(if this is not done,sharp sensor may land up on another node and that may cause problem later)
    6c24:	84 e1       	ldi	r24, 0x14	; 20
    6c26:	90 e0       	ldi	r25, 0x00	; 0
    6c28:	0e 94 46 2b 	call	0x568c	; 0x568c <forward_mm>
			if(bot_dir==N)    
    6c2c:	80 91 00 02 	lds	r24, 0x0200
    6c30:	81 30       	cpi	r24, 0x01	; 1
    6c32:	21 f4       	brne	.+8      	; 0x6c3c <about_turn+0x7e>
				bot_dir=S;
    6c34:	83 e0       	ldi	r24, 0x03	; 3
    6c36:	80 93 00 02 	sts	0x0200, r24
    6c3a:	13 c0       	rjmp	.+38     	; 0x6c62 <about_turn+0xa4>
			else if(bot_dir==S)
    6c3c:	80 91 00 02 	lds	r24, 0x0200
    6c40:	83 30       	cpi	r24, 0x03	; 3
    6c42:	21 f4       	brne	.+8      	; 0x6c4c <about_turn+0x8e>
				bot_dir=N;
    6c44:	81 e0       	ldi	r24, 0x01	; 1
    6c46:	80 93 00 02 	sts	0x0200, r24
    6c4a:	0b c0       	rjmp	.+22     	; 0x6c62 <about_turn+0xa4>
			else if(bot_dir==W)
    6c4c:	80 91 00 02 	lds	r24, 0x0200
    6c50:	82 30       	cpi	r24, 0x02	; 2
    6c52:	21 f4       	brne	.+8      	; 0x6c5c <about_turn+0x9e>
				bot_dir=E;
    6c54:	84 e0       	ldi	r24, 0x04	; 4
    6c56:	80 93 00 02 	sts	0x0200, r24
    6c5a:	03 c0       	rjmp	.+6      	; 0x6c62 <about_turn+0xa4>
			else
				bot_dir=W;
    6c5c:	82 e0       	ldi	r24, 0x02	; 2
    6c5e:	80 93 00 02 	sts	0x0200, r24
    6c62:	80 e0       	ldi	r24, 0x00	; 0
    6c64:	90 e0       	ldi	r25, 0x00	; 0
    6c66:	a0 ea       	ldi	r26, 0xA0	; 160
    6c68:	b1 e4       	ldi	r27, 0x41	; 65
    6c6a:	8b 87       	std	Y+11, r24	; 0x0b
    6c6c:	9c 87       	std	Y+12, r25	; 0x0c
    6c6e:	ad 87       	std	Y+13, r26	; 0x0d
    6c70:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6c72:	6b 85       	ldd	r22, Y+11	; 0x0b
    6c74:	7c 85       	ldd	r23, Y+12	; 0x0c
    6c76:	8d 85       	ldd	r24, Y+13	; 0x0d
    6c78:	9e 85       	ldd	r25, Y+14	; 0x0e
    6c7a:	26 e6       	ldi	r18, 0x66	; 102
    6c7c:	36 e6       	ldi	r19, 0x66	; 102
    6c7e:	46 e6       	ldi	r20, 0x66	; 102
    6c80:	55 e4       	ldi	r21, 0x45	; 69
    6c82:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6c86:	dc 01       	movw	r26, r24
    6c88:	cb 01       	movw	r24, r22
    6c8a:	8f 83       	std	Y+7, r24	; 0x07
    6c8c:	98 87       	std	Y+8, r25	; 0x08
    6c8e:	a9 87       	std	Y+9, r26	; 0x09
    6c90:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6c92:	6f 81       	ldd	r22, Y+7	; 0x07
    6c94:	78 85       	ldd	r23, Y+8	; 0x08
    6c96:	89 85       	ldd	r24, Y+9	; 0x09
    6c98:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c9a:	20 e0       	ldi	r18, 0x00	; 0
    6c9c:	30 e0       	ldi	r19, 0x00	; 0
    6c9e:	40 e8       	ldi	r20, 0x80	; 128
    6ca0:	5f e3       	ldi	r21, 0x3F	; 63
    6ca2:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    6ca6:	88 23       	and	r24, r24
    6ca8:	2c f4       	brge	.+10     	; 0x6cb4 <about_turn+0xf6>
		__ticks = 1;
    6caa:	81 e0       	ldi	r24, 0x01	; 1
    6cac:	90 e0       	ldi	r25, 0x00	; 0
    6cae:	9e 83       	std	Y+6, r25	; 0x06
    6cb0:	8d 83       	std	Y+5, r24	; 0x05
    6cb2:	3f c0       	rjmp	.+126    	; 0x6d32 <about_turn+0x174>
	else if (__tmp > 65535)
    6cb4:	6f 81       	ldd	r22, Y+7	; 0x07
    6cb6:	78 85       	ldd	r23, Y+8	; 0x08
    6cb8:	89 85       	ldd	r24, Y+9	; 0x09
    6cba:	9a 85       	ldd	r25, Y+10	; 0x0a
    6cbc:	20 e0       	ldi	r18, 0x00	; 0
    6cbe:	3f ef       	ldi	r19, 0xFF	; 255
    6cc0:	4f e7       	ldi	r20, 0x7F	; 127
    6cc2:	57 e4       	ldi	r21, 0x47	; 71
    6cc4:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    6cc8:	18 16       	cp	r1, r24
    6cca:	4c f5       	brge	.+82     	; 0x6d1e <about_turn+0x160>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6ccc:	6b 85       	ldd	r22, Y+11	; 0x0b
    6cce:	7c 85       	ldd	r23, Y+12	; 0x0c
    6cd0:	8d 85       	ldd	r24, Y+13	; 0x0d
    6cd2:	9e 85       	ldd	r25, Y+14	; 0x0e
    6cd4:	20 e0       	ldi	r18, 0x00	; 0
    6cd6:	30 e0       	ldi	r19, 0x00	; 0
    6cd8:	40 e2       	ldi	r20, 0x20	; 32
    6cda:	51 e4       	ldi	r21, 0x41	; 65
    6cdc:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    6ce0:	dc 01       	movw	r26, r24
    6ce2:	cb 01       	movw	r24, r22
    6ce4:	bc 01       	movw	r22, r24
    6ce6:	cd 01       	movw	r24, r26
    6ce8:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    6cec:	dc 01       	movw	r26, r24
    6cee:	cb 01       	movw	r24, r22
    6cf0:	9e 83       	std	Y+6, r25	; 0x06
    6cf2:	8d 83       	std	Y+5, r24	; 0x05
    6cf4:	0f c0       	rjmp	.+30     	; 0x6d14 <about_turn+0x156>
    6cf6:	80 e7       	ldi	r24, 0x70	; 112
    6cf8:	91 e0       	ldi	r25, 0x01	; 1
    6cfa:	9c 83       	std	Y+4, r25	; 0x04
    6cfc:	8b 83       	std	Y+3, r24	; 0x03
    6cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    6d00:	9c 81       	ldd	r25, Y+4	; 0x04
    6d02:	01 97       	sbiw	r24, 0x01	; 1
    6d04:	f1 f7       	brne	.-4      	; 0x6d02 <about_turn+0x144>
    6d06:	9c 83       	std	Y+4, r25	; 0x04
    6d08:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d0a:	8d 81       	ldd	r24, Y+5	; 0x05
    6d0c:	9e 81       	ldd	r25, Y+6	; 0x06
    6d0e:	01 97       	sbiw	r24, 0x01	; 1
    6d10:	9e 83       	std	Y+6, r25	; 0x06
    6d12:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d14:	8d 81       	ldd	r24, Y+5	; 0x05
    6d16:	9e 81       	ldd	r25, Y+6	; 0x06
    6d18:	00 97       	sbiw	r24, 0x00	; 0
    6d1a:	69 f7       	brne	.-38     	; 0x6cf6 <about_turn+0x138>
    6d1c:	14 c0       	rjmp	.+40     	; 0x6d46 <about_turn+0x188>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d1e:	6f 81       	ldd	r22, Y+7	; 0x07
    6d20:	78 85       	ldd	r23, Y+8	; 0x08
    6d22:	89 85       	ldd	r24, Y+9	; 0x09
    6d24:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d26:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    6d2a:	dc 01       	movw	r26, r24
    6d2c:	cb 01       	movw	r24, r22
    6d2e:	9e 83       	std	Y+6, r25	; 0x06
    6d30:	8d 83       	std	Y+5, r24	; 0x05
    6d32:	8d 81       	ldd	r24, Y+5	; 0x05
    6d34:	9e 81       	ldd	r25, Y+6	; 0x06
    6d36:	9a 83       	std	Y+2, r25	; 0x02
    6d38:	89 83       	std	Y+1, r24	; 0x01
    6d3a:	89 81       	ldd	r24, Y+1	; 0x01
    6d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    6d3e:	01 97       	sbiw	r24, 0x01	; 1
    6d40:	f1 f7       	brne	.-4      	; 0x6d3e <about_turn+0x180>
    6d42:	9a 83       	std	Y+2, r25	; 0x02
    6d44:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(20);
			velocity(115,125);
    6d46:	83 e7       	ldi	r24, 0x73	; 115
    6d48:	6d e7       	ldi	r22, 0x7D	; 125
    6d4a:	0e 94 f0 28 	call	0x51e0	; 0x51e0 <velocity>
			left_degrees(190);
    6d4e:	8e eb       	ldi	r24, 0xBE	; 190
    6d50:	90 e0       	ldi	r25, 0x00	; 0
    6d52:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <left_degrees>
			break;
		}
	}
    6d56:	60 96       	adiw	r28, 0x10	; 16
    6d58:	0f b6       	in	r0, 0x3f	; 63
    6d5a:	f8 94       	cli
    6d5c:	de bf       	out	0x3e, r29	; 62
    6d5e:	0f be       	out	0x3f, r0	; 63
    6d60:	cd bf       	out	0x3d, r28	; 61
    6d62:	cf 91       	pop	r28
    6d64:	df 91       	pop	r29
    6d66:	08 95       	ret

00006d68 <Start_solving>:
					******************
* Example Call:		Start_solving();
*
*/
void Start_solving()
{
    6d68:	df 93       	push	r29
    6d6a:	cf 93       	push	r28
    6d6c:	cd b7       	in	r28, 0x3d	; 61
    6d6e:	de b7       	in	r29, 0x3e	; 62
    6d70:	ae 97       	sbiw	r28, 0x2e	; 46
    6d72:	0f b6       	in	r0, 0x3f	; 63
    6d74:	f8 94       	cli
    6d76:	de bf       	out	0x3e, r29	; 62
    6d78:	0f be       	out	0x3f, r0	; 63
    6d7a:	cd bf       	out	0x3d, r28	; 61
	int nos_deposited=0;
    6d7c:	1e a6       	std	Y+46, r1	; 0x2e
    6d7e:	1d a6       	std	Y+45, r1	; 0x2d
	int nos_deposited_single=0; //keeps track of how many numbers has been deposited for a single number completion in Grid 2
    6d80:	1c a6       	std	Y+44, r1	; 0x2c
    6d82:	1b a6       	std	Y+43, r1	; 0x2b
	int i=0;
    6d84:	1a a6       	std	Y+42, r1	; 0x2a
    6d86:	19 a6       	std	Y+41, r1	; 0x29
	int pos,ptr=0;    //these two variables are used as index holder for arrays transferred serially from python
    6d88:	1e a2       	std	Y+38, r1	; 0x26
    6d8a:	1d a2       	std	Y+37, r1	; 0x25
	int ptr2=0;   // used to store index of num[] array
    6d8c:	1c a2       	std	Y+36, r1	; 0x24
    6d8e:	1b a2       	std	Y+35, r1	; 0x23
	int c,d;   // variable to store co-ordinates	
    int total_nos=num[0]+num[1]+num[2]+num[3];   // storing total numnbers required to sum up and making the numbers in Grid2
    6d90:	20 91 d8 03 	lds	r18, 0x03D8
    6d94:	30 91 d9 03 	lds	r19, 0x03D9
    6d98:	80 91 da 03 	lds	r24, 0x03DA
    6d9c:	90 91 db 03 	lds	r25, 0x03DB
    6da0:	28 0f       	add	r18, r24
    6da2:	39 1f       	adc	r19, r25
    6da4:	80 91 dc 03 	lds	r24, 0x03DC
    6da8:	90 91 dd 03 	lds	r25, 0x03DD
    6dac:	28 0f       	add	r18, r24
    6dae:	39 1f       	adc	r19, r25
    6db0:	80 91 de 03 	lds	r24, 0x03DE
    6db4:	90 91 df 03 	lds	r25, 0x03DF
    6db8:	82 0f       	add	r24, r18
    6dba:	93 1f       	adc	r25, r19
    6dbc:	9e 8f       	std	Y+30, r25	; 0x1e
    6dbe:	8d 8f       	std	Y+29, r24	; 0x1d
    6dc0:	1d c4       	rjmp	.+2106   	; 0x75fc <Start_solving+0x894>
	
	
	while(nos_deposited!=total_nos)  // loop until all numnbers are not deposited
	{
		if(nos_deposited_single==num[ptr2])    //if one number in Grid2 is completed
    6dc2:	8b a1       	ldd	r24, Y+35	; 0x23
    6dc4:	9c a1       	ldd	r25, Y+36	; 0x24
    6dc6:	88 0f       	add	r24, r24
    6dc8:	99 1f       	adc	r25, r25
    6dca:	fc 01       	movw	r30, r24
    6dcc:	e8 52       	subi	r30, 0x28	; 40
    6dce:	fc 4f       	sbci	r31, 0xFC	; 252
    6dd0:	20 81       	ld	r18, Z
    6dd2:	31 81       	ldd	r19, Z+1	; 0x01
    6dd4:	8b a5       	ldd	r24, Y+43	; 0x2b
    6dd6:	9c a5       	ldd	r25, Y+44	; 0x2c
    6dd8:	28 17       	cp	r18, r24
    6dda:	39 07       	cpc	r19, r25
    6ddc:	61 f4       	brne	.+24     	; 0x6df6 <Start_solving+0x8e>
		{	
			ptr2++;							//increment ptr2 by 1 to get total numbers required to solve next number in Grid2
    6dde:	8b a1       	ldd	r24, Y+35	; 0x23
    6de0:	9c a1       	ldd	r25, Y+36	; 0x24
    6de2:	01 96       	adiw	r24, 0x01	; 1
    6de4:	9c a3       	std	Y+36, r25	; 0x24
    6de6:	8b a3       	std	Y+35, r24	; 0x23
			ptr+=2;							//increment ptr by 2 to get the next number to solve in Grid2
    6de8:	8d a1       	ldd	r24, Y+37	; 0x25
    6dea:	9e a1       	ldd	r25, Y+38	; 0x26
    6dec:	02 96       	adiw	r24, 0x02	; 2
    6dee:	9e a3       	std	Y+38, r25	; 0x26
    6df0:	8d a3       	std	Y+37, r24	; 0x25
			nos_deposited_single=0;			//initialise nos_deposited_single to 0 as new number does not have any numbers deposited on it yet.
    6df2:	1c a6       	std	Y+44, r1	; 0x2c
    6df4:	1b a6       	std	Y+43, r1	; 0x2b
		}
		for(i=0;i<12;i++)					//loop to know the position of the number robot need to pick by searching it in Grid1 array.
    6df6:	1a a6       	std	Y+42, r1	; 0x2a
    6df8:	19 a6       	std	Y+41, r1	; 0x29
    6dfa:	45 c0       	rjmp	.+138    	; 0x6e86 <Start_solving+0x11e>
		{
			if(Sol[ptr2][nos_deposited_single]==Grid1[i])
    6dfc:	4b a1       	ldd	r20, Y+35	; 0x23
    6dfe:	5c a1       	ldd	r21, Y+36	; 0x24
    6e00:	6b a5       	ldd	r22, Y+43	; 0x2b
    6e02:	7c a5       	ldd	r23, Y+44	; 0x2c
    6e04:	ca 01       	movw	r24, r20
    6e06:	88 0f       	add	r24, r24
    6e08:	99 1f       	adc	r25, r25
    6e0a:	9c 01       	movw	r18, r24
    6e0c:	22 0f       	add	r18, r18
    6e0e:	33 1f       	adc	r19, r19
    6e10:	22 0f       	add	r18, r18
    6e12:	33 1f       	adc	r19, r19
    6e14:	82 0f       	add	r24, r18
    6e16:	93 1f       	adc	r25, r19
    6e18:	84 0f       	add	r24, r20
    6e1a:	95 1f       	adc	r25, r21
    6e1c:	86 0f       	add	r24, r22
    6e1e:	97 1f       	adc	r25, r23
    6e20:	88 0f       	add	r24, r24
    6e22:	99 1f       	adc	r25, r25
    6e24:	fc 01       	movw	r30, r24
    6e26:	e4 5e       	subi	r30, 0xE4	; 228
    6e28:	fb 4f       	sbci	r31, 0xFB	; 251
    6e2a:	20 81       	ld	r18, Z
    6e2c:	31 81       	ldd	r19, Z+1	; 0x01
    6e2e:	89 a5       	ldd	r24, Y+41	; 0x29
    6e30:	9a a5       	ldd	r25, Y+42	; 0x2a
    6e32:	88 0f       	add	r24, r24
    6e34:	99 1f       	adc	r25, r25
    6e36:	fc 01       	movw	r30, r24
    6e38:	e1 50       	subi	r30, 0x01	; 1
    6e3a:	fc 4f       	sbci	r31, 0xFC	; 252
    6e3c:	80 81       	ld	r24, Z
    6e3e:	91 81       	ldd	r25, Z+1	; 0x01
    6e40:	28 17       	cp	r18, r24
    6e42:	39 07       	cpc	r19, r25
    6e44:	d9 f4       	brne	.+54     	; 0x6e7c <Start_solving+0x114>
			{
				Grid1[i]=Grid1[i]+30;
    6e46:	49 a5       	ldd	r20, Y+41	; 0x29
    6e48:	5a a5       	ldd	r21, Y+42	; 0x2a
    6e4a:	89 a5       	ldd	r24, Y+41	; 0x29
    6e4c:	9a a5       	ldd	r25, Y+42	; 0x2a
    6e4e:	88 0f       	add	r24, r24
    6e50:	99 1f       	adc	r25, r25
    6e52:	fc 01       	movw	r30, r24
    6e54:	e1 50       	subi	r30, 0x01	; 1
    6e56:	fc 4f       	sbci	r31, 0xFC	; 252
    6e58:	80 81       	ld	r24, Z
    6e5a:	91 81       	ldd	r25, Z+1	; 0x01
    6e5c:	9c 01       	movw	r18, r24
    6e5e:	22 5e       	subi	r18, 0xE2	; 226
    6e60:	3f 4f       	sbci	r19, 0xFF	; 255
    6e62:	ca 01       	movw	r24, r20
    6e64:	88 0f       	add	r24, r24
    6e66:	99 1f       	adc	r25, r25
    6e68:	fc 01       	movw	r30, r24
    6e6a:	e1 50       	subi	r30, 0x01	; 1
    6e6c:	fc 4f       	sbci	r31, 0xFC	; 252
    6e6e:	31 83       	std	Z+1, r19	; 0x01
    6e70:	20 83       	st	Z, r18
				pos=i;
    6e72:	89 a5       	ldd	r24, Y+41	; 0x29
    6e74:	9a a5       	ldd	r25, Y+42	; 0x2a
    6e76:	98 a7       	std	Y+40, r25	; 0x28
    6e78:	8f a3       	std	Y+39, r24	; 0x27
    6e7a:	0b c0       	rjmp	.+22     	; 0x6e92 <Start_solving+0x12a>
		{	
			ptr2++;							//increment ptr2 by 1 to get total numbers required to solve next number in Grid2
			ptr+=2;							//increment ptr by 2 to get the next number to solve in Grid2
			nos_deposited_single=0;			//initialise nos_deposited_single to 0 as new number does not have any numbers deposited on it yet.
		}
		for(i=0;i<12;i++)					//loop to know the position of the number robot need to pick by searching it in Grid1 array.
    6e7c:	89 a5       	ldd	r24, Y+41	; 0x29
    6e7e:	9a a5       	ldd	r25, Y+42	; 0x2a
    6e80:	01 96       	adiw	r24, 0x01	; 1
    6e82:	9a a7       	std	Y+42, r25	; 0x2a
    6e84:	89 a7       	std	Y+41, r24	; 0x29
    6e86:	89 a5       	ldd	r24, Y+41	; 0x29
    6e88:	9a a5       	ldd	r25, Y+42	; 0x2a
    6e8a:	8c 30       	cpi	r24, 0x0C	; 12
    6e8c:	91 05       	cpc	r25, r1
    6e8e:	0c f4       	brge	.+2      	; 0x6e92 <Start_solving+0x12a>
    6e90:	b5 cf       	rjmp	.-150    	; 0x6dfc <Start_solving+0x94>
				Grid1[i]=Grid1[i]+30;
				pos=i;
				break;			//if found,break from loop
			}	
		}
		if(nos_deposited==0)		//only evaluates to true once for first number to be deposited.
    6e92:	8d a5       	ldd	r24, Y+45	; 0x2d
    6e94:	9e a5       	ldd	r25, Y+46	; 0x2e
    6e96:	00 97       	sbiw	r24, 0x00	; 0
    6e98:	59 f5       	brne	.+86     	; 0x6ef0 <Start_solving+0x188>
		{
			c=grid1array[pos][0];	//read x co-ordinate from co-ordinates array
    6e9a:	8f a1       	ldd	r24, Y+39	; 0x27
    6e9c:	98 a5       	ldd	r25, Y+40	; 0x28
    6e9e:	88 0f       	add	r24, r24
    6ea0:	99 1f       	adc	r25, r25
    6ea2:	88 0f       	add	r24, r24
    6ea4:	99 1f       	adc	r25, r25
    6ea6:	fc 01       	movw	r30, r24
    6ea8:	ef 5f       	subi	r30, 0xFF	; 255
    6eaa:	fd 4f       	sbci	r31, 0xFD	; 253
    6eac:	80 81       	ld	r24, Z
    6eae:	91 81       	ldd	r25, Z+1	; 0x01
    6eb0:	9a a3       	std	Y+34, r25	; 0x22
    6eb2:	89 a3       	std	Y+33, r24	; 0x21
			d=grid1array[pos][1];   //read y co-ordinate from co-ordinates array
    6eb4:	8f a1       	ldd	r24, Y+39	; 0x27
    6eb6:	98 a5       	ldd	r25, Y+40	; 0x28
    6eb8:	88 0f       	add	r24, r24
    6eba:	99 1f       	adc	r25, r25
    6ebc:	88 0f       	add	r24, r24
    6ebe:	99 1f       	adc	r25, r25
    6ec0:	fc 01       	movw	r30, r24
    6ec2:	ed 5f       	subi	r30, 0xFD	; 253
    6ec4:	fd 4f       	sbci	r31, 0xFD	; 253
    6ec6:	80 81       	ld	r24, Z
    6ec8:	91 81       	ldd	r25, Z+1	; 0x01
    6eca:	98 a3       	std	Y+32, r25	; 0x20
    6ecc:	8f 8f       	std	Y+31, r24	; 0x1f
			
			move_y_first(2,-1,c,d);   //traverse to the first number to be picked up
    6ece:	29 a1       	ldd	r18, Y+33	; 0x21
    6ed0:	3a a1       	ldd	r19, Y+34	; 0x22
    6ed2:	ef 8d       	ldd	r30, Y+31	; 0x1f
    6ed4:	f8 a1       	ldd	r31, Y+32	; 0x20
    6ed6:	82 e0       	ldi	r24, 0x02	; 2
    6ed8:	90 e0       	ldi	r25, 0x00	; 0
    6eda:	6f ef       	ldi	r22, 0xFF	; 255
    6edc:	7f ef       	ldi	r23, 0xFF	; 255
    6ede:	a9 01       	movw	r20, r18
    6ee0:	9f 01       	movw	r18, r30
    6ee2:	0e 94 e5 2c 	call	0x59ca	; 0x59ca <move_y_first>
			Led_on(pos);			//turn ON LED according to the position of robot.
    6ee6:	8f a1       	ldd	r24, Y+39	; 0x27
    6ee8:	98 a5       	ldd	r25, Y+40	; 0x28
    6eea:	0e 94 68 35 	call	0x6ad0	; 0x6ad0 <Led_on>
    6eee:	2a c0       	rjmp	.+84     	; 0x6f44 <Start_solving+0x1dc>
		}
		else
		{
			c=grid1array2[pos][0];   //read x co-ordinate from co-ordinates array
    6ef0:	8f a1       	ldd	r24, Y+39	; 0x27
    6ef2:	98 a5       	ldd	r25, Y+40	; 0x28
    6ef4:	88 0f       	add	r24, r24
    6ef6:	99 1f       	adc	r25, r25
    6ef8:	88 0f       	add	r24, r24
    6efa:	99 1f       	adc	r25, r25
    6efc:	fc 01       	movw	r30, r24
    6efe:	ef 56       	subi	r30, 0x6F	; 111
    6f00:	fd 4f       	sbci	r31, 0xFD	; 253
    6f02:	80 81       	ld	r24, Z
    6f04:	91 81       	ldd	r25, Z+1	; 0x01
    6f06:	9a a3       	std	Y+34, r25	; 0x22
    6f08:	89 a3       	std	Y+33, r24	; 0x21
			d=grid1array2[pos][1];   //read y co-ordinate from co-ordinates array
    6f0a:	8f a1       	ldd	r24, Y+39	; 0x27
    6f0c:	98 a5       	ldd	r25, Y+40	; 0x28
    6f0e:	88 0f       	add	r24, r24
    6f10:	99 1f       	adc	r25, r25
    6f12:	88 0f       	add	r24, r24
    6f14:	99 1f       	adc	r25, r25
    6f16:	fc 01       	movw	r30, r24
    6f18:	ed 56       	subi	r30, 0x6D	; 109
    6f1a:	fd 4f       	sbci	r31, 0xFD	; 253
    6f1c:	80 81       	ld	r24, Z
    6f1e:	91 81       	ldd	r25, Z+1	; 0x01
    6f20:	98 a3       	std	Y+32, r25	; 0x20
    6f22:	8f 8f       	std	Y+31, r24	; 0x1f
			
			move_x_first(4,1,c,d);   //traverse from (4,1) to the number to be picked //[(2,-1) is the coordinate of the start line]
    6f24:	29 a1       	ldd	r18, Y+33	; 0x21
    6f26:	3a a1       	ldd	r19, Y+34	; 0x22
    6f28:	ef 8d       	ldd	r30, Y+31	; 0x1f
    6f2a:	f8 a1       	ldd	r31, Y+32	; 0x20
    6f2c:	84 e0       	ldi	r24, 0x04	; 4
    6f2e:	90 e0       	ldi	r25, 0x00	; 0
    6f30:	61 e0       	ldi	r22, 0x01	; 1
    6f32:	70 e0       	ldi	r23, 0x00	; 0
    6f34:	a9 01       	movw	r20, r18
    6f36:	9f 01       	movw	r18, r30
    6f38:	0e 94 57 30 	call	0x60ae	; 0x60ae <move_x_first>
			Led_on1(pos);			//turn ON LED according to the position of robot.
    6f3c:	8f a1       	ldd	r24, Y+39	; 0x27
    6f3e:	98 a5       	ldd	r25, Y+40	; 0x28
    6f40:	0e 94 a3 35 	call	0x6b46	; 0x6b46 <Led_on1>
		}		
		Glcd_display(Sol[ptr2][nos_deposited_single]);   //used to display required number on GLCD
    6f44:	4b a1       	ldd	r20, Y+35	; 0x23
    6f46:	5c a1       	ldd	r21, Y+36	; 0x24
    6f48:	6b a5       	ldd	r22, Y+43	; 0x2b
    6f4a:	7c a5       	ldd	r23, Y+44	; 0x2c
    6f4c:	ca 01       	movw	r24, r20
    6f4e:	88 0f       	add	r24, r24
    6f50:	99 1f       	adc	r25, r25
    6f52:	9c 01       	movw	r18, r24
    6f54:	22 0f       	add	r18, r18
    6f56:	33 1f       	adc	r19, r19
    6f58:	22 0f       	add	r18, r18
    6f5a:	33 1f       	adc	r19, r19
    6f5c:	82 0f       	add	r24, r18
    6f5e:	93 1f       	adc	r25, r19
    6f60:	84 0f       	add	r24, r20
    6f62:	95 1f       	adc	r25, r21
    6f64:	86 0f       	add	r24, r22
    6f66:	97 1f       	adc	r25, r23
    6f68:	88 0f       	add	r24, r24
    6f6a:	99 1f       	adc	r25, r25
    6f6c:	fc 01       	movw	r30, r24
    6f6e:	e4 5e       	subi	r30, 0xE4	; 228
    6f70:	fb 4f       	sbci	r31, 0xFB	; 251
    6f72:	80 81       	ld	r24, Z
    6f74:	91 81       	ldd	r25, Z+1	; 0x01
    6f76:	0e 94 13 35 	call	0x6a26	; 0x6a26 <Glcd_display>

		if((c==0 || c==1) && (d==1) && nos_deposited==0) //to correct the motion of robot as nodes may sometimes be needed to increased or decreased due to turning of robot
    6f7a:	89 a1       	ldd	r24, Y+33	; 0x21
    6f7c:	9a a1       	ldd	r25, Y+34	; 0x22
    6f7e:	00 97       	sbiw	r24, 0x00	; 0
    6f80:	29 f0       	breq	.+10     	; 0x6f8c <Start_solving+0x224>
    6f82:	89 a1       	ldd	r24, Y+33	; 0x21
    6f84:	9a a1       	ldd	r25, Y+34	; 0x22
    6f86:	81 30       	cpi	r24, 0x01	; 1
    6f88:	91 05       	cpc	r25, r1
    6f8a:	71 f4       	brne	.+28     	; 0x6fa8 <Start_solving+0x240>
    6f8c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    6f8e:	98 a1       	ldd	r25, Y+32	; 0x20
    6f90:	81 30       	cpi	r24, 0x01	; 1
    6f92:	91 05       	cpc	r25, r1
    6f94:	49 f4       	brne	.+18     	; 0x6fa8 <Start_solving+0x240>
    6f96:	8d a5       	ldd	r24, Y+45	; 0x2d
    6f98:	9e a5       	ldd	r25, Y+46	; 0x2e
    6f9a:	00 97       	sbiw	r24, 0x00	; 0
    6f9c:	29 f4       	brne	.+10     	; 0x6fa8 <Start_solving+0x240>
		{
			c++;
    6f9e:	89 a1       	ldd	r24, Y+33	; 0x21
    6fa0:	9a a1       	ldd	r25, Y+34	; 0x22
    6fa2:	01 96       	adiw	r24, 0x01	; 1
    6fa4:	9a a3       	std	Y+34, r25	; 0x22
    6fa6:	89 a3       	std	Y+33, r24	; 0x21
		}
		if(pos>=4 && pos<=11 && nos_deposited!=0)     //same as above
    6fa8:	8f a1       	ldd	r24, Y+39	; 0x27
    6faa:	98 a5       	ldd	r25, Y+40	; 0x28
    6fac:	84 30       	cpi	r24, 0x04	; 4
    6fae:	91 05       	cpc	r25, r1
    6fb0:	74 f0       	brlt	.+28     	; 0x6fce <Start_solving+0x266>
    6fb2:	8f a1       	ldd	r24, Y+39	; 0x27
    6fb4:	98 a5       	ldd	r25, Y+40	; 0x28
    6fb6:	8c 30       	cpi	r24, 0x0C	; 12
    6fb8:	91 05       	cpc	r25, r1
    6fba:	4c f4       	brge	.+18     	; 0x6fce <Start_solving+0x266>
    6fbc:	8d a5       	ldd	r24, Y+45	; 0x2d
    6fbe:	9e a5       	ldd	r25, Y+46	; 0x2e
    6fc0:	00 97       	sbiw	r24, 0x00	; 0
    6fc2:	29 f0       	breq	.+10     	; 0x6fce <Start_solving+0x266>
			c++;
    6fc4:	89 a1       	ldd	r24, Y+33	; 0x21
    6fc6:	9a a1       	ldd	r25, Y+34	; 0x22
    6fc8:	01 96       	adiw	r24, 0x01	; 1
    6fca:	9a a3       	std	Y+34, r25	; 0x22
    6fcc:	89 a3       	std	Y+33, r24	; 0x21
		if((pos==6 || pos==7 || pos==10 || pos==11) && nos_deposited==0)    //similar
    6fce:	8f a1       	ldd	r24, Y+39	; 0x27
    6fd0:	98 a5       	ldd	r25, Y+40	; 0x28
    6fd2:	86 30       	cpi	r24, 0x06	; 6
    6fd4:	91 05       	cpc	r25, r1
    6fd6:	79 f0       	breq	.+30     	; 0x6ff6 <Start_solving+0x28e>
    6fd8:	8f a1       	ldd	r24, Y+39	; 0x27
    6fda:	98 a5       	ldd	r25, Y+40	; 0x28
    6fdc:	87 30       	cpi	r24, 0x07	; 7
    6fde:	91 05       	cpc	r25, r1
    6fe0:	51 f0       	breq	.+20     	; 0x6ff6 <Start_solving+0x28e>
    6fe2:	8f a1       	ldd	r24, Y+39	; 0x27
    6fe4:	98 a5       	ldd	r25, Y+40	; 0x28
    6fe6:	8a 30       	cpi	r24, 0x0A	; 10
    6fe8:	91 05       	cpc	r25, r1
    6fea:	29 f0       	breq	.+10     	; 0x6ff6 <Start_solving+0x28e>
    6fec:	8f a1       	ldd	r24, Y+39	; 0x27
    6fee:	98 a5       	ldd	r25, Y+40	; 0x28
    6ff0:	8b 30       	cpi	r24, 0x0B	; 11
    6ff2:	91 05       	cpc	r25, r1
    6ff4:	49 f4       	brne	.+18     	; 0x7008 <Start_solving+0x2a0>
    6ff6:	8d a5       	ldd	r24, Y+45	; 0x2d
    6ff8:	9e a5       	ldd	r25, Y+46	; 0x2e
    6ffa:	00 97       	sbiw	r24, 0x00	; 0
    6ffc:	29 f4       	brne	.+10     	; 0x7008 <Start_solving+0x2a0>
			c--;
    6ffe:	89 a1       	ldd	r24, Y+33	; 0x21
    7000:	9a a1       	ldd	r25, Y+34	; 0x22
    7002:	01 97       	sbiw	r24, 0x01	; 1
    7004:	9a a3       	std	Y+34, r25	; 0x22
    7006:	89 a3       	std	Y+33, r24	; 0x21
		move_y_first(c,d,5,1);   //traverse
    7008:	89 a1       	ldd	r24, Y+33	; 0x21
    700a:	9a a1       	ldd	r25, Y+34	; 0x22
    700c:	2f 8d       	ldd	r18, Y+31	; 0x1f
    700e:	38 a1       	ldd	r19, Y+32	; 0x20
    7010:	b9 01       	movw	r22, r18
    7012:	45 e0       	ldi	r20, 0x05	; 5
    7014:	50 e0       	ldi	r21, 0x00	; 0
    7016:	21 e0       	ldi	r18, 0x01	; 1
    7018:	30 e0       	ldi	r19, 0x00	; 0
    701a:	0e 94 e5 2c 	call	0x59ca	; 0x59ca <move_y_first>
	    
		c=grid2array[Grid2[ptr]][0];   //read x co-ordinate from co-ordinates array
    701e:	8d a1       	ldd	r24, Y+37	; 0x25
    7020:	9e a1       	ldd	r25, Y+38	; 0x26
    7022:	88 0f       	add	r24, r24
    7024:	99 1f       	adc	r25, r25
    7026:	fc 01       	movw	r30, r24
    7028:	e8 58       	subi	r30, 0x88	; 136
    702a:	fb 4f       	sbci	r31, 0xFB	; 251
    702c:	80 81       	ld	r24, Z
    702e:	91 81       	ldd	r25, Z+1	; 0x01
    7030:	88 0f       	add	r24, r24
    7032:	99 1f       	adc	r25, r25
    7034:	88 0f       	add	r24, r24
    7036:	99 1f       	adc	r25, r25
    7038:	fc 01       	movw	r30, r24
    703a:	ef 5c       	subi	r30, 0xCF	; 207
    703c:	fd 4f       	sbci	r31, 0xFD	; 253
    703e:	80 81       	ld	r24, Z
    7040:	91 81       	ldd	r25, Z+1	; 0x01
    7042:	9a a3       	std	Y+34, r25	; 0x22
    7044:	89 a3       	std	Y+33, r24	; 0x21
		d=grid2array[Grid2[ptr]][1];   //read y co-ordinate from co-ordinates array
    7046:	8d a1       	ldd	r24, Y+37	; 0x25
    7048:	9e a1       	ldd	r25, Y+38	; 0x26
    704a:	88 0f       	add	r24, r24
    704c:	99 1f       	adc	r25, r25
    704e:	fc 01       	movw	r30, r24
    7050:	e8 58       	subi	r30, 0x88	; 136
    7052:	fb 4f       	sbci	r31, 0xFB	; 251
    7054:	80 81       	ld	r24, Z
    7056:	91 81       	ldd	r25, Z+1	; 0x01
    7058:	88 0f       	add	r24, r24
    705a:	99 1f       	adc	r25, r25
    705c:	88 0f       	add	r24, r24
    705e:	99 1f       	adc	r25, r25
    7060:	fc 01       	movw	r30, r24
    7062:	ed 5c       	subi	r30, 0xCD	; 205
    7064:	fd 4f       	sbci	r31, 0xFD	; 253
    7066:	80 81       	ld	r24, Z
    7068:	91 81       	ldd	r25, Z+1	; 0x01
    706a:	98 a3       	std	Y+32, r25	; 0x20
    706c:	8f 8f       	std	Y+31, r24	; 0x1f
		move_x_first(5,1,c,d);    //traverse
    706e:	29 a1       	ldd	r18, Y+33	; 0x21
    7070:	3a a1       	ldd	r19, Y+34	; 0x22
    7072:	ef 8d       	ldd	r30, Y+31	; 0x1f
    7074:	f8 a1       	ldd	r31, Y+32	; 0x20
    7076:	85 e0       	ldi	r24, 0x05	; 5
    7078:	90 e0       	ldi	r25, 0x00	; 0
    707a:	61 e0       	ldi	r22, 0x01	; 1
    707c:	70 e0       	ldi	r23, 0x00	; 0
    707e:	a9 01       	movw	r20, r18
    7080:	9f 01       	movw	r18, r30
    7082:	0e 94 57 30 	call	0x60ae	; 0x60ae <move_x_first>

		//below if else code is used to deposit number from the side where LED is glowing
		if(LED_right==1)//if right led is glowing
    7086:	80 91 e0 03 	lds	r24, 0x03E0
    708a:	90 91 e1 03 	lds	r25, 0x03E1
    708e:	81 30       	cpi	r24, 0x01	; 1
    7090:	91 05       	cpc	r25, r1
    7092:	09 f0       	breq	.+2      	; 0x7096 <Start_solving+0x32e>
    7094:	c1 c0       	rjmp	.+386    	; 0x7218 <Start_solving+0x4b0>
		{
			if(((d-1)!=0) && (Grid2[ptr]==1 || Grid2[ptr]==3 || Grid2[ptr]==5 || Grid2[ptr]==18 || Grid2[ptr]==20 || Grid2[ptr]==22))
    7096:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7098:	98 a1       	ldd	r25, Y+32	; 0x20
    709a:	81 30       	cpi	r24, 0x01	; 1
    709c:	91 05       	cpc	r25, r1
    709e:	09 f4       	brne	.+2      	; 0x70a2 <Start_solving+0x33a>
    70a0:	4f c0       	rjmp	.+158    	; 0x7140 <Start_solving+0x3d8>
    70a2:	8d a1       	ldd	r24, Y+37	; 0x25
    70a4:	9e a1       	ldd	r25, Y+38	; 0x26
    70a6:	88 0f       	add	r24, r24
    70a8:	99 1f       	adc	r25, r25
    70aa:	fc 01       	movw	r30, r24
    70ac:	e8 58       	subi	r30, 0x88	; 136
    70ae:	fb 4f       	sbci	r31, 0xFB	; 251
    70b0:	80 81       	ld	r24, Z
    70b2:	91 81       	ldd	r25, Z+1	; 0x01
    70b4:	81 30       	cpi	r24, 0x01	; 1
    70b6:	91 05       	cpc	r25, r1
    70b8:	e1 f1       	breq	.+120    	; 0x7132 <Start_solving+0x3ca>
    70ba:	8d a1       	ldd	r24, Y+37	; 0x25
    70bc:	9e a1       	ldd	r25, Y+38	; 0x26
    70be:	88 0f       	add	r24, r24
    70c0:	99 1f       	adc	r25, r25
    70c2:	fc 01       	movw	r30, r24
    70c4:	e8 58       	subi	r30, 0x88	; 136
    70c6:	fb 4f       	sbci	r31, 0xFB	; 251
    70c8:	80 81       	ld	r24, Z
    70ca:	91 81       	ldd	r25, Z+1	; 0x01
    70cc:	83 30       	cpi	r24, 0x03	; 3
    70ce:	91 05       	cpc	r25, r1
    70d0:	81 f1       	breq	.+96     	; 0x7132 <Start_solving+0x3ca>
    70d2:	8d a1       	ldd	r24, Y+37	; 0x25
    70d4:	9e a1       	ldd	r25, Y+38	; 0x26
    70d6:	88 0f       	add	r24, r24
    70d8:	99 1f       	adc	r25, r25
    70da:	fc 01       	movw	r30, r24
    70dc:	e8 58       	subi	r30, 0x88	; 136
    70de:	fb 4f       	sbci	r31, 0xFB	; 251
    70e0:	80 81       	ld	r24, Z
    70e2:	91 81       	ldd	r25, Z+1	; 0x01
    70e4:	85 30       	cpi	r24, 0x05	; 5
    70e6:	91 05       	cpc	r25, r1
    70e8:	21 f1       	breq	.+72     	; 0x7132 <Start_solving+0x3ca>
    70ea:	8d a1       	ldd	r24, Y+37	; 0x25
    70ec:	9e a1       	ldd	r25, Y+38	; 0x26
    70ee:	88 0f       	add	r24, r24
    70f0:	99 1f       	adc	r25, r25
    70f2:	fc 01       	movw	r30, r24
    70f4:	e8 58       	subi	r30, 0x88	; 136
    70f6:	fb 4f       	sbci	r31, 0xFB	; 251
    70f8:	80 81       	ld	r24, Z
    70fa:	91 81       	ldd	r25, Z+1	; 0x01
    70fc:	82 31       	cpi	r24, 0x12	; 18
    70fe:	91 05       	cpc	r25, r1
    7100:	c1 f0       	breq	.+48     	; 0x7132 <Start_solving+0x3ca>
    7102:	8d a1       	ldd	r24, Y+37	; 0x25
    7104:	9e a1       	ldd	r25, Y+38	; 0x26
    7106:	88 0f       	add	r24, r24
    7108:	99 1f       	adc	r25, r25
    710a:	fc 01       	movw	r30, r24
    710c:	e8 58       	subi	r30, 0x88	; 136
    710e:	fb 4f       	sbci	r31, 0xFB	; 251
    7110:	80 81       	ld	r24, Z
    7112:	91 81       	ldd	r25, Z+1	; 0x01
    7114:	84 31       	cpi	r24, 0x14	; 20
    7116:	91 05       	cpc	r25, r1
    7118:	61 f0       	breq	.+24     	; 0x7132 <Start_solving+0x3ca>
    711a:	8d a1       	ldd	r24, Y+37	; 0x25
    711c:	9e a1       	ldd	r25, Y+38	; 0x26
    711e:	88 0f       	add	r24, r24
    7120:	99 1f       	adc	r25, r25
    7122:	fc 01       	movw	r30, r24
    7124:	e8 58       	subi	r30, 0x88	; 136
    7126:	fb 4f       	sbci	r31, 0xFB	; 251
    7128:	80 81       	ld	r24, Z
    712a:	91 81       	ldd	r25, Z+1	; 0x01
    712c:	86 31       	cpi	r24, 0x16	; 22
    712e:	91 05       	cpc	r25, r1
    7130:	39 f4       	brne	.+14     	; 0x7140 <Start_solving+0x3d8>
			{
				LED_right=0;
    7132:	10 92 e1 03 	sts	0x03E1, r1
    7136:	10 92 e0 03 	sts	0x03E0, r1
				Right_led_off(); //turn off right led
    713a:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Right_led_off>
    713e:	6c c0       	rjmp	.+216    	; 0x7218 <Start_solving+0x4b0>
			}
			else if((d-1)!=0)
    7140:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7142:	98 a1       	ldd	r25, Y+32	; 0x20
    7144:	81 30       	cpi	r24, 0x01	; 1
    7146:	91 05       	cpc	r25, r1
    7148:	c9 f0       	breq	.+50     	; 0x717c <Start_solving+0x414>
			{
				about_turn();  //if Glowing LED is on the opposite side of the target_number(number in Grid2) then moves robot 180 degrees.
    714a:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <about_turn>
				if(d>0)     //on turning the co-ordinates needs to be fixed
    714e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7150:	98 a1       	ldd	r25, Y+32	; 0x20
    7152:	18 16       	cp	r1, r24
    7154:	19 06       	cpc	r1, r25
    7156:	34 f4       	brge	.+12     	; 0x7164 <Start_solving+0x3fc>
					d=d+1;
    7158:	8f 8d       	ldd	r24, Y+31	; 0x1f
    715a:	98 a1       	ldd	r25, Y+32	; 0x20
    715c:	01 96       	adiw	r24, 0x01	; 1
    715e:	98 a3       	std	Y+32, r25	; 0x20
    7160:	8f 8f       	std	Y+31, r24	; 0x1f
    7162:	05 c0       	rjmp	.+10     	; 0x716e <Start_solving+0x406>
				else
					d=d-1;
    7164:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7166:	98 a1       	ldd	r25, Y+32	; 0x20
    7168:	01 97       	sbiw	r24, 0x01	; 1
    716a:	98 a3       	std	Y+32, r25	; 0x20
    716c:	8f 8f       	std	Y+31, r24	; 0x1f
				LED_right=0;
    716e:	10 92 e1 03 	sts	0x03E1, r1
    7172:	10 92 e0 03 	sts	0x03E0, r1
				Right_led_off();
    7176:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Right_led_off>
    717a:	4e c0       	rjmp	.+156    	; 0x7218 <Start_solving+0x4b0>
			}
			else if ((d==1) && (Grid2[ptr]>=12 && Grid2[ptr]<=17))
    717c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    717e:	98 a1       	ldd	r25, Y+32	; 0x20
    7180:	81 30       	cpi	r24, 0x01	; 1
    7182:	91 05       	cpc	r25, r1
    7184:	21 f5       	brne	.+72     	; 0x71ce <Start_solving+0x466>
    7186:	8d a1       	ldd	r24, Y+37	; 0x25
    7188:	9e a1       	ldd	r25, Y+38	; 0x26
    718a:	88 0f       	add	r24, r24
    718c:	99 1f       	adc	r25, r25
    718e:	fc 01       	movw	r30, r24
    7190:	e8 58       	subi	r30, 0x88	; 136
    7192:	fb 4f       	sbci	r31, 0xFB	; 251
    7194:	80 81       	ld	r24, Z
    7196:	91 81       	ldd	r25, Z+1	; 0x01
    7198:	8c 30       	cpi	r24, 0x0C	; 12
    719a:	91 05       	cpc	r25, r1
    719c:	c4 f0       	brlt	.+48     	; 0x71ce <Start_solving+0x466>
    719e:	8d a1       	ldd	r24, Y+37	; 0x25
    71a0:	9e a1       	ldd	r25, Y+38	; 0x26
    71a2:	88 0f       	add	r24, r24
    71a4:	99 1f       	adc	r25, r25
    71a6:	fc 01       	movw	r30, r24
    71a8:	e8 58       	subi	r30, 0x88	; 136
    71aa:	fb 4f       	sbci	r31, 0xFB	; 251
    71ac:	80 81       	ld	r24, Z
    71ae:	91 81       	ldd	r25, Z+1	; 0x01
    71b0:	82 31       	cpi	r24, 0x12	; 18
    71b2:	91 05       	cpc	r25, r1
    71b4:	64 f4       	brge	.+24     	; 0x71ce <Start_solving+0x466>
			{
				Right_led_off();
    71b6:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Right_led_off>
				LED_right=0;
    71ba:	10 92 e1 03 	sts	0x03E1, r1
    71be:	10 92 e0 03 	sts	0x03E0, r1
				c--;
    71c2:	89 a1       	ldd	r24, Y+33	; 0x21
    71c4:	9a a1       	ldd	r25, Y+34	; 0x22
    71c6:	01 97       	sbiw	r24, 0x01	; 1
    71c8:	9a a3       	std	Y+34, r25	; 0x22
    71ca:	89 a3       	std	Y+33, r24	; 0x21
    71cc:	25 c0       	rjmp	.+74     	; 0x7218 <Start_solving+0x4b0>
			}
			else if((d==1) && (Grid2[ptr]>=6 && Grid2[ptr]<=11))
    71ce:	8f 8d       	ldd	r24, Y+31	; 0x1f
    71d0:	98 a1       	ldd	r25, Y+32	; 0x20
    71d2:	81 30       	cpi	r24, 0x01	; 1
    71d4:	91 05       	cpc	r25, r1
    71d6:	01 f5       	brne	.+64     	; 0x7218 <Start_solving+0x4b0>
    71d8:	8d a1       	ldd	r24, Y+37	; 0x25
    71da:	9e a1       	ldd	r25, Y+38	; 0x26
    71dc:	88 0f       	add	r24, r24
    71de:	99 1f       	adc	r25, r25
    71e0:	fc 01       	movw	r30, r24
    71e2:	e8 58       	subi	r30, 0x88	; 136
    71e4:	fb 4f       	sbci	r31, 0xFB	; 251
    71e6:	80 81       	ld	r24, Z
    71e8:	91 81       	ldd	r25, Z+1	; 0x01
    71ea:	86 30       	cpi	r24, 0x06	; 6
    71ec:	91 05       	cpc	r25, r1
    71ee:	a4 f0       	brlt	.+40     	; 0x7218 <Start_solving+0x4b0>
    71f0:	8d a1       	ldd	r24, Y+37	; 0x25
    71f2:	9e a1       	ldd	r25, Y+38	; 0x26
    71f4:	88 0f       	add	r24, r24
    71f6:	99 1f       	adc	r25, r25
    71f8:	fc 01       	movw	r30, r24
    71fa:	e8 58       	subi	r30, 0x88	; 136
    71fc:	fb 4f       	sbci	r31, 0xFB	; 251
    71fe:	80 81       	ld	r24, Z
    7200:	91 81       	ldd	r25, Z+1	; 0x01
    7202:	8c 30       	cpi	r24, 0x0C	; 12
    7204:	91 05       	cpc	r25, r1
    7206:	44 f4       	brge	.+16     	; 0x7218 <Start_solving+0x4b0>
			{
				about_turn();
    7208:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <about_turn>
				LED_right=0;
    720c:	10 92 e1 03 	sts	0x03E1, r1
    7210:	10 92 e0 03 	sts	0x03E0, r1
				Right_led_off();
    7214:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Right_led_off>
			}
			
				
		}
		if(LED_left==1)  //if left led is glowing
    7218:	80 91 e2 03 	lds	r24, 0x03E2
    721c:	90 91 e3 03 	lds	r25, 0x03E3
    7220:	81 30       	cpi	r24, 0x01	; 1
    7222:	91 05       	cpc	r25, r1
    7224:	09 f0       	breq	.+2      	; 0x7228 <Start_solving+0x4c0>
    7226:	c0 c0       	rjmp	.+384    	; 0x73a8 <Start_solving+0x640>
		{
			if(((d-1)!=0) && (Grid2[ptr]==0 || Grid2[ptr]==2 || Grid2[ptr]==4 || Grid2[ptr]==19 || Grid2[ptr]==21 || Grid2[ptr]==23))
    7228:	8f 8d       	ldd	r24, Y+31	; 0x1f
    722a:	98 a1       	ldd	r25, Y+32	; 0x20
    722c:	81 30       	cpi	r24, 0x01	; 1
    722e:	91 05       	cpc	r25, r1
    7230:	09 f4       	brne	.+2      	; 0x7234 <Start_solving+0x4cc>
    7232:	4e c0       	rjmp	.+156    	; 0x72d0 <Start_solving+0x568>
    7234:	8d a1       	ldd	r24, Y+37	; 0x25
    7236:	9e a1       	ldd	r25, Y+38	; 0x26
    7238:	88 0f       	add	r24, r24
    723a:	99 1f       	adc	r25, r25
    723c:	fc 01       	movw	r30, r24
    723e:	e8 58       	subi	r30, 0x88	; 136
    7240:	fb 4f       	sbci	r31, 0xFB	; 251
    7242:	80 81       	ld	r24, Z
    7244:	91 81       	ldd	r25, Z+1	; 0x01
    7246:	00 97       	sbiw	r24, 0x00	; 0
    7248:	e1 f1       	breq	.+120    	; 0x72c2 <Start_solving+0x55a>
    724a:	8d a1       	ldd	r24, Y+37	; 0x25
    724c:	9e a1       	ldd	r25, Y+38	; 0x26
    724e:	88 0f       	add	r24, r24
    7250:	99 1f       	adc	r25, r25
    7252:	fc 01       	movw	r30, r24
    7254:	e8 58       	subi	r30, 0x88	; 136
    7256:	fb 4f       	sbci	r31, 0xFB	; 251
    7258:	80 81       	ld	r24, Z
    725a:	91 81       	ldd	r25, Z+1	; 0x01
    725c:	82 30       	cpi	r24, 0x02	; 2
    725e:	91 05       	cpc	r25, r1
    7260:	81 f1       	breq	.+96     	; 0x72c2 <Start_solving+0x55a>
    7262:	8d a1       	ldd	r24, Y+37	; 0x25
    7264:	9e a1       	ldd	r25, Y+38	; 0x26
    7266:	88 0f       	add	r24, r24
    7268:	99 1f       	adc	r25, r25
    726a:	fc 01       	movw	r30, r24
    726c:	e8 58       	subi	r30, 0x88	; 136
    726e:	fb 4f       	sbci	r31, 0xFB	; 251
    7270:	80 81       	ld	r24, Z
    7272:	91 81       	ldd	r25, Z+1	; 0x01
    7274:	84 30       	cpi	r24, 0x04	; 4
    7276:	91 05       	cpc	r25, r1
    7278:	21 f1       	breq	.+72     	; 0x72c2 <Start_solving+0x55a>
    727a:	8d a1       	ldd	r24, Y+37	; 0x25
    727c:	9e a1       	ldd	r25, Y+38	; 0x26
    727e:	88 0f       	add	r24, r24
    7280:	99 1f       	adc	r25, r25
    7282:	fc 01       	movw	r30, r24
    7284:	e8 58       	subi	r30, 0x88	; 136
    7286:	fb 4f       	sbci	r31, 0xFB	; 251
    7288:	80 81       	ld	r24, Z
    728a:	91 81       	ldd	r25, Z+1	; 0x01
    728c:	83 31       	cpi	r24, 0x13	; 19
    728e:	91 05       	cpc	r25, r1
    7290:	c1 f0       	breq	.+48     	; 0x72c2 <Start_solving+0x55a>
    7292:	8d a1       	ldd	r24, Y+37	; 0x25
    7294:	9e a1       	ldd	r25, Y+38	; 0x26
    7296:	88 0f       	add	r24, r24
    7298:	99 1f       	adc	r25, r25
    729a:	fc 01       	movw	r30, r24
    729c:	e8 58       	subi	r30, 0x88	; 136
    729e:	fb 4f       	sbci	r31, 0xFB	; 251
    72a0:	80 81       	ld	r24, Z
    72a2:	91 81       	ldd	r25, Z+1	; 0x01
    72a4:	85 31       	cpi	r24, 0x15	; 21
    72a6:	91 05       	cpc	r25, r1
    72a8:	61 f0       	breq	.+24     	; 0x72c2 <Start_solving+0x55a>
    72aa:	8d a1       	ldd	r24, Y+37	; 0x25
    72ac:	9e a1       	ldd	r25, Y+38	; 0x26
    72ae:	88 0f       	add	r24, r24
    72b0:	99 1f       	adc	r25, r25
    72b2:	fc 01       	movw	r30, r24
    72b4:	e8 58       	subi	r30, 0x88	; 136
    72b6:	fb 4f       	sbci	r31, 0xFB	; 251
    72b8:	80 81       	ld	r24, Z
    72ba:	91 81       	ldd	r25, Z+1	; 0x01
    72bc:	87 31       	cpi	r24, 0x17	; 23
    72be:	91 05       	cpc	r25, r1
    72c0:	39 f4       	brne	.+14     	; 0x72d0 <Start_solving+0x568>
			{
			
				LED_left=0;
    72c2:	10 92 e3 03 	sts	0x03E3, r1
    72c6:	10 92 e2 03 	sts	0x03E2, r1
				Left_led_off();  //turn off left led
    72ca:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <Left_led_off>
    72ce:	6c c0       	rjmp	.+216    	; 0x73a8 <Start_solving+0x640>
			}
			else if((d-1)!=0)
    72d0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    72d2:	98 a1       	ldd	r25, Y+32	; 0x20
    72d4:	81 30       	cpi	r24, 0x01	; 1
    72d6:	91 05       	cpc	r25, r1
    72d8:	c9 f0       	breq	.+50     	; 0x730c <Start_solving+0x5a4>
			{
				about_turn();   //if Glowing LED is on the opposite side of the target_number(number in Grid2) then moves robot 180 degrees.
    72da:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <about_turn>
				if(d>0)       //on turning the co-ordinates needs to be fixed
    72de:	8f 8d       	ldd	r24, Y+31	; 0x1f
    72e0:	98 a1       	ldd	r25, Y+32	; 0x20
    72e2:	18 16       	cp	r1, r24
    72e4:	19 06       	cpc	r1, r25
    72e6:	34 f4       	brge	.+12     	; 0x72f4 <Start_solving+0x58c>
					d=d+1;
    72e8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    72ea:	98 a1       	ldd	r25, Y+32	; 0x20
    72ec:	01 96       	adiw	r24, 0x01	; 1
    72ee:	98 a3       	std	Y+32, r25	; 0x20
    72f0:	8f 8f       	std	Y+31, r24	; 0x1f
    72f2:	05 c0       	rjmp	.+10     	; 0x72fe <Start_solving+0x596>
				else
					d=d-1;
    72f4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    72f6:	98 a1       	ldd	r25, Y+32	; 0x20
    72f8:	01 97       	sbiw	r24, 0x01	; 1
    72fa:	98 a3       	std	Y+32, r25	; 0x20
    72fc:	8f 8f       	std	Y+31, r24	; 0x1f
				LED_left=0;
    72fe:	10 92 e3 03 	sts	0x03E3, r1
    7302:	10 92 e2 03 	sts	0x03E2, r1
				Left_led_off();
    7306:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <Left_led_off>
    730a:	4e c0       	rjmp	.+156    	; 0x73a8 <Start_solving+0x640>
			}
			else if ((d==1) && (Grid2[ptr]>=6 && Grid2[ptr]<=11))
    730c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    730e:	98 a1       	ldd	r25, Y+32	; 0x20
    7310:	81 30       	cpi	r24, 0x01	; 1
    7312:	91 05       	cpc	r25, r1
    7314:	21 f5       	brne	.+72     	; 0x735e <Start_solving+0x5f6>
    7316:	8d a1       	ldd	r24, Y+37	; 0x25
    7318:	9e a1       	ldd	r25, Y+38	; 0x26
    731a:	88 0f       	add	r24, r24
    731c:	99 1f       	adc	r25, r25
    731e:	fc 01       	movw	r30, r24
    7320:	e8 58       	subi	r30, 0x88	; 136
    7322:	fb 4f       	sbci	r31, 0xFB	; 251
    7324:	80 81       	ld	r24, Z
    7326:	91 81       	ldd	r25, Z+1	; 0x01
    7328:	86 30       	cpi	r24, 0x06	; 6
    732a:	91 05       	cpc	r25, r1
    732c:	c4 f0       	brlt	.+48     	; 0x735e <Start_solving+0x5f6>
    732e:	8d a1       	ldd	r24, Y+37	; 0x25
    7330:	9e a1       	ldd	r25, Y+38	; 0x26
    7332:	88 0f       	add	r24, r24
    7334:	99 1f       	adc	r25, r25
    7336:	fc 01       	movw	r30, r24
    7338:	e8 58       	subi	r30, 0x88	; 136
    733a:	fb 4f       	sbci	r31, 0xFB	; 251
    733c:	80 81       	ld	r24, Z
    733e:	91 81       	ldd	r25, Z+1	; 0x01
    7340:	8c 30       	cpi	r24, 0x0C	; 12
    7342:	91 05       	cpc	r25, r1
    7344:	64 f4       	brge	.+24     	; 0x735e <Start_solving+0x5f6>
			{
				Left_led_off();
    7346:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <Left_led_off>
				LED_left=0;
    734a:	10 92 e3 03 	sts	0x03E3, r1
    734e:	10 92 e2 03 	sts	0x03E2, r1
				c--;
    7352:	89 a1       	ldd	r24, Y+33	; 0x21
    7354:	9a a1       	ldd	r25, Y+34	; 0x22
    7356:	01 97       	sbiw	r24, 0x01	; 1
    7358:	9a a3       	std	Y+34, r25	; 0x22
    735a:	89 a3       	std	Y+33, r24	; 0x21
    735c:	25 c0       	rjmp	.+74     	; 0x73a8 <Start_solving+0x640>
			}
			else if((d==1) && (Grid2[ptr]>=12 && Grid2[ptr]<=17))
    735e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7360:	98 a1       	ldd	r25, Y+32	; 0x20
    7362:	81 30       	cpi	r24, 0x01	; 1
    7364:	91 05       	cpc	r25, r1
    7366:	01 f5       	brne	.+64     	; 0x73a8 <Start_solving+0x640>
    7368:	8d a1       	ldd	r24, Y+37	; 0x25
    736a:	9e a1       	ldd	r25, Y+38	; 0x26
    736c:	88 0f       	add	r24, r24
    736e:	99 1f       	adc	r25, r25
    7370:	fc 01       	movw	r30, r24
    7372:	e8 58       	subi	r30, 0x88	; 136
    7374:	fb 4f       	sbci	r31, 0xFB	; 251
    7376:	80 81       	ld	r24, Z
    7378:	91 81       	ldd	r25, Z+1	; 0x01
    737a:	8c 30       	cpi	r24, 0x0C	; 12
    737c:	91 05       	cpc	r25, r1
    737e:	a4 f0       	brlt	.+40     	; 0x73a8 <Start_solving+0x640>
    7380:	8d a1       	ldd	r24, Y+37	; 0x25
    7382:	9e a1       	ldd	r25, Y+38	; 0x26
    7384:	88 0f       	add	r24, r24
    7386:	99 1f       	adc	r25, r25
    7388:	fc 01       	movw	r30, r24
    738a:	e8 58       	subi	r30, 0x88	; 136
    738c:	fb 4f       	sbci	r31, 0xFB	; 251
    738e:	80 81       	ld	r24, Z
    7390:	91 81       	ldd	r25, Z+1	; 0x01
    7392:	82 31       	cpi	r24, 0x12	; 18
    7394:	91 05       	cpc	r25, r1
    7396:	44 f4       	brge	.+16     	; 0x73a8 <Start_solving+0x640>
			{
				about_turn();
    7398:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <about_turn>
				LED_left=0;
    739c:	10 92 e3 03 	sts	0x03E3, r1
    73a0:	10 92 e2 03 	sts	0x03E2, r1
				Left_led_off();
    73a4:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <Left_led_off>
			}
		}		
		Glcd_display(10);    // for displaying "DEPOSITED" on GLCD
    73a8:	8a e0       	ldi	r24, 0x0A	; 10
    73aa:	90 e0       	ldi	r25, 0x00	; 0
    73ac:	0e 94 13 35 	call	0x6a26	; 0x6a26 <Glcd_display>
		nos_deposited_single++;   //increment as number is deposited for single number
    73b0:	8b a5       	ldd	r24, Y+43	; 0x2b
    73b2:	9c a5       	ldd	r25, Y+44	; 0x2c
    73b4:	01 96       	adiw	r24, 0x01	; 1
    73b6:	9c a7       	std	Y+44, r25	; 0x2c
    73b8:	8b a7       	std	Y+43, r24	; 0x2b
		if(nos_deposited_single==num[ptr2])  // if single number is completed then sound buzzer
    73ba:	8b a1       	ldd	r24, Y+35	; 0x23
    73bc:	9c a1       	ldd	r25, Y+36	; 0x24
    73be:	88 0f       	add	r24, r24
    73c0:	99 1f       	adc	r25, r25
    73c2:	fc 01       	movw	r30, r24
    73c4:	e8 52       	subi	r30, 0x28	; 40
    73c6:	fc 4f       	sbci	r31, 0xFC	; 252
    73c8:	20 81       	ld	r18, Z
    73ca:	31 81       	ldd	r19, Z+1	; 0x01
    73cc:	8b a5       	ldd	r24, Y+43	; 0x2b
    73ce:	9c a5       	ldd	r25, Y+44	; 0x2c
    73d0:	28 17       	cp	r18, r24
    73d2:	39 07       	cpc	r19, r25
    73d4:	09 f0       	breq	.+2      	; 0x73d8 <Start_solving+0x670>
    73d6:	f8 c0       	rjmp	.+496    	; 0x75c8 <Start_solving+0x860>
		{
			if(nos_deposited==total_nos - 1)   //for all numbers deposited except last one
    73d8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    73da:	9e 8d       	ldd	r25, Y+30	; 0x1e
    73dc:	9c 01       	movw	r18, r24
    73de:	21 50       	subi	r18, 0x01	; 1
    73e0:	30 40       	sbci	r19, 0x00	; 0
    73e2:	8d a5       	ldd	r24, Y+45	; 0x2d
    73e4:	9e a5       	ldd	r25, Y+46	; 0x2e
    73e6:	28 17       	cp	r18, r24
    73e8:	39 07       	cpc	r19, r25
    73ea:	09 f0       	breq	.+2      	; 0x73ee <Start_solving+0x686>
    73ec:	77 c0       	rjmp	.+238    	; 0x74dc <Start_solving+0x774>
			{
				buzzer_on();
    73ee:	0e 94 5d 26 	call	0x4cba	; 0x4cba <buzzer_on>
    73f2:	80 e0       	ldi	r24, 0x00	; 0
    73f4:	90 e8       	ldi	r25, 0x80	; 128
    73f6:	ab eb       	ldi	r26, 0xBB	; 187
    73f8:	b5 e4       	ldi	r27, 0x45	; 69
    73fa:	89 8f       	std	Y+25, r24	; 0x19
    73fc:	9a 8f       	std	Y+26, r25	; 0x1a
    73fe:	ab 8f       	std	Y+27, r26	; 0x1b
    7400:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7402:	69 8d       	ldd	r22, Y+25	; 0x19
    7404:	7a 8d       	ldd	r23, Y+26	; 0x1a
    7406:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7408:	9c 8d       	ldd	r25, Y+28	; 0x1c
    740a:	26 e6       	ldi	r18, 0x66	; 102
    740c:	36 e6       	ldi	r19, 0x66	; 102
    740e:	46 e6       	ldi	r20, 0x66	; 102
    7410:	55 e4       	ldi	r21, 0x45	; 69
    7412:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    7416:	dc 01       	movw	r26, r24
    7418:	cb 01       	movw	r24, r22
    741a:	8d 8b       	std	Y+21, r24	; 0x15
    741c:	9e 8b       	std	Y+22, r25	; 0x16
    741e:	af 8b       	std	Y+23, r26	; 0x17
    7420:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    7422:	6d 89       	ldd	r22, Y+21	; 0x15
    7424:	7e 89       	ldd	r23, Y+22	; 0x16
    7426:	8f 89       	ldd	r24, Y+23	; 0x17
    7428:	98 8d       	ldd	r25, Y+24	; 0x18
    742a:	20 e0       	ldi	r18, 0x00	; 0
    742c:	30 e0       	ldi	r19, 0x00	; 0
    742e:	40 e8       	ldi	r20, 0x80	; 128
    7430:	5f e3       	ldi	r21, 0x3F	; 63
    7432:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    7436:	88 23       	and	r24, r24
    7438:	2c f4       	brge	.+10     	; 0x7444 <Start_solving+0x6dc>
		__ticks = 1;
    743a:	81 e0       	ldi	r24, 0x01	; 1
    743c:	90 e0       	ldi	r25, 0x00	; 0
    743e:	9c 8b       	std	Y+20, r25	; 0x14
    7440:	8b 8b       	std	Y+19, r24	; 0x13
    7442:	3f c0       	rjmp	.+126    	; 0x74c2 <Start_solving+0x75a>
	else if (__tmp > 65535)
    7444:	6d 89       	ldd	r22, Y+21	; 0x15
    7446:	7e 89       	ldd	r23, Y+22	; 0x16
    7448:	8f 89       	ldd	r24, Y+23	; 0x17
    744a:	98 8d       	ldd	r25, Y+24	; 0x18
    744c:	20 e0       	ldi	r18, 0x00	; 0
    744e:	3f ef       	ldi	r19, 0xFF	; 255
    7450:	4f e7       	ldi	r20, 0x7F	; 127
    7452:	57 e4       	ldi	r21, 0x47	; 71
    7454:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    7458:	18 16       	cp	r1, r24
    745a:	4c f5       	brge	.+82     	; 0x74ae <Start_solving+0x746>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    745c:	69 8d       	ldd	r22, Y+25	; 0x19
    745e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    7460:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7462:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7464:	20 e0       	ldi	r18, 0x00	; 0
    7466:	30 e0       	ldi	r19, 0x00	; 0
    7468:	40 e2       	ldi	r20, 0x20	; 32
    746a:	51 e4       	ldi	r21, 0x41	; 65
    746c:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    7470:	dc 01       	movw	r26, r24
    7472:	cb 01       	movw	r24, r22
    7474:	bc 01       	movw	r22, r24
    7476:	cd 01       	movw	r24, r26
    7478:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    747c:	dc 01       	movw	r26, r24
    747e:	cb 01       	movw	r24, r22
    7480:	9c 8b       	std	Y+20, r25	; 0x14
    7482:	8b 8b       	std	Y+19, r24	; 0x13
    7484:	0f c0       	rjmp	.+30     	; 0x74a4 <Start_solving+0x73c>
    7486:	80 e7       	ldi	r24, 0x70	; 112
    7488:	91 e0       	ldi	r25, 0x01	; 1
    748a:	9a 8b       	std	Y+18, r25	; 0x12
    748c:	89 8b       	std	Y+17, r24	; 0x11
    748e:	89 89       	ldd	r24, Y+17	; 0x11
    7490:	9a 89       	ldd	r25, Y+18	; 0x12
    7492:	01 97       	sbiw	r24, 0x01	; 1
    7494:	f1 f7       	brne	.-4      	; 0x7492 <Start_solving+0x72a>
    7496:	9a 8b       	std	Y+18, r25	; 0x12
    7498:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    749a:	8b 89       	ldd	r24, Y+19	; 0x13
    749c:	9c 89       	ldd	r25, Y+20	; 0x14
    749e:	01 97       	sbiw	r24, 0x01	; 1
    74a0:	9c 8b       	std	Y+20, r25	; 0x14
    74a2:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    74a4:	8b 89       	ldd	r24, Y+19	; 0x13
    74a6:	9c 89       	ldd	r25, Y+20	; 0x14
    74a8:	00 97       	sbiw	r24, 0x00	; 0
    74aa:	69 f7       	brne	.-38     	; 0x7486 <Start_solving+0x71e>
    74ac:	14 c0       	rjmp	.+40     	; 0x74d6 <Start_solving+0x76e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    74ae:	6d 89       	ldd	r22, Y+21	; 0x15
    74b0:	7e 89       	ldd	r23, Y+22	; 0x16
    74b2:	8f 89       	ldd	r24, Y+23	; 0x17
    74b4:	98 8d       	ldd	r25, Y+24	; 0x18
    74b6:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    74ba:	dc 01       	movw	r26, r24
    74bc:	cb 01       	movw	r24, r22
    74be:	9c 8b       	std	Y+20, r25	; 0x14
    74c0:	8b 8b       	std	Y+19, r24	; 0x13
    74c2:	8b 89       	ldd	r24, Y+19	; 0x13
    74c4:	9c 89       	ldd	r25, Y+20	; 0x14
    74c6:	98 8b       	std	Y+16, r25	; 0x10
    74c8:	8f 87       	std	Y+15, r24	; 0x0f
    74ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    74cc:	98 89       	ldd	r25, Y+16	; 0x10
    74ce:	01 97       	sbiw	r24, 0x01	; 1
    74d0:	f1 f7       	brne	.-4      	; 0x74ce <Start_solving+0x766>
    74d2:	98 8b       	std	Y+16, r25	; 0x10
    74d4:	8f 87       	std	Y+15, r24	; 0x0f
				_delay_ms(6000);
				buzzer_off();
    74d6:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <buzzer_off>
    74da:	76 c0       	rjmp	.+236    	; 0x75c8 <Start_solving+0x860>
			}
			else				// for the last number
			{
				buzzer_on();
    74dc:	0e 94 5d 26 	call	0x4cba	; 0x4cba <buzzer_on>
    74e0:	80 e0       	ldi	r24, 0x00	; 0
    74e2:	90 e0       	ldi	r25, 0x00	; 0
    74e4:	aa e7       	ldi	r26, 0x7A	; 122
    74e6:	b4 e4       	ldi	r27, 0x44	; 68
    74e8:	8b 87       	std	Y+11, r24	; 0x0b
    74ea:	9c 87       	std	Y+12, r25	; 0x0c
    74ec:	ad 87       	std	Y+13, r26	; 0x0d
    74ee:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    74f0:	6b 85       	ldd	r22, Y+11	; 0x0b
    74f2:	7c 85       	ldd	r23, Y+12	; 0x0c
    74f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    74f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    74f8:	26 e6       	ldi	r18, 0x66	; 102
    74fa:	36 e6       	ldi	r19, 0x66	; 102
    74fc:	46 e6       	ldi	r20, 0x66	; 102
    74fe:	55 e4       	ldi	r21, 0x45	; 69
    7500:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    7504:	dc 01       	movw	r26, r24
    7506:	cb 01       	movw	r24, r22
    7508:	8f 83       	std	Y+7, r24	; 0x07
    750a:	98 87       	std	Y+8, r25	; 0x08
    750c:	a9 87       	std	Y+9, r26	; 0x09
    750e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7510:	6f 81       	ldd	r22, Y+7	; 0x07
    7512:	78 85       	ldd	r23, Y+8	; 0x08
    7514:	89 85       	ldd	r24, Y+9	; 0x09
    7516:	9a 85       	ldd	r25, Y+10	; 0x0a
    7518:	20 e0       	ldi	r18, 0x00	; 0
    751a:	30 e0       	ldi	r19, 0x00	; 0
    751c:	40 e8       	ldi	r20, 0x80	; 128
    751e:	5f e3       	ldi	r21, 0x3F	; 63
    7520:	0e 94 fe 3e 	call	0x7dfc	; 0x7dfc <__ltsf2>
    7524:	88 23       	and	r24, r24
    7526:	2c f4       	brge	.+10     	; 0x7532 <Start_solving+0x7ca>
		__ticks = 1;
    7528:	81 e0       	ldi	r24, 0x01	; 1
    752a:	90 e0       	ldi	r25, 0x00	; 0
    752c:	9e 83       	std	Y+6, r25	; 0x06
    752e:	8d 83       	std	Y+5, r24	; 0x05
    7530:	3f c0       	rjmp	.+126    	; 0x75b0 <Start_solving+0x848>
	else if (__tmp > 65535)
    7532:	6f 81       	ldd	r22, Y+7	; 0x07
    7534:	78 85       	ldd	r23, Y+8	; 0x08
    7536:	89 85       	ldd	r24, Y+9	; 0x09
    7538:	9a 85       	ldd	r25, Y+10	; 0x0a
    753a:	20 e0       	ldi	r18, 0x00	; 0
    753c:	3f ef       	ldi	r19, 0xFF	; 255
    753e:	4f e7       	ldi	r20, 0x7F	; 127
    7540:	57 e4       	ldi	r21, 0x47	; 71
    7542:	0e 94 9e 3e 	call	0x7d3c	; 0x7d3c <__gtsf2>
    7546:	18 16       	cp	r1, r24
    7548:	4c f5       	brge	.+82     	; 0x759c <Start_solving+0x834>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    754a:	6b 85       	ldd	r22, Y+11	; 0x0b
    754c:	7c 85       	ldd	r23, Y+12	; 0x0c
    754e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7550:	9e 85       	ldd	r25, Y+14	; 0x0e
    7552:	20 e0       	ldi	r18, 0x00	; 0
    7554:	30 e0       	ldi	r19, 0x00	; 0
    7556:	40 e2       	ldi	r20, 0x20	; 32
    7558:	51 e4       	ldi	r21, 0x41	; 65
    755a:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <__mulsf3>
    755e:	dc 01       	movw	r26, r24
    7560:	cb 01       	movw	r24, r22
    7562:	bc 01       	movw	r22, r24
    7564:	cd 01       	movw	r24, r26
    7566:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    756a:	dc 01       	movw	r26, r24
    756c:	cb 01       	movw	r24, r22
    756e:	9e 83       	std	Y+6, r25	; 0x06
    7570:	8d 83       	std	Y+5, r24	; 0x05
    7572:	0f c0       	rjmp	.+30     	; 0x7592 <Start_solving+0x82a>
    7574:	80 e7       	ldi	r24, 0x70	; 112
    7576:	91 e0       	ldi	r25, 0x01	; 1
    7578:	9c 83       	std	Y+4, r25	; 0x04
    757a:	8b 83       	std	Y+3, r24	; 0x03
    757c:	8b 81       	ldd	r24, Y+3	; 0x03
    757e:	9c 81       	ldd	r25, Y+4	; 0x04
    7580:	01 97       	sbiw	r24, 0x01	; 1
    7582:	f1 f7       	brne	.-4      	; 0x7580 <Start_solving+0x818>
    7584:	9c 83       	std	Y+4, r25	; 0x04
    7586:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7588:	8d 81       	ldd	r24, Y+5	; 0x05
    758a:	9e 81       	ldd	r25, Y+6	; 0x06
    758c:	01 97       	sbiw	r24, 0x01	; 1
    758e:	9e 83       	std	Y+6, r25	; 0x06
    7590:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7592:	8d 81       	ldd	r24, Y+5	; 0x05
    7594:	9e 81       	ldd	r25, Y+6	; 0x06
    7596:	00 97       	sbiw	r24, 0x00	; 0
    7598:	69 f7       	brne	.-38     	; 0x7574 <Start_solving+0x80c>
    759a:	14 c0       	rjmp	.+40     	; 0x75c4 <Start_solving+0x85c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    759c:	6f 81       	ldd	r22, Y+7	; 0x07
    759e:	78 85       	ldd	r23, Y+8	; 0x08
    75a0:	89 85       	ldd	r24, Y+9	; 0x09
    75a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    75a4:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fixunssfsi>
    75a8:	dc 01       	movw	r26, r24
    75aa:	cb 01       	movw	r24, r22
    75ac:	9e 83       	std	Y+6, r25	; 0x06
    75ae:	8d 83       	std	Y+5, r24	; 0x05
    75b0:	8d 81       	ldd	r24, Y+5	; 0x05
    75b2:	9e 81       	ldd	r25, Y+6	; 0x06
    75b4:	9a 83       	std	Y+2, r25	; 0x02
    75b6:	89 83       	std	Y+1, r24	; 0x01
    75b8:	89 81       	ldd	r24, Y+1	; 0x01
    75ba:	9a 81       	ldd	r25, Y+2	; 0x02
    75bc:	01 97       	sbiw	r24, 0x01	; 1
    75be:	f1 f7       	brne	.-4      	; 0x75bc <Start_solving+0x854>
    75c0:	9a 83       	std	Y+2, r25	; 0x02
    75c2:	89 83       	std	Y+1, r24	; 0x01
				_delay_ms(1000);
				buzzer_off();
    75c4:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <buzzer_off>
			}
		}
		if(nos_deposited==total_nos - 1)   //if all nos deposited then break from the loop
    75c8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    75ca:	9e 8d       	ldd	r25, Y+30	; 0x1e
    75cc:	9c 01       	movw	r18, r24
    75ce:	21 50       	subi	r18, 0x01	; 1
    75d0:	30 40       	sbci	r19, 0x00	; 0
    75d2:	8d a5       	ldd	r24, Y+45	; 0x2d
    75d4:	9e a5       	ldd	r25, Y+46	; 0x2e
    75d6:	28 17       	cp	r18, r24
    75d8:	39 07       	cpc	r19, r25
    75da:	c1 f0       	breq	.+48     	; 0x760c <Start_solving+0x8a4>
			break;
		move_y_first(c,d,4,1);			//return from grid 2 to grid 1 boundary using bridge
    75dc:	89 a1       	ldd	r24, Y+33	; 0x21
    75de:	9a a1       	ldd	r25, Y+34	; 0x22
    75e0:	2f 8d       	ldd	r18, Y+31	; 0x1f
    75e2:	38 a1       	ldd	r19, Y+32	; 0x20
    75e4:	b9 01       	movw	r22, r18
    75e6:	44 e0       	ldi	r20, 0x04	; 4
    75e8:	50 e0       	ldi	r21, 0x00	; 0
    75ea:	21 e0       	ldi	r18, 0x01	; 1
    75ec:	30 e0       	ldi	r19, 0x00	; 0
    75ee:	0e 94 e5 2c 	call	0x59ca	; 0x59ca <move_y_first>
		nos_deposited++;			//increment the numbers deposited as a whole
    75f2:	8d a5       	ldd	r24, Y+45	; 0x2d
    75f4:	9e a5       	ldd	r25, Y+46	; 0x2e
    75f6:	01 96       	adiw	r24, 0x01	; 1
    75f8:	9e a7       	std	Y+46, r25	; 0x2e
    75fa:	8d a7       	std	Y+45, r24	; 0x2d
	int ptr2=0;   // used to store index of num[] array
	int c,d;   // variable to store co-ordinates	
    int total_nos=num[0]+num[1]+num[2]+num[3];   // storing total numnbers required to sum up and making the numbers in Grid2
	
	
	while(nos_deposited!=total_nos)  // loop until all numnbers are not deposited
    75fc:	2d a5       	ldd	r18, Y+45	; 0x2d
    75fe:	3e a5       	ldd	r19, Y+46	; 0x2e
    7600:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7602:	9e 8d       	ldd	r25, Y+30	; 0x1e
    7604:	28 17       	cp	r18, r24
    7606:	39 07       	cpc	r19, r25
    7608:	09 f0       	breq	.+2      	; 0x760c <Start_solving+0x8a4>
    760a:	db cb       	rjmp	.-2122   	; 0x6dc2 <Start_solving+0x5a>
		move_y_first(c,d,4,1);			//return from grid 2 to grid 1 boundary using bridge
		nos_deposited++;			//increment the numbers deposited as a whole
		
		
	}
}
    760c:	ae 96       	adiw	r28, 0x2e	; 46
    760e:	0f b6       	in	r0, 0x3f	; 63
    7610:	f8 94       	cli
    7612:	de bf       	out	0x3e, r29	; 62
    7614:	0f be       	out	0x3f, r0	; 63
    7616:	cd bf       	out	0x3d, r28	; 61
    7618:	cf 91       	pop	r28
    761a:	df 91       	pop	r29
    761c:	08 95       	ret

0000761e <main>:
* Output: 		    int to inform the caller that the program exited correctly or incorrectly.
* Logic: 			calls "init_devices()" to initailise all device and the while loop keep executing until INT7 interrupt(boot key press) has occured. 
* Example Call:		Called automatically by the Operating System.
*
*/
int main() {
    761e:	df 93       	push	r29
    7620:	cf 93       	push	r28
    7622:	cd b7       	in	r28, 0x3d	; 61
    7624:	de b7       	in	r29, 0x3e	; 62
	init_devices();   
    7626:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <init_devices>
	while(boot_key_press==0)   // loops until boot key is pressed
    762a:	80 91 d6 03 	lds	r24, 0x03D6
    762e:	90 91 d7 03 	lds	r25, 0x03D7
    7632:	00 97       	sbiw	r24, 0x00	; 0
    7634:	d1 f3       	breq	.-12     	; 0x762a <main+0xc>
	{
	}
	Start_solving();  //starts solving the grid
    7636:	0e 94 b4 36 	call	0x6d68	; 0x6d68 <Start_solving>
	return 0;	
    763a:	80 e0       	ldi	r24, 0x00	; 0
    763c:	90 e0       	ldi	r25, 0x00	; 0
}			
    763e:	cf 91       	pop	r28
    7640:	df 91       	pop	r29
    7642:	08 95       	ret

00007644 <__fixunssfsi>:
    7644:	ef 92       	push	r14
    7646:	ff 92       	push	r15
    7648:	0f 93       	push	r16
    764a:	1f 93       	push	r17
    764c:	7b 01       	movw	r14, r22
    764e:	8c 01       	movw	r16, r24
    7650:	20 e0       	ldi	r18, 0x00	; 0
    7652:	30 e0       	ldi	r19, 0x00	; 0
    7654:	40 e0       	ldi	r20, 0x00	; 0
    7656:	5f e4       	ldi	r21, 0x4F	; 79
    7658:	0e 94 ce 3e 	call	0x7d9c	; 0x7d9c <__gesf2>
    765c:	88 23       	and	r24, r24
    765e:	8c f0       	brlt	.+34     	; 0x7682 <__fixunssfsi+0x3e>
    7660:	c8 01       	movw	r24, r16
    7662:	b7 01       	movw	r22, r14
    7664:	20 e0       	ldi	r18, 0x00	; 0
    7666:	30 e0       	ldi	r19, 0x00	; 0
    7668:	40 e0       	ldi	r20, 0x00	; 0
    766a:	5f e4       	ldi	r21, 0x4F	; 79
    766c:	0e 94 9a 3c 	call	0x7934	; 0x7934 <__subsf3>
    7670:	0e 94 2e 3f 	call	0x7e5c	; 0x7e5c <__fixsfsi>
    7674:	9b 01       	movw	r18, r22
    7676:	ac 01       	movw	r20, r24
    7678:	20 50       	subi	r18, 0x00	; 0
    767a:	30 40       	sbci	r19, 0x00	; 0
    767c:	40 40       	sbci	r20, 0x00	; 0
    767e:	50 48       	sbci	r21, 0x80	; 128
    7680:	06 c0       	rjmp	.+12     	; 0x768e <__fixunssfsi+0x4a>
    7682:	c8 01       	movw	r24, r16
    7684:	b7 01       	movw	r22, r14
    7686:	0e 94 2e 3f 	call	0x7e5c	; 0x7e5c <__fixsfsi>
    768a:	9b 01       	movw	r18, r22
    768c:	ac 01       	movw	r20, r24
    768e:	b9 01       	movw	r22, r18
    7690:	ca 01       	movw	r24, r20
    7692:	1f 91       	pop	r17
    7694:	0f 91       	pop	r16
    7696:	ff 90       	pop	r15
    7698:	ef 90       	pop	r14
    769a:	08 95       	ret

0000769c <_fpadd_parts>:
    769c:	a0 e0       	ldi	r26, 0x00	; 0
    769e:	b0 e0       	ldi	r27, 0x00	; 0
    76a0:	e4 e5       	ldi	r30, 0x54	; 84
    76a2:	fb e3       	ldi	r31, 0x3B	; 59
    76a4:	0c 94 04 42 	jmp	0x8408	; 0x8408 <__prologue_saves__>
    76a8:	dc 01       	movw	r26, r24
    76aa:	2b 01       	movw	r4, r22
    76ac:	fa 01       	movw	r30, r20
    76ae:	9c 91       	ld	r25, X
    76b0:	92 30       	cpi	r25, 0x02	; 2
    76b2:	08 f4       	brcc	.+2      	; 0x76b6 <_fpadd_parts+0x1a>
    76b4:	39 c1       	rjmp	.+626    	; 0x7928 <_fpadd_parts+0x28c>
    76b6:	eb 01       	movw	r28, r22
    76b8:	88 81       	ld	r24, Y
    76ba:	82 30       	cpi	r24, 0x02	; 2
    76bc:	08 f4       	brcc	.+2      	; 0x76c0 <_fpadd_parts+0x24>
    76be:	33 c1       	rjmp	.+614    	; 0x7926 <_fpadd_parts+0x28a>
    76c0:	94 30       	cpi	r25, 0x04	; 4
    76c2:	69 f4       	brne	.+26     	; 0x76de <_fpadd_parts+0x42>
    76c4:	84 30       	cpi	r24, 0x04	; 4
    76c6:	09 f0       	breq	.+2      	; 0x76ca <_fpadd_parts+0x2e>
    76c8:	2f c1       	rjmp	.+606    	; 0x7928 <_fpadd_parts+0x28c>
    76ca:	11 96       	adiw	r26, 0x01	; 1
    76cc:	9c 91       	ld	r25, X
    76ce:	11 97       	sbiw	r26, 0x01	; 1
    76d0:	89 81       	ldd	r24, Y+1	; 0x01
    76d2:	98 17       	cp	r25, r24
    76d4:	09 f4       	brne	.+2      	; 0x76d8 <_fpadd_parts+0x3c>
    76d6:	28 c1       	rjmp	.+592    	; 0x7928 <_fpadd_parts+0x28c>
    76d8:	a1 ec       	ldi	r26, 0xC1	; 193
    76da:	b2 e0       	ldi	r27, 0x02	; 2
    76dc:	25 c1       	rjmp	.+586    	; 0x7928 <_fpadd_parts+0x28c>
    76de:	84 30       	cpi	r24, 0x04	; 4
    76e0:	09 f4       	brne	.+2      	; 0x76e4 <_fpadd_parts+0x48>
    76e2:	21 c1       	rjmp	.+578    	; 0x7926 <_fpadd_parts+0x28a>
    76e4:	82 30       	cpi	r24, 0x02	; 2
    76e6:	a9 f4       	brne	.+42     	; 0x7712 <_fpadd_parts+0x76>
    76e8:	92 30       	cpi	r25, 0x02	; 2
    76ea:	09 f0       	breq	.+2      	; 0x76ee <_fpadd_parts+0x52>
    76ec:	1d c1       	rjmp	.+570    	; 0x7928 <_fpadd_parts+0x28c>
    76ee:	9a 01       	movw	r18, r20
    76f0:	ad 01       	movw	r20, r26
    76f2:	88 e0       	ldi	r24, 0x08	; 8
    76f4:	ea 01       	movw	r28, r20
    76f6:	09 90       	ld	r0, Y+
    76f8:	ae 01       	movw	r20, r28
    76fa:	e9 01       	movw	r28, r18
    76fc:	09 92       	st	Y+, r0
    76fe:	9e 01       	movw	r18, r28
    7700:	81 50       	subi	r24, 0x01	; 1
    7702:	c1 f7       	brne	.-16     	; 0x76f4 <_fpadd_parts+0x58>
    7704:	e2 01       	movw	r28, r4
    7706:	89 81       	ldd	r24, Y+1	; 0x01
    7708:	11 96       	adiw	r26, 0x01	; 1
    770a:	9c 91       	ld	r25, X
    770c:	89 23       	and	r24, r25
    770e:	81 83       	std	Z+1, r24	; 0x01
    7710:	08 c1       	rjmp	.+528    	; 0x7922 <_fpadd_parts+0x286>
    7712:	92 30       	cpi	r25, 0x02	; 2
    7714:	09 f4       	brne	.+2      	; 0x7718 <_fpadd_parts+0x7c>
    7716:	07 c1       	rjmp	.+526    	; 0x7926 <_fpadd_parts+0x28a>
    7718:	12 96       	adiw	r26, 0x02	; 2
    771a:	2d 90       	ld	r2, X+
    771c:	3c 90       	ld	r3, X
    771e:	13 97       	sbiw	r26, 0x03	; 3
    7720:	eb 01       	movw	r28, r22
    7722:	8a 81       	ldd	r24, Y+2	; 0x02
    7724:	9b 81       	ldd	r25, Y+3	; 0x03
    7726:	14 96       	adiw	r26, 0x04	; 4
    7728:	ad 90       	ld	r10, X+
    772a:	bd 90       	ld	r11, X+
    772c:	cd 90       	ld	r12, X+
    772e:	dc 90       	ld	r13, X
    7730:	17 97       	sbiw	r26, 0x07	; 7
    7732:	ec 80       	ldd	r14, Y+4	; 0x04
    7734:	fd 80       	ldd	r15, Y+5	; 0x05
    7736:	0e 81       	ldd	r16, Y+6	; 0x06
    7738:	1f 81       	ldd	r17, Y+7	; 0x07
    773a:	91 01       	movw	r18, r2
    773c:	28 1b       	sub	r18, r24
    773e:	39 0b       	sbc	r19, r25
    7740:	b9 01       	movw	r22, r18
    7742:	37 ff       	sbrs	r19, 7
    7744:	04 c0       	rjmp	.+8      	; 0x774e <_fpadd_parts+0xb2>
    7746:	66 27       	eor	r22, r22
    7748:	77 27       	eor	r23, r23
    774a:	62 1b       	sub	r22, r18
    774c:	73 0b       	sbc	r23, r19
    774e:	60 32       	cpi	r22, 0x20	; 32
    7750:	71 05       	cpc	r23, r1
    7752:	0c f0       	brlt	.+2      	; 0x7756 <_fpadd_parts+0xba>
    7754:	61 c0       	rjmp	.+194    	; 0x7818 <_fpadd_parts+0x17c>
    7756:	12 16       	cp	r1, r18
    7758:	13 06       	cpc	r1, r19
    775a:	6c f5       	brge	.+90     	; 0x77b6 <_fpadd_parts+0x11a>
    775c:	37 01       	movw	r6, r14
    775e:	48 01       	movw	r8, r16
    7760:	06 2e       	mov	r0, r22
    7762:	04 c0       	rjmp	.+8      	; 0x776c <_fpadd_parts+0xd0>
    7764:	96 94       	lsr	r9
    7766:	87 94       	ror	r8
    7768:	77 94       	ror	r7
    776a:	67 94       	ror	r6
    776c:	0a 94       	dec	r0
    776e:	d2 f7       	brpl	.-12     	; 0x7764 <_fpadd_parts+0xc8>
    7770:	21 e0       	ldi	r18, 0x01	; 1
    7772:	30 e0       	ldi	r19, 0x00	; 0
    7774:	40 e0       	ldi	r20, 0x00	; 0
    7776:	50 e0       	ldi	r21, 0x00	; 0
    7778:	04 c0       	rjmp	.+8      	; 0x7782 <_fpadd_parts+0xe6>
    777a:	22 0f       	add	r18, r18
    777c:	33 1f       	adc	r19, r19
    777e:	44 1f       	adc	r20, r20
    7780:	55 1f       	adc	r21, r21
    7782:	6a 95       	dec	r22
    7784:	d2 f7       	brpl	.-12     	; 0x777a <_fpadd_parts+0xde>
    7786:	21 50       	subi	r18, 0x01	; 1
    7788:	30 40       	sbci	r19, 0x00	; 0
    778a:	40 40       	sbci	r20, 0x00	; 0
    778c:	50 40       	sbci	r21, 0x00	; 0
    778e:	2e 21       	and	r18, r14
    7790:	3f 21       	and	r19, r15
    7792:	40 23       	and	r20, r16
    7794:	51 23       	and	r21, r17
    7796:	21 15       	cp	r18, r1
    7798:	31 05       	cpc	r19, r1
    779a:	41 05       	cpc	r20, r1
    779c:	51 05       	cpc	r21, r1
    779e:	21 f0       	breq	.+8      	; 0x77a8 <_fpadd_parts+0x10c>
    77a0:	21 e0       	ldi	r18, 0x01	; 1
    77a2:	30 e0       	ldi	r19, 0x00	; 0
    77a4:	40 e0       	ldi	r20, 0x00	; 0
    77a6:	50 e0       	ldi	r21, 0x00	; 0
    77a8:	79 01       	movw	r14, r18
    77aa:	8a 01       	movw	r16, r20
    77ac:	e6 28       	or	r14, r6
    77ae:	f7 28       	or	r15, r7
    77b0:	08 29       	or	r16, r8
    77b2:	19 29       	or	r17, r9
    77b4:	3c c0       	rjmp	.+120    	; 0x782e <_fpadd_parts+0x192>
    77b6:	23 2b       	or	r18, r19
    77b8:	d1 f1       	breq	.+116    	; 0x782e <_fpadd_parts+0x192>
    77ba:	26 0e       	add	r2, r22
    77bc:	37 1e       	adc	r3, r23
    77be:	35 01       	movw	r6, r10
    77c0:	46 01       	movw	r8, r12
    77c2:	06 2e       	mov	r0, r22
    77c4:	04 c0       	rjmp	.+8      	; 0x77ce <_fpadd_parts+0x132>
    77c6:	96 94       	lsr	r9
    77c8:	87 94       	ror	r8
    77ca:	77 94       	ror	r7
    77cc:	67 94       	ror	r6
    77ce:	0a 94       	dec	r0
    77d0:	d2 f7       	brpl	.-12     	; 0x77c6 <_fpadd_parts+0x12a>
    77d2:	21 e0       	ldi	r18, 0x01	; 1
    77d4:	30 e0       	ldi	r19, 0x00	; 0
    77d6:	40 e0       	ldi	r20, 0x00	; 0
    77d8:	50 e0       	ldi	r21, 0x00	; 0
    77da:	04 c0       	rjmp	.+8      	; 0x77e4 <_fpadd_parts+0x148>
    77dc:	22 0f       	add	r18, r18
    77de:	33 1f       	adc	r19, r19
    77e0:	44 1f       	adc	r20, r20
    77e2:	55 1f       	adc	r21, r21
    77e4:	6a 95       	dec	r22
    77e6:	d2 f7       	brpl	.-12     	; 0x77dc <_fpadd_parts+0x140>
    77e8:	21 50       	subi	r18, 0x01	; 1
    77ea:	30 40       	sbci	r19, 0x00	; 0
    77ec:	40 40       	sbci	r20, 0x00	; 0
    77ee:	50 40       	sbci	r21, 0x00	; 0
    77f0:	2a 21       	and	r18, r10
    77f2:	3b 21       	and	r19, r11
    77f4:	4c 21       	and	r20, r12
    77f6:	5d 21       	and	r21, r13
    77f8:	21 15       	cp	r18, r1
    77fa:	31 05       	cpc	r19, r1
    77fc:	41 05       	cpc	r20, r1
    77fe:	51 05       	cpc	r21, r1
    7800:	21 f0       	breq	.+8      	; 0x780a <_fpadd_parts+0x16e>
    7802:	21 e0       	ldi	r18, 0x01	; 1
    7804:	30 e0       	ldi	r19, 0x00	; 0
    7806:	40 e0       	ldi	r20, 0x00	; 0
    7808:	50 e0       	ldi	r21, 0x00	; 0
    780a:	59 01       	movw	r10, r18
    780c:	6a 01       	movw	r12, r20
    780e:	a6 28       	or	r10, r6
    7810:	b7 28       	or	r11, r7
    7812:	c8 28       	or	r12, r8
    7814:	d9 28       	or	r13, r9
    7816:	0b c0       	rjmp	.+22     	; 0x782e <_fpadd_parts+0x192>
    7818:	82 15       	cp	r24, r2
    781a:	93 05       	cpc	r25, r3
    781c:	2c f0       	brlt	.+10     	; 0x7828 <_fpadd_parts+0x18c>
    781e:	1c 01       	movw	r2, r24
    7820:	aa 24       	eor	r10, r10
    7822:	bb 24       	eor	r11, r11
    7824:	65 01       	movw	r12, r10
    7826:	03 c0       	rjmp	.+6      	; 0x782e <_fpadd_parts+0x192>
    7828:	ee 24       	eor	r14, r14
    782a:	ff 24       	eor	r15, r15
    782c:	87 01       	movw	r16, r14
    782e:	11 96       	adiw	r26, 0x01	; 1
    7830:	9c 91       	ld	r25, X
    7832:	d2 01       	movw	r26, r4
    7834:	11 96       	adiw	r26, 0x01	; 1
    7836:	8c 91       	ld	r24, X
    7838:	98 17       	cp	r25, r24
    783a:	09 f4       	brne	.+2      	; 0x783e <_fpadd_parts+0x1a2>
    783c:	45 c0       	rjmp	.+138    	; 0x78c8 <_fpadd_parts+0x22c>
    783e:	99 23       	and	r25, r25
    7840:	39 f0       	breq	.+14     	; 0x7850 <_fpadd_parts+0x1b4>
    7842:	a8 01       	movw	r20, r16
    7844:	97 01       	movw	r18, r14
    7846:	2a 19       	sub	r18, r10
    7848:	3b 09       	sbc	r19, r11
    784a:	4c 09       	sbc	r20, r12
    784c:	5d 09       	sbc	r21, r13
    784e:	06 c0       	rjmp	.+12     	; 0x785c <_fpadd_parts+0x1c0>
    7850:	a6 01       	movw	r20, r12
    7852:	95 01       	movw	r18, r10
    7854:	2e 19       	sub	r18, r14
    7856:	3f 09       	sbc	r19, r15
    7858:	40 0b       	sbc	r20, r16
    785a:	51 0b       	sbc	r21, r17
    785c:	57 fd       	sbrc	r21, 7
    785e:	08 c0       	rjmp	.+16     	; 0x7870 <_fpadd_parts+0x1d4>
    7860:	11 82       	std	Z+1, r1	; 0x01
    7862:	33 82       	std	Z+3, r3	; 0x03
    7864:	22 82       	std	Z+2, r2	; 0x02
    7866:	24 83       	std	Z+4, r18	; 0x04
    7868:	35 83       	std	Z+5, r19	; 0x05
    786a:	46 83       	std	Z+6, r20	; 0x06
    786c:	57 83       	std	Z+7, r21	; 0x07
    786e:	1d c0       	rjmp	.+58     	; 0x78aa <_fpadd_parts+0x20e>
    7870:	81 e0       	ldi	r24, 0x01	; 1
    7872:	81 83       	std	Z+1, r24	; 0x01
    7874:	33 82       	std	Z+3, r3	; 0x03
    7876:	22 82       	std	Z+2, r2	; 0x02
    7878:	88 27       	eor	r24, r24
    787a:	99 27       	eor	r25, r25
    787c:	dc 01       	movw	r26, r24
    787e:	82 1b       	sub	r24, r18
    7880:	93 0b       	sbc	r25, r19
    7882:	a4 0b       	sbc	r26, r20
    7884:	b5 0b       	sbc	r27, r21
    7886:	84 83       	std	Z+4, r24	; 0x04
    7888:	95 83       	std	Z+5, r25	; 0x05
    788a:	a6 83       	std	Z+6, r26	; 0x06
    788c:	b7 83       	std	Z+7, r27	; 0x07
    788e:	0d c0       	rjmp	.+26     	; 0x78aa <_fpadd_parts+0x20e>
    7890:	22 0f       	add	r18, r18
    7892:	33 1f       	adc	r19, r19
    7894:	44 1f       	adc	r20, r20
    7896:	55 1f       	adc	r21, r21
    7898:	24 83       	std	Z+4, r18	; 0x04
    789a:	35 83       	std	Z+5, r19	; 0x05
    789c:	46 83       	std	Z+6, r20	; 0x06
    789e:	57 83       	std	Z+7, r21	; 0x07
    78a0:	82 81       	ldd	r24, Z+2	; 0x02
    78a2:	93 81       	ldd	r25, Z+3	; 0x03
    78a4:	01 97       	sbiw	r24, 0x01	; 1
    78a6:	93 83       	std	Z+3, r25	; 0x03
    78a8:	82 83       	std	Z+2, r24	; 0x02
    78aa:	24 81       	ldd	r18, Z+4	; 0x04
    78ac:	35 81       	ldd	r19, Z+5	; 0x05
    78ae:	46 81       	ldd	r20, Z+6	; 0x06
    78b0:	57 81       	ldd	r21, Z+7	; 0x07
    78b2:	da 01       	movw	r26, r20
    78b4:	c9 01       	movw	r24, r18
    78b6:	01 97       	sbiw	r24, 0x01	; 1
    78b8:	a1 09       	sbc	r26, r1
    78ba:	b1 09       	sbc	r27, r1
    78bc:	8f 5f       	subi	r24, 0xFF	; 255
    78be:	9f 4f       	sbci	r25, 0xFF	; 255
    78c0:	af 4f       	sbci	r26, 0xFF	; 255
    78c2:	bf 43       	sbci	r27, 0x3F	; 63
    78c4:	28 f3       	brcs	.-54     	; 0x7890 <_fpadd_parts+0x1f4>
    78c6:	0b c0       	rjmp	.+22     	; 0x78de <_fpadd_parts+0x242>
    78c8:	91 83       	std	Z+1, r25	; 0x01
    78ca:	33 82       	std	Z+3, r3	; 0x03
    78cc:	22 82       	std	Z+2, r2	; 0x02
    78ce:	ea 0c       	add	r14, r10
    78d0:	fb 1c       	adc	r15, r11
    78d2:	0c 1d       	adc	r16, r12
    78d4:	1d 1d       	adc	r17, r13
    78d6:	e4 82       	std	Z+4, r14	; 0x04
    78d8:	f5 82       	std	Z+5, r15	; 0x05
    78da:	06 83       	std	Z+6, r16	; 0x06
    78dc:	17 83       	std	Z+7, r17	; 0x07
    78de:	83 e0       	ldi	r24, 0x03	; 3
    78e0:	80 83       	st	Z, r24
    78e2:	24 81       	ldd	r18, Z+4	; 0x04
    78e4:	35 81       	ldd	r19, Z+5	; 0x05
    78e6:	46 81       	ldd	r20, Z+6	; 0x06
    78e8:	57 81       	ldd	r21, Z+7	; 0x07
    78ea:	57 ff       	sbrs	r21, 7
    78ec:	1a c0       	rjmp	.+52     	; 0x7922 <_fpadd_parts+0x286>
    78ee:	c9 01       	movw	r24, r18
    78f0:	aa 27       	eor	r26, r26
    78f2:	97 fd       	sbrc	r25, 7
    78f4:	a0 95       	com	r26
    78f6:	ba 2f       	mov	r27, r26
    78f8:	81 70       	andi	r24, 0x01	; 1
    78fa:	90 70       	andi	r25, 0x00	; 0
    78fc:	a0 70       	andi	r26, 0x00	; 0
    78fe:	b0 70       	andi	r27, 0x00	; 0
    7900:	56 95       	lsr	r21
    7902:	47 95       	ror	r20
    7904:	37 95       	ror	r19
    7906:	27 95       	ror	r18
    7908:	82 2b       	or	r24, r18
    790a:	93 2b       	or	r25, r19
    790c:	a4 2b       	or	r26, r20
    790e:	b5 2b       	or	r27, r21
    7910:	84 83       	std	Z+4, r24	; 0x04
    7912:	95 83       	std	Z+5, r25	; 0x05
    7914:	a6 83       	std	Z+6, r26	; 0x06
    7916:	b7 83       	std	Z+7, r27	; 0x07
    7918:	82 81       	ldd	r24, Z+2	; 0x02
    791a:	93 81       	ldd	r25, Z+3	; 0x03
    791c:	01 96       	adiw	r24, 0x01	; 1
    791e:	93 83       	std	Z+3, r25	; 0x03
    7920:	82 83       	std	Z+2, r24	; 0x02
    7922:	df 01       	movw	r26, r30
    7924:	01 c0       	rjmp	.+2      	; 0x7928 <_fpadd_parts+0x28c>
    7926:	d2 01       	movw	r26, r4
    7928:	cd 01       	movw	r24, r26
    792a:	cd b7       	in	r28, 0x3d	; 61
    792c:	de b7       	in	r29, 0x3e	; 62
    792e:	e2 e1       	ldi	r30, 0x12	; 18
    7930:	0c 94 20 42 	jmp	0x8440	; 0x8440 <__epilogue_restores__>

00007934 <__subsf3>:
    7934:	a0 e2       	ldi	r26, 0x20	; 32
    7936:	b0 e0       	ldi	r27, 0x00	; 0
    7938:	e0 ea       	ldi	r30, 0xA0	; 160
    793a:	fc e3       	ldi	r31, 0x3C	; 60
    793c:	0c 94 10 42 	jmp	0x8420	; 0x8420 <__prologue_saves__+0x18>
    7940:	69 83       	std	Y+1, r22	; 0x01
    7942:	7a 83       	std	Y+2, r23	; 0x02
    7944:	8b 83       	std	Y+3, r24	; 0x03
    7946:	9c 83       	std	Y+4, r25	; 0x04
    7948:	2d 83       	std	Y+5, r18	; 0x05
    794a:	3e 83       	std	Y+6, r19	; 0x06
    794c:	4f 83       	std	Y+7, r20	; 0x07
    794e:	58 87       	std	Y+8, r21	; 0x08
    7950:	e9 e0       	ldi	r30, 0x09	; 9
    7952:	ee 2e       	mov	r14, r30
    7954:	f1 2c       	mov	r15, r1
    7956:	ec 0e       	add	r14, r28
    7958:	fd 1e       	adc	r15, r29
    795a:	ce 01       	movw	r24, r28
    795c:	01 96       	adiw	r24, 0x01	; 1
    795e:	b7 01       	movw	r22, r14
    7960:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7964:	8e 01       	movw	r16, r28
    7966:	0f 5e       	subi	r16, 0xEF	; 239
    7968:	1f 4f       	sbci	r17, 0xFF	; 255
    796a:	ce 01       	movw	r24, r28
    796c:	05 96       	adiw	r24, 0x05	; 5
    796e:	b8 01       	movw	r22, r16
    7970:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7974:	8a 89       	ldd	r24, Y+18	; 0x12
    7976:	91 e0       	ldi	r25, 0x01	; 1
    7978:	89 27       	eor	r24, r25
    797a:	8a 8b       	std	Y+18, r24	; 0x12
    797c:	c7 01       	movw	r24, r14
    797e:	b8 01       	movw	r22, r16
    7980:	ae 01       	movw	r20, r28
    7982:	47 5e       	subi	r20, 0xE7	; 231
    7984:	5f 4f       	sbci	r21, 0xFF	; 255
    7986:	0e 94 4e 3b 	call	0x769c	; 0x769c <_fpadd_parts>
    798a:	0e 94 4a 40 	call	0x8094	; 0x8094 <__pack_f>
    798e:	a0 96       	adiw	r28, 0x20	; 32
    7990:	e6 e0       	ldi	r30, 0x06	; 6
    7992:	0c 94 2c 42 	jmp	0x8458	; 0x8458 <__epilogue_restores__+0x18>

00007996 <__addsf3>:
    7996:	a0 e2       	ldi	r26, 0x20	; 32
    7998:	b0 e0       	ldi	r27, 0x00	; 0
    799a:	e1 ed       	ldi	r30, 0xD1	; 209
    799c:	fc e3       	ldi	r31, 0x3C	; 60
    799e:	0c 94 10 42 	jmp	0x8420	; 0x8420 <__prologue_saves__+0x18>
    79a2:	69 83       	std	Y+1, r22	; 0x01
    79a4:	7a 83       	std	Y+2, r23	; 0x02
    79a6:	8b 83       	std	Y+3, r24	; 0x03
    79a8:	9c 83       	std	Y+4, r25	; 0x04
    79aa:	2d 83       	std	Y+5, r18	; 0x05
    79ac:	3e 83       	std	Y+6, r19	; 0x06
    79ae:	4f 83       	std	Y+7, r20	; 0x07
    79b0:	58 87       	std	Y+8, r21	; 0x08
    79b2:	f9 e0       	ldi	r31, 0x09	; 9
    79b4:	ef 2e       	mov	r14, r31
    79b6:	f1 2c       	mov	r15, r1
    79b8:	ec 0e       	add	r14, r28
    79ba:	fd 1e       	adc	r15, r29
    79bc:	ce 01       	movw	r24, r28
    79be:	01 96       	adiw	r24, 0x01	; 1
    79c0:	b7 01       	movw	r22, r14
    79c2:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    79c6:	8e 01       	movw	r16, r28
    79c8:	0f 5e       	subi	r16, 0xEF	; 239
    79ca:	1f 4f       	sbci	r17, 0xFF	; 255
    79cc:	ce 01       	movw	r24, r28
    79ce:	05 96       	adiw	r24, 0x05	; 5
    79d0:	b8 01       	movw	r22, r16
    79d2:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    79d6:	c7 01       	movw	r24, r14
    79d8:	b8 01       	movw	r22, r16
    79da:	ae 01       	movw	r20, r28
    79dc:	47 5e       	subi	r20, 0xE7	; 231
    79de:	5f 4f       	sbci	r21, 0xFF	; 255
    79e0:	0e 94 4e 3b 	call	0x769c	; 0x769c <_fpadd_parts>
    79e4:	0e 94 4a 40 	call	0x8094	; 0x8094 <__pack_f>
    79e8:	a0 96       	adiw	r28, 0x20	; 32
    79ea:	e6 e0       	ldi	r30, 0x06	; 6
    79ec:	0c 94 2c 42 	jmp	0x8458	; 0x8458 <__epilogue_restores__+0x18>

000079f0 <__mulsf3>:
    79f0:	a0 e2       	ldi	r26, 0x20	; 32
    79f2:	b0 e0       	ldi	r27, 0x00	; 0
    79f4:	ee ef       	ldi	r30, 0xFE	; 254
    79f6:	fc e3       	ldi	r31, 0x3C	; 60
    79f8:	0c 94 04 42 	jmp	0x8408	; 0x8408 <__prologue_saves__>
    79fc:	69 83       	std	Y+1, r22	; 0x01
    79fe:	7a 83       	std	Y+2, r23	; 0x02
    7a00:	8b 83       	std	Y+3, r24	; 0x03
    7a02:	9c 83       	std	Y+4, r25	; 0x04
    7a04:	2d 83       	std	Y+5, r18	; 0x05
    7a06:	3e 83       	std	Y+6, r19	; 0x06
    7a08:	4f 83       	std	Y+7, r20	; 0x07
    7a0a:	58 87       	std	Y+8, r21	; 0x08
    7a0c:	ce 01       	movw	r24, r28
    7a0e:	01 96       	adiw	r24, 0x01	; 1
    7a10:	be 01       	movw	r22, r28
    7a12:	67 5f       	subi	r22, 0xF7	; 247
    7a14:	7f 4f       	sbci	r23, 0xFF	; 255
    7a16:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7a1a:	ce 01       	movw	r24, r28
    7a1c:	05 96       	adiw	r24, 0x05	; 5
    7a1e:	be 01       	movw	r22, r28
    7a20:	6f 5e       	subi	r22, 0xEF	; 239
    7a22:	7f 4f       	sbci	r23, 0xFF	; 255
    7a24:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7a28:	99 85       	ldd	r25, Y+9	; 0x09
    7a2a:	92 30       	cpi	r25, 0x02	; 2
    7a2c:	88 f0       	brcs	.+34     	; 0x7a50 <__mulsf3+0x60>
    7a2e:	89 89       	ldd	r24, Y+17	; 0x11
    7a30:	82 30       	cpi	r24, 0x02	; 2
    7a32:	c8 f0       	brcs	.+50     	; 0x7a66 <__mulsf3+0x76>
    7a34:	94 30       	cpi	r25, 0x04	; 4
    7a36:	19 f4       	brne	.+6      	; 0x7a3e <__mulsf3+0x4e>
    7a38:	82 30       	cpi	r24, 0x02	; 2
    7a3a:	51 f4       	brne	.+20     	; 0x7a50 <__mulsf3+0x60>
    7a3c:	04 c0       	rjmp	.+8      	; 0x7a46 <__mulsf3+0x56>
    7a3e:	84 30       	cpi	r24, 0x04	; 4
    7a40:	29 f4       	brne	.+10     	; 0x7a4c <__mulsf3+0x5c>
    7a42:	92 30       	cpi	r25, 0x02	; 2
    7a44:	81 f4       	brne	.+32     	; 0x7a66 <__mulsf3+0x76>
    7a46:	81 ec       	ldi	r24, 0xC1	; 193
    7a48:	92 e0       	ldi	r25, 0x02	; 2
    7a4a:	c6 c0       	rjmp	.+396    	; 0x7bd8 <__mulsf3+0x1e8>
    7a4c:	92 30       	cpi	r25, 0x02	; 2
    7a4e:	49 f4       	brne	.+18     	; 0x7a62 <__mulsf3+0x72>
    7a50:	20 e0       	ldi	r18, 0x00	; 0
    7a52:	9a 85       	ldd	r25, Y+10	; 0x0a
    7a54:	8a 89       	ldd	r24, Y+18	; 0x12
    7a56:	98 13       	cpse	r25, r24
    7a58:	21 e0       	ldi	r18, 0x01	; 1
    7a5a:	2a 87       	std	Y+10, r18	; 0x0a
    7a5c:	ce 01       	movw	r24, r28
    7a5e:	09 96       	adiw	r24, 0x09	; 9
    7a60:	bb c0       	rjmp	.+374    	; 0x7bd8 <__mulsf3+0x1e8>
    7a62:	82 30       	cpi	r24, 0x02	; 2
    7a64:	49 f4       	brne	.+18     	; 0x7a78 <__mulsf3+0x88>
    7a66:	20 e0       	ldi	r18, 0x00	; 0
    7a68:	9a 85       	ldd	r25, Y+10	; 0x0a
    7a6a:	8a 89       	ldd	r24, Y+18	; 0x12
    7a6c:	98 13       	cpse	r25, r24
    7a6e:	21 e0       	ldi	r18, 0x01	; 1
    7a70:	2a 8b       	std	Y+18, r18	; 0x12
    7a72:	ce 01       	movw	r24, r28
    7a74:	41 96       	adiw	r24, 0x11	; 17
    7a76:	b0 c0       	rjmp	.+352    	; 0x7bd8 <__mulsf3+0x1e8>
    7a78:	2d 84       	ldd	r2, Y+13	; 0x0d
    7a7a:	3e 84       	ldd	r3, Y+14	; 0x0e
    7a7c:	4f 84       	ldd	r4, Y+15	; 0x0f
    7a7e:	58 88       	ldd	r5, Y+16	; 0x10
    7a80:	6d 88       	ldd	r6, Y+21	; 0x15
    7a82:	7e 88       	ldd	r7, Y+22	; 0x16
    7a84:	8f 88       	ldd	r8, Y+23	; 0x17
    7a86:	98 8c       	ldd	r9, Y+24	; 0x18
    7a88:	ee 24       	eor	r14, r14
    7a8a:	ff 24       	eor	r15, r15
    7a8c:	87 01       	movw	r16, r14
    7a8e:	aa 24       	eor	r10, r10
    7a90:	bb 24       	eor	r11, r11
    7a92:	65 01       	movw	r12, r10
    7a94:	40 e0       	ldi	r20, 0x00	; 0
    7a96:	50 e0       	ldi	r21, 0x00	; 0
    7a98:	60 e0       	ldi	r22, 0x00	; 0
    7a9a:	70 e0       	ldi	r23, 0x00	; 0
    7a9c:	e0 e0       	ldi	r30, 0x00	; 0
    7a9e:	f0 e0       	ldi	r31, 0x00	; 0
    7aa0:	c1 01       	movw	r24, r2
    7aa2:	81 70       	andi	r24, 0x01	; 1
    7aa4:	90 70       	andi	r25, 0x00	; 0
    7aa6:	89 2b       	or	r24, r25
    7aa8:	e9 f0       	breq	.+58     	; 0x7ae4 <__mulsf3+0xf4>
    7aaa:	e6 0c       	add	r14, r6
    7aac:	f7 1c       	adc	r15, r7
    7aae:	08 1d       	adc	r16, r8
    7ab0:	19 1d       	adc	r17, r9
    7ab2:	9a 01       	movw	r18, r20
    7ab4:	ab 01       	movw	r20, r22
    7ab6:	2a 0d       	add	r18, r10
    7ab8:	3b 1d       	adc	r19, r11
    7aba:	4c 1d       	adc	r20, r12
    7abc:	5d 1d       	adc	r21, r13
    7abe:	80 e0       	ldi	r24, 0x00	; 0
    7ac0:	90 e0       	ldi	r25, 0x00	; 0
    7ac2:	a0 e0       	ldi	r26, 0x00	; 0
    7ac4:	b0 e0       	ldi	r27, 0x00	; 0
    7ac6:	e6 14       	cp	r14, r6
    7ac8:	f7 04       	cpc	r15, r7
    7aca:	08 05       	cpc	r16, r8
    7acc:	19 05       	cpc	r17, r9
    7ace:	20 f4       	brcc	.+8      	; 0x7ad8 <__mulsf3+0xe8>
    7ad0:	81 e0       	ldi	r24, 0x01	; 1
    7ad2:	90 e0       	ldi	r25, 0x00	; 0
    7ad4:	a0 e0       	ldi	r26, 0x00	; 0
    7ad6:	b0 e0       	ldi	r27, 0x00	; 0
    7ad8:	ba 01       	movw	r22, r20
    7ada:	a9 01       	movw	r20, r18
    7adc:	48 0f       	add	r20, r24
    7ade:	59 1f       	adc	r21, r25
    7ae0:	6a 1f       	adc	r22, r26
    7ae2:	7b 1f       	adc	r23, r27
    7ae4:	aa 0c       	add	r10, r10
    7ae6:	bb 1c       	adc	r11, r11
    7ae8:	cc 1c       	adc	r12, r12
    7aea:	dd 1c       	adc	r13, r13
    7aec:	97 fe       	sbrs	r9, 7
    7aee:	08 c0       	rjmp	.+16     	; 0x7b00 <__mulsf3+0x110>
    7af0:	81 e0       	ldi	r24, 0x01	; 1
    7af2:	90 e0       	ldi	r25, 0x00	; 0
    7af4:	a0 e0       	ldi	r26, 0x00	; 0
    7af6:	b0 e0       	ldi	r27, 0x00	; 0
    7af8:	a8 2a       	or	r10, r24
    7afa:	b9 2a       	or	r11, r25
    7afc:	ca 2a       	or	r12, r26
    7afe:	db 2a       	or	r13, r27
    7b00:	31 96       	adiw	r30, 0x01	; 1
    7b02:	e0 32       	cpi	r30, 0x20	; 32
    7b04:	f1 05       	cpc	r31, r1
    7b06:	49 f0       	breq	.+18     	; 0x7b1a <__mulsf3+0x12a>
    7b08:	66 0c       	add	r6, r6
    7b0a:	77 1c       	adc	r7, r7
    7b0c:	88 1c       	adc	r8, r8
    7b0e:	99 1c       	adc	r9, r9
    7b10:	56 94       	lsr	r5
    7b12:	47 94       	ror	r4
    7b14:	37 94       	ror	r3
    7b16:	27 94       	ror	r2
    7b18:	c3 cf       	rjmp	.-122    	; 0x7aa0 <__mulsf3+0xb0>
    7b1a:	fa 85       	ldd	r31, Y+10	; 0x0a
    7b1c:	ea 89       	ldd	r30, Y+18	; 0x12
    7b1e:	2b 89       	ldd	r18, Y+19	; 0x13
    7b20:	3c 89       	ldd	r19, Y+20	; 0x14
    7b22:	8b 85       	ldd	r24, Y+11	; 0x0b
    7b24:	9c 85       	ldd	r25, Y+12	; 0x0c
    7b26:	28 0f       	add	r18, r24
    7b28:	39 1f       	adc	r19, r25
    7b2a:	2e 5f       	subi	r18, 0xFE	; 254
    7b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    7b2e:	17 c0       	rjmp	.+46     	; 0x7b5e <__mulsf3+0x16e>
    7b30:	ca 01       	movw	r24, r20
    7b32:	81 70       	andi	r24, 0x01	; 1
    7b34:	90 70       	andi	r25, 0x00	; 0
    7b36:	89 2b       	or	r24, r25
    7b38:	61 f0       	breq	.+24     	; 0x7b52 <__mulsf3+0x162>
    7b3a:	16 95       	lsr	r17
    7b3c:	07 95       	ror	r16
    7b3e:	f7 94       	ror	r15
    7b40:	e7 94       	ror	r14
    7b42:	80 e0       	ldi	r24, 0x00	; 0
    7b44:	90 e0       	ldi	r25, 0x00	; 0
    7b46:	a0 e0       	ldi	r26, 0x00	; 0
    7b48:	b0 e8       	ldi	r27, 0x80	; 128
    7b4a:	e8 2a       	or	r14, r24
    7b4c:	f9 2a       	or	r15, r25
    7b4e:	0a 2b       	or	r16, r26
    7b50:	1b 2b       	or	r17, r27
    7b52:	76 95       	lsr	r23
    7b54:	67 95       	ror	r22
    7b56:	57 95       	ror	r21
    7b58:	47 95       	ror	r20
    7b5a:	2f 5f       	subi	r18, 0xFF	; 255
    7b5c:	3f 4f       	sbci	r19, 0xFF	; 255
    7b5e:	77 fd       	sbrc	r23, 7
    7b60:	e7 cf       	rjmp	.-50     	; 0x7b30 <__mulsf3+0x140>
    7b62:	0c c0       	rjmp	.+24     	; 0x7b7c <__mulsf3+0x18c>
    7b64:	44 0f       	add	r20, r20
    7b66:	55 1f       	adc	r21, r21
    7b68:	66 1f       	adc	r22, r22
    7b6a:	77 1f       	adc	r23, r23
    7b6c:	17 fd       	sbrc	r17, 7
    7b6e:	41 60       	ori	r20, 0x01	; 1
    7b70:	ee 0c       	add	r14, r14
    7b72:	ff 1c       	adc	r15, r15
    7b74:	00 1f       	adc	r16, r16
    7b76:	11 1f       	adc	r17, r17
    7b78:	21 50       	subi	r18, 0x01	; 1
    7b7a:	30 40       	sbci	r19, 0x00	; 0
    7b7c:	40 30       	cpi	r20, 0x00	; 0
    7b7e:	90 e0       	ldi	r25, 0x00	; 0
    7b80:	59 07       	cpc	r21, r25
    7b82:	90 e0       	ldi	r25, 0x00	; 0
    7b84:	69 07       	cpc	r22, r25
    7b86:	90 e4       	ldi	r25, 0x40	; 64
    7b88:	79 07       	cpc	r23, r25
    7b8a:	60 f3       	brcs	.-40     	; 0x7b64 <__mulsf3+0x174>
    7b8c:	2b 8f       	std	Y+27, r18	; 0x1b
    7b8e:	3c 8f       	std	Y+28, r19	; 0x1c
    7b90:	db 01       	movw	r26, r22
    7b92:	ca 01       	movw	r24, r20
    7b94:	8f 77       	andi	r24, 0x7F	; 127
    7b96:	90 70       	andi	r25, 0x00	; 0
    7b98:	a0 70       	andi	r26, 0x00	; 0
    7b9a:	b0 70       	andi	r27, 0x00	; 0
    7b9c:	80 34       	cpi	r24, 0x40	; 64
    7b9e:	91 05       	cpc	r25, r1
    7ba0:	a1 05       	cpc	r26, r1
    7ba2:	b1 05       	cpc	r27, r1
    7ba4:	61 f4       	brne	.+24     	; 0x7bbe <__mulsf3+0x1ce>
    7ba6:	47 fd       	sbrc	r20, 7
    7ba8:	0a c0       	rjmp	.+20     	; 0x7bbe <__mulsf3+0x1ce>
    7baa:	e1 14       	cp	r14, r1
    7bac:	f1 04       	cpc	r15, r1
    7bae:	01 05       	cpc	r16, r1
    7bb0:	11 05       	cpc	r17, r1
    7bb2:	29 f0       	breq	.+10     	; 0x7bbe <__mulsf3+0x1ce>
    7bb4:	40 5c       	subi	r20, 0xC0	; 192
    7bb6:	5f 4f       	sbci	r21, 0xFF	; 255
    7bb8:	6f 4f       	sbci	r22, 0xFF	; 255
    7bba:	7f 4f       	sbci	r23, 0xFF	; 255
    7bbc:	40 78       	andi	r20, 0x80	; 128
    7bbe:	1a 8e       	std	Y+26, r1	; 0x1a
    7bc0:	fe 17       	cp	r31, r30
    7bc2:	11 f0       	breq	.+4      	; 0x7bc8 <__mulsf3+0x1d8>
    7bc4:	81 e0       	ldi	r24, 0x01	; 1
    7bc6:	8a 8f       	std	Y+26, r24	; 0x1a
    7bc8:	4d 8f       	std	Y+29, r20	; 0x1d
    7bca:	5e 8f       	std	Y+30, r21	; 0x1e
    7bcc:	6f 8f       	std	Y+31, r22	; 0x1f
    7bce:	78 a3       	std	Y+32, r23	; 0x20
    7bd0:	83 e0       	ldi	r24, 0x03	; 3
    7bd2:	89 8f       	std	Y+25, r24	; 0x19
    7bd4:	ce 01       	movw	r24, r28
    7bd6:	49 96       	adiw	r24, 0x19	; 25
    7bd8:	0e 94 4a 40 	call	0x8094	; 0x8094 <__pack_f>
    7bdc:	a0 96       	adiw	r28, 0x20	; 32
    7bde:	e2 e1       	ldi	r30, 0x12	; 18
    7be0:	0c 94 20 42 	jmp	0x8440	; 0x8440 <__epilogue_restores__>

00007be4 <__divsf3>:
    7be4:	a8 e1       	ldi	r26, 0x18	; 24
    7be6:	b0 e0       	ldi	r27, 0x00	; 0
    7be8:	e8 ef       	ldi	r30, 0xF8	; 248
    7bea:	fd e3       	ldi	r31, 0x3D	; 61
    7bec:	0c 94 0c 42 	jmp	0x8418	; 0x8418 <__prologue_saves__+0x10>
    7bf0:	69 83       	std	Y+1, r22	; 0x01
    7bf2:	7a 83       	std	Y+2, r23	; 0x02
    7bf4:	8b 83       	std	Y+3, r24	; 0x03
    7bf6:	9c 83       	std	Y+4, r25	; 0x04
    7bf8:	2d 83       	std	Y+5, r18	; 0x05
    7bfa:	3e 83       	std	Y+6, r19	; 0x06
    7bfc:	4f 83       	std	Y+7, r20	; 0x07
    7bfe:	58 87       	std	Y+8, r21	; 0x08
    7c00:	b9 e0       	ldi	r27, 0x09	; 9
    7c02:	eb 2e       	mov	r14, r27
    7c04:	f1 2c       	mov	r15, r1
    7c06:	ec 0e       	add	r14, r28
    7c08:	fd 1e       	adc	r15, r29
    7c0a:	ce 01       	movw	r24, r28
    7c0c:	01 96       	adiw	r24, 0x01	; 1
    7c0e:	b7 01       	movw	r22, r14
    7c10:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7c14:	8e 01       	movw	r16, r28
    7c16:	0f 5e       	subi	r16, 0xEF	; 239
    7c18:	1f 4f       	sbci	r17, 0xFF	; 255
    7c1a:	ce 01       	movw	r24, r28
    7c1c:	05 96       	adiw	r24, 0x05	; 5
    7c1e:	b8 01       	movw	r22, r16
    7c20:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7c24:	29 85       	ldd	r18, Y+9	; 0x09
    7c26:	22 30       	cpi	r18, 0x02	; 2
    7c28:	08 f4       	brcc	.+2      	; 0x7c2c <__divsf3+0x48>
    7c2a:	7e c0       	rjmp	.+252    	; 0x7d28 <__divsf3+0x144>
    7c2c:	39 89       	ldd	r19, Y+17	; 0x11
    7c2e:	32 30       	cpi	r19, 0x02	; 2
    7c30:	10 f4       	brcc	.+4      	; 0x7c36 <__divsf3+0x52>
    7c32:	b8 01       	movw	r22, r16
    7c34:	7c c0       	rjmp	.+248    	; 0x7d2e <__divsf3+0x14a>
    7c36:	8a 85       	ldd	r24, Y+10	; 0x0a
    7c38:	9a 89       	ldd	r25, Y+18	; 0x12
    7c3a:	89 27       	eor	r24, r25
    7c3c:	8a 87       	std	Y+10, r24	; 0x0a
    7c3e:	24 30       	cpi	r18, 0x04	; 4
    7c40:	11 f0       	breq	.+4      	; 0x7c46 <__divsf3+0x62>
    7c42:	22 30       	cpi	r18, 0x02	; 2
    7c44:	31 f4       	brne	.+12     	; 0x7c52 <__divsf3+0x6e>
    7c46:	23 17       	cp	r18, r19
    7c48:	09 f0       	breq	.+2      	; 0x7c4c <__divsf3+0x68>
    7c4a:	6e c0       	rjmp	.+220    	; 0x7d28 <__divsf3+0x144>
    7c4c:	61 ec       	ldi	r22, 0xC1	; 193
    7c4e:	72 e0       	ldi	r23, 0x02	; 2
    7c50:	6e c0       	rjmp	.+220    	; 0x7d2e <__divsf3+0x14a>
    7c52:	34 30       	cpi	r19, 0x04	; 4
    7c54:	39 f4       	brne	.+14     	; 0x7c64 <__divsf3+0x80>
    7c56:	1d 86       	std	Y+13, r1	; 0x0d
    7c58:	1e 86       	std	Y+14, r1	; 0x0e
    7c5a:	1f 86       	std	Y+15, r1	; 0x0f
    7c5c:	18 8a       	std	Y+16, r1	; 0x10
    7c5e:	1c 86       	std	Y+12, r1	; 0x0c
    7c60:	1b 86       	std	Y+11, r1	; 0x0b
    7c62:	04 c0       	rjmp	.+8      	; 0x7c6c <__divsf3+0x88>
    7c64:	32 30       	cpi	r19, 0x02	; 2
    7c66:	21 f4       	brne	.+8      	; 0x7c70 <__divsf3+0x8c>
    7c68:	84 e0       	ldi	r24, 0x04	; 4
    7c6a:	89 87       	std	Y+9, r24	; 0x09
    7c6c:	b7 01       	movw	r22, r14
    7c6e:	5f c0       	rjmp	.+190    	; 0x7d2e <__divsf3+0x14a>
    7c70:	2b 85       	ldd	r18, Y+11	; 0x0b
    7c72:	3c 85       	ldd	r19, Y+12	; 0x0c
    7c74:	8b 89       	ldd	r24, Y+19	; 0x13
    7c76:	9c 89       	ldd	r25, Y+20	; 0x14
    7c78:	28 1b       	sub	r18, r24
    7c7a:	39 0b       	sbc	r19, r25
    7c7c:	3c 87       	std	Y+12, r19	; 0x0c
    7c7e:	2b 87       	std	Y+11, r18	; 0x0b
    7c80:	ed 84       	ldd	r14, Y+13	; 0x0d
    7c82:	fe 84       	ldd	r15, Y+14	; 0x0e
    7c84:	0f 85       	ldd	r16, Y+15	; 0x0f
    7c86:	18 89       	ldd	r17, Y+16	; 0x10
    7c88:	ad 88       	ldd	r10, Y+21	; 0x15
    7c8a:	be 88       	ldd	r11, Y+22	; 0x16
    7c8c:	cf 88       	ldd	r12, Y+23	; 0x17
    7c8e:	d8 8c       	ldd	r13, Y+24	; 0x18
    7c90:	ea 14       	cp	r14, r10
    7c92:	fb 04       	cpc	r15, r11
    7c94:	0c 05       	cpc	r16, r12
    7c96:	1d 05       	cpc	r17, r13
    7c98:	40 f4       	brcc	.+16     	; 0x7caa <__divsf3+0xc6>
    7c9a:	ee 0c       	add	r14, r14
    7c9c:	ff 1c       	adc	r15, r15
    7c9e:	00 1f       	adc	r16, r16
    7ca0:	11 1f       	adc	r17, r17
    7ca2:	21 50       	subi	r18, 0x01	; 1
    7ca4:	30 40       	sbci	r19, 0x00	; 0
    7ca6:	3c 87       	std	Y+12, r19	; 0x0c
    7ca8:	2b 87       	std	Y+11, r18	; 0x0b
    7caa:	20 e0       	ldi	r18, 0x00	; 0
    7cac:	30 e0       	ldi	r19, 0x00	; 0
    7cae:	40 e0       	ldi	r20, 0x00	; 0
    7cb0:	50 e0       	ldi	r21, 0x00	; 0
    7cb2:	80 e0       	ldi	r24, 0x00	; 0
    7cb4:	90 e0       	ldi	r25, 0x00	; 0
    7cb6:	a0 e0       	ldi	r26, 0x00	; 0
    7cb8:	b0 e4       	ldi	r27, 0x40	; 64
    7cba:	60 e0       	ldi	r22, 0x00	; 0
    7cbc:	70 e0       	ldi	r23, 0x00	; 0
    7cbe:	ea 14       	cp	r14, r10
    7cc0:	fb 04       	cpc	r15, r11
    7cc2:	0c 05       	cpc	r16, r12
    7cc4:	1d 05       	cpc	r17, r13
    7cc6:	40 f0       	brcs	.+16     	; 0x7cd8 <__divsf3+0xf4>
    7cc8:	28 2b       	or	r18, r24
    7cca:	39 2b       	or	r19, r25
    7ccc:	4a 2b       	or	r20, r26
    7cce:	5b 2b       	or	r21, r27
    7cd0:	ea 18       	sub	r14, r10
    7cd2:	fb 08       	sbc	r15, r11
    7cd4:	0c 09       	sbc	r16, r12
    7cd6:	1d 09       	sbc	r17, r13
    7cd8:	b6 95       	lsr	r27
    7cda:	a7 95       	ror	r26
    7cdc:	97 95       	ror	r25
    7cde:	87 95       	ror	r24
    7ce0:	ee 0c       	add	r14, r14
    7ce2:	ff 1c       	adc	r15, r15
    7ce4:	00 1f       	adc	r16, r16
    7ce6:	11 1f       	adc	r17, r17
    7ce8:	6f 5f       	subi	r22, 0xFF	; 255
    7cea:	7f 4f       	sbci	r23, 0xFF	; 255
    7cec:	6f 31       	cpi	r22, 0x1F	; 31
    7cee:	71 05       	cpc	r23, r1
    7cf0:	31 f7       	brne	.-52     	; 0x7cbe <__divsf3+0xda>
    7cf2:	da 01       	movw	r26, r20
    7cf4:	c9 01       	movw	r24, r18
    7cf6:	8f 77       	andi	r24, 0x7F	; 127
    7cf8:	90 70       	andi	r25, 0x00	; 0
    7cfa:	a0 70       	andi	r26, 0x00	; 0
    7cfc:	b0 70       	andi	r27, 0x00	; 0
    7cfe:	80 34       	cpi	r24, 0x40	; 64
    7d00:	91 05       	cpc	r25, r1
    7d02:	a1 05       	cpc	r26, r1
    7d04:	b1 05       	cpc	r27, r1
    7d06:	61 f4       	brne	.+24     	; 0x7d20 <__divsf3+0x13c>
    7d08:	27 fd       	sbrc	r18, 7
    7d0a:	0a c0       	rjmp	.+20     	; 0x7d20 <__divsf3+0x13c>
    7d0c:	e1 14       	cp	r14, r1
    7d0e:	f1 04       	cpc	r15, r1
    7d10:	01 05       	cpc	r16, r1
    7d12:	11 05       	cpc	r17, r1
    7d14:	29 f0       	breq	.+10     	; 0x7d20 <__divsf3+0x13c>
    7d16:	20 5c       	subi	r18, 0xC0	; 192
    7d18:	3f 4f       	sbci	r19, 0xFF	; 255
    7d1a:	4f 4f       	sbci	r20, 0xFF	; 255
    7d1c:	5f 4f       	sbci	r21, 0xFF	; 255
    7d1e:	20 78       	andi	r18, 0x80	; 128
    7d20:	2d 87       	std	Y+13, r18	; 0x0d
    7d22:	3e 87       	std	Y+14, r19	; 0x0e
    7d24:	4f 87       	std	Y+15, r20	; 0x0f
    7d26:	58 8b       	std	Y+16, r21	; 0x10
    7d28:	be 01       	movw	r22, r28
    7d2a:	67 5f       	subi	r22, 0xF7	; 247
    7d2c:	7f 4f       	sbci	r23, 0xFF	; 255
    7d2e:	cb 01       	movw	r24, r22
    7d30:	0e 94 4a 40 	call	0x8094	; 0x8094 <__pack_f>
    7d34:	68 96       	adiw	r28, 0x18	; 24
    7d36:	ea e0       	ldi	r30, 0x0A	; 10
    7d38:	0c 94 28 42 	jmp	0x8450	; 0x8450 <__epilogue_restores__+0x10>

00007d3c <__gtsf2>:
    7d3c:	a8 e1       	ldi	r26, 0x18	; 24
    7d3e:	b0 e0       	ldi	r27, 0x00	; 0
    7d40:	e4 ea       	ldi	r30, 0xA4	; 164
    7d42:	fe e3       	ldi	r31, 0x3E	; 62
    7d44:	0c 94 10 42 	jmp	0x8420	; 0x8420 <__prologue_saves__+0x18>
    7d48:	69 83       	std	Y+1, r22	; 0x01
    7d4a:	7a 83       	std	Y+2, r23	; 0x02
    7d4c:	8b 83       	std	Y+3, r24	; 0x03
    7d4e:	9c 83       	std	Y+4, r25	; 0x04
    7d50:	2d 83       	std	Y+5, r18	; 0x05
    7d52:	3e 83       	std	Y+6, r19	; 0x06
    7d54:	4f 83       	std	Y+7, r20	; 0x07
    7d56:	58 87       	std	Y+8, r21	; 0x08
    7d58:	89 e0       	ldi	r24, 0x09	; 9
    7d5a:	e8 2e       	mov	r14, r24
    7d5c:	f1 2c       	mov	r15, r1
    7d5e:	ec 0e       	add	r14, r28
    7d60:	fd 1e       	adc	r15, r29
    7d62:	ce 01       	movw	r24, r28
    7d64:	01 96       	adiw	r24, 0x01	; 1
    7d66:	b7 01       	movw	r22, r14
    7d68:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7d6c:	8e 01       	movw	r16, r28
    7d6e:	0f 5e       	subi	r16, 0xEF	; 239
    7d70:	1f 4f       	sbci	r17, 0xFF	; 255
    7d72:	ce 01       	movw	r24, r28
    7d74:	05 96       	adiw	r24, 0x05	; 5
    7d76:	b8 01       	movw	r22, r16
    7d78:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7d7c:	89 85       	ldd	r24, Y+9	; 0x09
    7d7e:	82 30       	cpi	r24, 0x02	; 2
    7d80:	40 f0       	brcs	.+16     	; 0x7d92 <__gtsf2+0x56>
    7d82:	89 89       	ldd	r24, Y+17	; 0x11
    7d84:	82 30       	cpi	r24, 0x02	; 2
    7d86:	28 f0       	brcs	.+10     	; 0x7d92 <__gtsf2+0x56>
    7d88:	c7 01       	movw	r24, r14
    7d8a:	b8 01       	movw	r22, r16
    7d8c:	0e 94 97 41 	call	0x832e	; 0x832e <__fpcmp_parts_f>
    7d90:	01 c0       	rjmp	.+2      	; 0x7d94 <__gtsf2+0x58>
    7d92:	8f ef       	ldi	r24, 0xFF	; 255
    7d94:	68 96       	adiw	r28, 0x18	; 24
    7d96:	e6 e0       	ldi	r30, 0x06	; 6
    7d98:	0c 94 2c 42 	jmp	0x8458	; 0x8458 <__epilogue_restores__+0x18>

00007d9c <__gesf2>:
    7d9c:	a8 e1       	ldi	r26, 0x18	; 24
    7d9e:	b0 e0       	ldi	r27, 0x00	; 0
    7da0:	e4 ed       	ldi	r30, 0xD4	; 212
    7da2:	fe e3       	ldi	r31, 0x3E	; 62
    7da4:	0c 94 10 42 	jmp	0x8420	; 0x8420 <__prologue_saves__+0x18>
    7da8:	69 83       	std	Y+1, r22	; 0x01
    7daa:	7a 83       	std	Y+2, r23	; 0x02
    7dac:	8b 83       	std	Y+3, r24	; 0x03
    7dae:	9c 83       	std	Y+4, r25	; 0x04
    7db0:	2d 83       	std	Y+5, r18	; 0x05
    7db2:	3e 83       	std	Y+6, r19	; 0x06
    7db4:	4f 83       	std	Y+7, r20	; 0x07
    7db6:	58 87       	std	Y+8, r21	; 0x08
    7db8:	89 e0       	ldi	r24, 0x09	; 9
    7dba:	e8 2e       	mov	r14, r24
    7dbc:	f1 2c       	mov	r15, r1
    7dbe:	ec 0e       	add	r14, r28
    7dc0:	fd 1e       	adc	r15, r29
    7dc2:	ce 01       	movw	r24, r28
    7dc4:	01 96       	adiw	r24, 0x01	; 1
    7dc6:	b7 01       	movw	r22, r14
    7dc8:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7dcc:	8e 01       	movw	r16, r28
    7dce:	0f 5e       	subi	r16, 0xEF	; 239
    7dd0:	1f 4f       	sbci	r17, 0xFF	; 255
    7dd2:	ce 01       	movw	r24, r28
    7dd4:	05 96       	adiw	r24, 0x05	; 5
    7dd6:	b8 01       	movw	r22, r16
    7dd8:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7ddc:	89 85       	ldd	r24, Y+9	; 0x09
    7dde:	82 30       	cpi	r24, 0x02	; 2
    7de0:	40 f0       	brcs	.+16     	; 0x7df2 <__gesf2+0x56>
    7de2:	89 89       	ldd	r24, Y+17	; 0x11
    7de4:	82 30       	cpi	r24, 0x02	; 2
    7de6:	28 f0       	brcs	.+10     	; 0x7df2 <__gesf2+0x56>
    7de8:	c7 01       	movw	r24, r14
    7dea:	b8 01       	movw	r22, r16
    7dec:	0e 94 97 41 	call	0x832e	; 0x832e <__fpcmp_parts_f>
    7df0:	01 c0       	rjmp	.+2      	; 0x7df4 <__gesf2+0x58>
    7df2:	8f ef       	ldi	r24, 0xFF	; 255
    7df4:	68 96       	adiw	r28, 0x18	; 24
    7df6:	e6 e0       	ldi	r30, 0x06	; 6
    7df8:	0c 94 2c 42 	jmp	0x8458	; 0x8458 <__epilogue_restores__+0x18>

00007dfc <__ltsf2>:
    7dfc:	a8 e1       	ldi	r26, 0x18	; 24
    7dfe:	b0 e0       	ldi	r27, 0x00	; 0
    7e00:	e4 e0       	ldi	r30, 0x04	; 4
    7e02:	ff e3       	ldi	r31, 0x3F	; 63
    7e04:	0c 94 10 42 	jmp	0x8420	; 0x8420 <__prologue_saves__+0x18>
    7e08:	69 83       	std	Y+1, r22	; 0x01
    7e0a:	7a 83       	std	Y+2, r23	; 0x02
    7e0c:	8b 83       	std	Y+3, r24	; 0x03
    7e0e:	9c 83       	std	Y+4, r25	; 0x04
    7e10:	2d 83       	std	Y+5, r18	; 0x05
    7e12:	3e 83       	std	Y+6, r19	; 0x06
    7e14:	4f 83       	std	Y+7, r20	; 0x07
    7e16:	58 87       	std	Y+8, r21	; 0x08
    7e18:	89 e0       	ldi	r24, 0x09	; 9
    7e1a:	e8 2e       	mov	r14, r24
    7e1c:	f1 2c       	mov	r15, r1
    7e1e:	ec 0e       	add	r14, r28
    7e20:	fd 1e       	adc	r15, r29
    7e22:	ce 01       	movw	r24, r28
    7e24:	01 96       	adiw	r24, 0x01	; 1
    7e26:	b7 01       	movw	r22, r14
    7e28:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7e2c:	8e 01       	movw	r16, r28
    7e2e:	0f 5e       	subi	r16, 0xEF	; 239
    7e30:	1f 4f       	sbci	r17, 0xFF	; 255
    7e32:	ce 01       	movw	r24, r28
    7e34:	05 96       	adiw	r24, 0x05	; 5
    7e36:	b8 01       	movw	r22, r16
    7e38:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7e3c:	89 85       	ldd	r24, Y+9	; 0x09
    7e3e:	82 30       	cpi	r24, 0x02	; 2
    7e40:	40 f0       	brcs	.+16     	; 0x7e52 <__ltsf2+0x56>
    7e42:	89 89       	ldd	r24, Y+17	; 0x11
    7e44:	82 30       	cpi	r24, 0x02	; 2
    7e46:	28 f0       	brcs	.+10     	; 0x7e52 <__ltsf2+0x56>
    7e48:	c7 01       	movw	r24, r14
    7e4a:	b8 01       	movw	r22, r16
    7e4c:	0e 94 97 41 	call	0x832e	; 0x832e <__fpcmp_parts_f>
    7e50:	01 c0       	rjmp	.+2      	; 0x7e54 <__ltsf2+0x58>
    7e52:	81 e0       	ldi	r24, 0x01	; 1
    7e54:	68 96       	adiw	r28, 0x18	; 24
    7e56:	e6 e0       	ldi	r30, 0x06	; 6
    7e58:	0c 94 2c 42 	jmp	0x8458	; 0x8458 <__epilogue_restores__+0x18>

00007e5c <__fixsfsi>:
    7e5c:	ac e0       	ldi	r26, 0x0C	; 12
    7e5e:	b0 e0       	ldi	r27, 0x00	; 0
    7e60:	e4 e3       	ldi	r30, 0x34	; 52
    7e62:	ff e3       	ldi	r31, 0x3F	; 63
    7e64:	0c 94 14 42 	jmp	0x8428	; 0x8428 <__prologue_saves__+0x20>
    7e68:	69 83       	std	Y+1, r22	; 0x01
    7e6a:	7a 83       	std	Y+2, r23	; 0x02
    7e6c:	8b 83       	std	Y+3, r24	; 0x03
    7e6e:	9c 83       	std	Y+4, r25	; 0x04
    7e70:	ce 01       	movw	r24, r28
    7e72:	01 96       	adiw	r24, 0x01	; 1
    7e74:	be 01       	movw	r22, r28
    7e76:	6b 5f       	subi	r22, 0xFB	; 251
    7e78:	7f 4f       	sbci	r23, 0xFF	; 255
    7e7a:	0e 94 1f 41 	call	0x823e	; 0x823e <__unpack_f>
    7e7e:	8d 81       	ldd	r24, Y+5	; 0x05
    7e80:	82 30       	cpi	r24, 0x02	; 2
    7e82:	61 f1       	breq	.+88     	; 0x7edc <__fixsfsi+0x80>
    7e84:	82 30       	cpi	r24, 0x02	; 2
    7e86:	50 f1       	brcs	.+84     	; 0x7edc <__fixsfsi+0x80>
    7e88:	84 30       	cpi	r24, 0x04	; 4
    7e8a:	21 f4       	brne	.+8      	; 0x7e94 <__fixsfsi+0x38>
    7e8c:	8e 81       	ldd	r24, Y+6	; 0x06
    7e8e:	88 23       	and	r24, r24
    7e90:	51 f1       	breq	.+84     	; 0x7ee6 <__fixsfsi+0x8a>
    7e92:	2e c0       	rjmp	.+92     	; 0x7ef0 <__fixsfsi+0x94>
    7e94:	2f 81       	ldd	r18, Y+7	; 0x07
    7e96:	38 85       	ldd	r19, Y+8	; 0x08
    7e98:	37 fd       	sbrc	r19, 7
    7e9a:	20 c0       	rjmp	.+64     	; 0x7edc <__fixsfsi+0x80>
    7e9c:	6e 81       	ldd	r22, Y+6	; 0x06
    7e9e:	2f 31       	cpi	r18, 0x1F	; 31
    7ea0:	31 05       	cpc	r19, r1
    7ea2:	1c f0       	brlt	.+6      	; 0x7eaa <__fixsfsi+0x4e>
    7ea4:	66 23       	and	r22, r22
    7ea6:	f9 f0       	breq	.+62     	; 0x7ee6 <__fixsfsi+0x8a>
    7ea8:	23 c0       	rjmp	.+70     	; 0x7ef0 <__fixsfsi+0x94>
    7eaa:	8e e1       	ldi	r24, 0x1E	; 30
    7eac:	90 e0       	ldi	r25, 0x00	; 0
    7eae:	82 1b       	sub	r24, r18
    7eb0:	93 0b       	sbc	r25, r19
    7eb2:	29 85       	ldd	r18, Y+9	; 0x09
    7eb4:	3a 85       	ldd	r19, Y+10	; 0x0a
    7eb6:	4b 85       	ldd	r20, Y+11	; 0x0b
    7eb8:	5c 85       	ldd	r21, Y+12	; 0x0c
    7eba:	04 c0       	rjmp	.+8      	; 0x7ec4 <__fixsfsi+0x68>
    7ebc:	56 95       	lsr	r21
    7ebe:	47 95       	ror	r20
    7ec0:	37 95       	ror	r19
    7ec2:	27 95       	ror	r18
    7ec4:	8a 95       	dec	r24
    7ec6:	d2 f7       	brpl	.-12     	; 0x7ebc <__fixsfsi+0x60>
    7ec8:	66 23       	and	r22, r22
    7eca:	b1 f0       	breq	.+44     	; 0x7ef8 <__fixsfsi+0x9c>
    7ecc:	50 95       	com	r21
    7ece:	40 95       	com	r20
    7ed0:	30 95       	com	r19
    7ed2:	21 95       	neg	r18
    7ed4:	3f 4f       	sbci	r19, 0xFF	; 255
    7ed6:	4f 4f       	sbci	r20, 0xFF	; 255
    7ed8:	5f 4f       	sbci	r21, 0xFF	; 255
    7eda:	0e c0       	rjmp	.+28     	; 0x7ef8 <__fixsfsi+0x9c>
    7edc:	20 e0       	ldi	r18, 0x00	; 0
    7ede:	30 e0       	ldi	r19, 0x00	; 0
    7ee0:	40 e0       	ldi	r20, 0x00	; 0
    7ee2:	50 e0       	ldi	r21, 0x00	; 0
    7ee4:	09 c0       	rjmp	.+18     	; 0x7ef8 <__fixsfsi+0x9c>
    7ee6:	2f ef       	ldi	r18, 0xFF	; 255
    7ee8:	3f ef       	ldi	r19, 0xFF	; 255
    7eea:	4f ef       	ldi	r20, 0xFF	; 255
    7eec:	5f e7       	ldi	r21, 0x7F	; 127
    7eee:	04 c0       	rjmp	.+8      	; 0x7ef8 <__fixsfsi+0x9c>
    7ef0:	20 e0       	ldi	r18, 0x00	; 0
    7ef2:	30 e0       	ldi	r19, 0x00	; 0
    7ef4:	40 e0       	ldi	r20, 0x00	; 0
    7ef6:	50 e8       	ldi	r21, 0x80	; 128
    7ef8:	b9 01       	movw	r22, r18
    7efa:	ca 01       	movw	r24, r20
    7efc:	2c 96       	adiw	r28, 0x0c	; 12
    7efe:	e2 e0       	ldi	r30, 0x02	; 2
    7f00:	0c 94 30 42 	jmp	0x8460	; 0x8460 <__epilogue_restores__+0x20>

00007f04 <__floatunsisf>:
    7f04:	a8 e0       	ldi	r26, 0x08	; 8
    7f06:	b0 e0       	ldi	r27, 0x00	; 0
    7f08:	e8 e8       	ldi	r30, 0x88	; 136
    7f0a:	ff e3       	ldi	r31, 0x3F	; 63
    7f0c:	0c 94 0c 42 	jmp	0x8418	; 0x8418 <__prologue_saves__+0x10>
    7f10:	7b 01       	movw	r14, r22
    7f12:	8c 01       	movw	r16, r24
    7f14:	61 15       	cp	r22, r1
    7f16:	71 05       	cpc	r23, r1
    7f18:	81 05       	cpc	r24, r1
    7f1a:	91 05       	cpc	r25, r1
    7f1c:	19 f4       	brne	.+6      	; 0x7f24 <__floatunsisf+0x20>
    7f1e:	82 e0       	ldi	r24, 0x02	; 2
    7f20:	89 83       	std	Y+1, r24	; 0x01
    7f22:	60 c0       	rjmp	.+192    	; 0x7fe4 <__floatunsisf+0xe0>
    7f24:	83 e0       	ldi	r24, 0x03	; 3
    7f26:	89 83       	std	Y+1, r24	; 0x01
    7f28:	8e e1       	ldi	r24, 0x1E	; 30
    7f2a:	c8 2e       	mov	r12, r24
    7f2c:	d1 2c       	mov	r13, r1
    7f2e:	dc 82       	std	Y+4, r13	; 0x04
    7f30:	cb 82       	std	Y+3, r12	; 0x03
    7f32:	ed 82       	std	Y+5, r14	; 0x05
    7f34:	fe 82       	std	Y+6, r15	; 0x06
    7f36:	0f 83       	std	Y+7, r16	; 0x07
    7f38:	18 87       	std	Y+8, r17	; 0x08
    7f3a:	c8 01       	movw	r24, r16
    7f3c:	b7 01       	movw	r22, r14
    7f3e:	0e 94 fb 3f 	call	0x7ff6	; 0x7ff6 <__clzsi2>
    7f42:	fc 01       	movw	r30, r24
    7f44:	31 97       	sbiw	r30, 0x01	; 1
    7f46:	f7 ff       	sbrs	r31, 7
    7f48:	3b c0       	rjmp	.+118    	; 0x7fc0 <__floatunsisf+0xbc>
    7f4a:	22 27       	eor	r18, r18
    7f4c:	33 27       	eor	r19, r19
    7f4e:	2e 1b       	sub	r18, r30
    7f50:	3f 0b       	sbc	r19, r31
    7f52:	57 01       	movw	r10, r14
    7f54:	68 01       	movw	r12, r16
    7f56:	02 2e       	mov	r0, r18
    7f58:	04 c0       	rjmp	.+8      	; 0x7f62 <__floatunsisf+0x5e>
    7f5a:	d6 94       	lsr	r13
    7f5c:	c7 94       	ror	r12
    7f5e:	b7 94       	ror	r11
    7f60:	a7 94       	ror	r10
    7f62:	0a 94       	dec	r0
    7f64:	d2 f7       	brpl	.-12     	; 0x7f5a <__floatunsisf+0x56>
    7f66:	40 e0       	ldi	r20, 0x00	; 0
    7f68:	50 e0       	ldi	r21, 0x00	; 0
    7f6a:	60 e0       	ldi	r22, 0x00	; 0
    7f6c:	70 e0       	ldi	r23, 0x00	; 0
    7f6e:	81 e0       	ldi	r24, 0x01	; 1
    7f70:	90 e0       	ldi	r25, 0x00	; 0
    7f72:	a0 e0       	ldi	r26, 0x00	; 0
    7f74:	b0 e0       	ldi	r27, 0x00	; 0
    7f76:	04 c0       	rjmp	.+8      	; 0x7f80 <__floatunsisf+0x7c>
    7f78:	88 0f       	add	r24, r24
    7f7a:	99 1f       	adc	r25, r25
    7f7c:	aa 1f       	adc	r26, r26
    7f7e:	bb 1f       	adc	r27, r27
    7f80:	2a 95       	dec	r18
    7f82:	d2 f7       	brpl	.-12     	; 0x7f78 <__floatunsisf+0x74>
    7f84:	01 97       	sbiw	r24, 0x01	; 1
    7f86:	a1 09       	sbc	r26, r1
    7f88:	b1 09       	sbc	r27, r1
    7f8a:	8e 21       	and	r24, r14
    7f8c:	9f 21       	and	r25, r15
    7f8e:	a0 23       	and	r26, r16
    7f90:	b1 23       	and	r27, r17
    7f92:	00 97       	sbiw	r24, 0x00	; 0
    7f94:	a1 05       	cpc	r26, r1
    7f96:	b1 05       	cpc	r27, r1
    7f98:	21 f0       	breq	.+8      	; 0x7fa2 <__floatunsisf+0x9e>
    7f9a:	41 e0       	ldi	r20, 0x01	; 1
    7f9c:	50 e0       	ldi	r21, 0x00	; 0
    7f9e:	60 e0       	ldi	r22, 0x00	; 0
    7fa0:	70 e0       	ldi	r23, 0x00	; 0
    7fa2:	4a 29       	or	r20, r10
    7fa4:	5b 29       	or	r21, r11
    7fa6:	6c 29       	or	r22, r12
    7fa8:	7d 29       	or	r23, r13
    7faa:	4d 83       	std	Y+5, r20	; 0x05
    7fac:	5e 83       	std	Y+6, r21	; 0x06
    7fae:	6f 83       	std	Y+7, r22	; 0x07
    7fb0:	78 87       	std	Y+8, r23	; 0x08
    7fb2:	8e e1       	ldi	r24, 0x1E	; 30
    7fb4:	90 e0       	ldi	r25, 0x00	; 0
    7fb6:	8e 1b       	sub	r24, r30
    7fb8:	9f 0b       	sbc	r25, r31
    7fba:	9c 83       	std	Y+4, r25	; 0x04
    7fbc:	8b 83       	std	Y+3, r24	; 0x03
    7fbe:	12 c0       	rjmp	.+36     	; 0x7fe4 <__floatunsisf+0xe0>
    7fc0:	30 97       	sbiw	r30, 0x00	; 0
    7fc2:	81 f0       	breq	.+32     	; 0x7fe4 <__floatunsisf+0xe0>
    7fc4:	0e 2e       	mov	r0, r30
    7fc6:	04 c0       	rjmp	.+8      	; 0x7fd0 <__floatunsisf+0xcc>
    7fc8:	ee 0c       	add	r14, r14
    7fca:	ff 1c       	adc	r15, r15
    7fcc:	00 1f       	adc	r16, r16
    7fce:	11 1f       	adc	r17, r17
    7fd0:	0a 94       	dec	r0
    7fd2:	d2 f7       	brpl	.-12     	; 0x7fc8 <__floatunsisf+0xc4>
    7fd4:	ed 82       	std	Y+5, r14	; 0x05
    7fd6:	fe 82       	std	Y+6, r15	; 0x06
    7fd8:	0f 83       	std	Y+7, r16	; 0x07
    7fda:	18 87       	std	Y+8, r17	; 0x08
    7fdc:	ce 1a       	sub	r12, r30
    7fde:	df 0a       	sbc	r13, r31
    7fe0:	dc 82       	std	Y+4, r13	; 0x04
    7fe2:	cb 82       	std	Y+3, r12	; 0x03
    7fe4:	1a 82       	std	Y+2, r1	; 0x02
    7fe6:	ce 01       	movw	r24, r28
    7fe8:	01 96       	adiw	r24, 0x01	; 1
    7fea:	0e 94 4a 40 	call	0x8094	; 0x8094 <__pack_f>
    7fee:	28 96       	adiw	r28, 0x08	; 8
    7ff0:	ea e0       	ldi	r30, 0x0A	; 10
    7ff2:	0c 94 28 42 	jmp	0x8450	; 0x8450 <__epilogue_restores__+0x10>

00007ff6 <__clzsi2>:
    7ff6:	ef 92       	push	r14
    7ff8:	ff 92       	push	r15
    7ffa:	0f 93       	push	r16
    7ffc:	1f 93       	push	r17
    7ffe:	7b 01       	movw	r14, r22
    8000:	8c 01       	movw	r16, r24
    8002:	80 e0       	ldi	r24, 0x00	; 0
    8004:	e8 16       	cp	r14, r24
    8006:	80 e0       	ldi	r24, 0x00	; 0
    8008:	f8 06       	cpc	r15, r24
    800a:	81 e0       	ldi	r24, 0x01	; 1
    800c:	08 07       	cpc	r16, r24
    800e:	80 e0       	ldi	r24, 0x00	; 0
    8010:	18 07       	cpc	r17, r24
    8012:	88 f4       	brcc	.+34     	; 0x8036 <__clzsi2+0x40>
    8014:	8f ef       	ldi	r24, 0xFF	; 255
    8016:	e8 16       	cp	r14, r24
    8018:	f1 04       	cpc	r15, r1
    801a:	01 05       	cpc	r16, r1
    801c:	11 05       	cpc	r17, r1
    801e:	31 f0       	breq	.+12     	; 0x802c <__clzsi2+0x36>
    8020:	28 f0       	brcs	.+10     	; 0x802c <__clzsi2+0x36>
    8022:	88 e0       	ldi	r24, 0x08	; 8
    8024:	90 e0       	ldi	r25, 0x00	; 0
    8026:	a0 e0       	ldi	r26, 0x00	; 0
    8028:	b0 e0       	ldi	r27, 0x00	; 0
    802a:	17 c0       	rjmp	.+46     	; 0x805a <__clzsi2+0x64>
    802c:	80 e0       	ldi	r24, 0x00	; 0
    802e:	90 e0       	ldi	r25, 0x00	; 0
    8030:	a0 e0       	ldi	r26, 0x00	; 0
    8032:	b0 e0       	ldi	r27, 0x00	; 0
    8034:	12 c0       	rjmp	.+36     	; 0x805a <__clzsi2+0x64>
    8036:	80 e0       	ldi	r24, 0x00	; 0
    8038:	e8 16       	cp	r14, r24
    803a:	80 e0       	ldi	r24, 0x00	; 0
    803c:	f8 06       	cpc	r15, r24
    803e:	80 e0       	ldi	r24, 0x00	; 0
    8040:	08 07       	cpc	r16, r24
    8042:	81 e0       	ldi	r24, 0x01	; 1
    8044:	18 07       	cpc	r17, r24
    8046:	28 f0       	brcs	.+10     	; 0x8052 <__clzsi2+0x5c>
    8048:	88 e1       	ldi	r24, 0x18	; 24
    804a:	90 e0       	ldi	r25, 0x00	; 0
    804c:	a0 e0       	ldi	r26, 0x00	; 0
    804e:	b0 e0       	ldi	r27, 0x00	; 0
    8050:	04 c0       	rjmp	.+8      	; 0x805a <__clzsi2+0x64>
    8052:	80 e1       	ldi	r24, 0x10	; 16
    8054:	90 e0       	ldi	r25, 0x00	; 0
    8056:	a0 e0       	ldi	r26, 0x00	; 0
    8058:	b0 e0       	ldi	r27, 0x00	; 0
    805a:	20 e2       	ldi	r18, 0x20	; 32
    805c:	30 e0       	ldi	r19, 0x00	; 0
    805e:	40 e0       	ldi	r20, 0x00	; 0
    8060:	50 e0       	ldi	r21, 0x00	; 0
    8062:	28 1b       	sub	r18, r24
    8064:	39 0b       	sbc	r19, r25
    8066:	4a 0b       	sbc	r20, r26
    8068:	5b 0b       	sbc	r21, r27
    806a:	04 c0       	rjmp	.+8      	; 0x8074 <__clzsi2+0x7e>
    806c:	16 95       	lsr	r17
    806e:	07 95       	ror	r16
    8070:	f7 94       	ror	r15
    8072:	e7 94       	ror	r14
    8074:	8a 95       	dec	r24
    8076:	d2 f7       	brpl	.-12     	; 0x806c <__clzsi2+0x76>
    8078:	f7 01       	movw	r30, r14
    807a:	e7 53       	subi	r30, 0x37	; 55
    807c:	fd 4f       	sbci	r31, 0xFD	; 253
    807e:	80 81       	ld	r24, Z
    8080:	28 1b       	sub	r18, r24
    8082:	31 09       	sbc	r19, r1
    8084:	41 09       	sbc	r20, r1
    8086:	51 09       	sbc	r21, r1
    8088:	c9 01       	movw	r24, r18
    808a:	1f 91       	pop	r17
    808c:	0f 91       	pop	r16
    808e:	ff 90       	pop	r15
    8090:	ef 90       	pop	r14
    8092:	08 95       	ret

00008094 <__pack_f>:
    8094:	df 92       	push	r13
    8096:	ef 92       	push	r14
    8098:	ff 92       	push	r15
    809a:	0f 93       	push	r16
    809c:	1f 93       	push	r17
    809e:	fc 01       	movw	r30, r24
    80a0:	e4 80       	ldd	r14, Z+4	; 0x04
    80a2:	f5 80       	ldd	r15, Z+5	; 0x05
    80a4:	06 81       	ldd	r16, Z+6	; 0x06
    80a6:	17 81       	ldd	r17, Z+7	; 0x07
    80a8:	d1 80       	ldd	r13, Z+1	; 0x01
    80aa:	80 81       	ld	r24, Z
    80ac:	82 30       	cpi	r24, 0x02	; 2
    80ae:	48 f4       	brcc	.+18     	; 0x80c2 <__pack_f+0x2e>
    80b0:	80 e0       	ldi	r24, 0x00	; 0
    80b2:	90 e0       	ldi	r25, 0x00	; 0
    80b4:	a0 e1       	ldi	r26, 0x10	; 16
    80b6:	b0 e0       	ldi	r27, 0x00	; 0
    80b8:	e8 2a       	or	r14, r24
    80ba:	f9 2a       	or	r15, r25
    80bc:	0a 2b       	or	r16, r26
    80be:	1b 2b       	or	r17, r27
    80c0:	a5 c0       	rjmp	.+330    	; 0x820c <__pack_f+0x178>
    80c2:	84 30       	cpi	r24, 0x04	; 4
    80c4:	09 f4       	brne	.+2      	; 0x80c8 <__pack_f+0x34>
    80c6:	9f c0       	rjmp	.+318    	; 0x8206 <__pack_f+0x172>
    80c8:	82 30       	cpi	r24, 0x02	; 2
    80ca:	21 f4       	brne	.+8      	; 0x80d4 <__pack_f+0x40>
    80cc:	ee 24       	eor	r14, r14
    80ce:	ff 24       	eor	r15, r15
    80d0:	87 01       	movw	r16, r14
    80d2:	05 c0       	rjmp	.+10     	; 0x80de <__pack_f+0x4a>
    80d4:	e1 14       	cp	r14, r1
    80d6:	f1 04       	cpc	r15, r1
    80d8:	01 05       	cpc	r16, r1
    80da:	11 05       	cpc	r17, r1
    80dc:	19 f4       	brne	.+6      	; 0x80e4 <__pack_f+0x50>
    80de:	e0 e0       	ldi	r30, 0x00	; 0
    80e0:	f0 e0       	ldi	r31, 0x00	; 0
    80e2:	96 c0       	rjmp	.+300    	; 0x8210 <__pack_f+0x17c>
    80e4:	62 81       	ldd	r22, Z+2	; 0x02
    80e6:	73 81       	ldd	r23, Z+3	; 0x03
    80e8:	9f ef       	ldi	r25, 0xFF	; 255
    80ea:	62 38       	cpi	r22, 0x82	; 130
    80ec:	79 07       	cpc	r23, r25
    80ee:	0c f0       	brlt	.+2      	; 0x80f2 <__pack_f+0x5e>
    80f0:	5b c0       	rjmp	.+182    	; 0x81a8 <__pack_f+0x114>
    80f2:	22 e8       	ldi	r18, 0x82	; 130
    80f4:	3f ef       	ldi	r19, 0xFF	; 255
    80f6:	26 1b       	sub	r18, r22
    80f8:	37 0b       	sbc	r19, r23
    80fa:	2a 31       	cpi	r18, 0x1A	; 26
    80fc:	31 05       	cpc	r19, r1
    80fe:	2c f0       	brlt	.+10     	; 0x810a <__pack_f+0x76>
    8100:	20 e0       	ldi	r18, 0x00	; 0
    8102:	30 e0       	ldi	r19, 0x00	; 0
    8104:	40 e0       	ldi	r20, 0x00	; 0
    8106:	50 e0       	ldi	r21, 0x00	; 0
    8108:	2a c0       	rjmp	.+84     	; 0x815e <__pack_f+0xca>
    810a:	b8 01       	movw	r22, r16
    810c:	a7 01       	movw	r20, r14
    810e:	02 2e       	mov	r0, r18
    8110:	04 c0       	rjmp	.+8      	; 0x811a <__pack_f+0x86>
    8112:	76 95       	lsr	r23
    8114:	67 95       	ror	r22
    8116:	57 95       	ror	r21
    8118:	47 95       	ror	r20
    811a:	0a 94       	dec	r0
    811c:	d2 f7       	brpl	.-12     	; 0x8112 <__pack_f+0x7e>
    811e:	81 e0       	ldi	r24, 0x01	; 1
    8120:	90 e0       	ldi	r25, 0x00	; 0
    8122:	a0 e0       	ldi	r26, 0x00	; 0
    8124:	b0 e0       	ldi	r27, 0x00	; 0
    8126:	04 c0       	rjmp	.+8      	; 0x8130 <__pack_f+0x9c>
    8128:	88 0f       	add	r24, r24
    812a:	99 1f       	adc	r25, r25
    812c:	aa 1f       	adc	r26, r26
    812e:	bb 1f       	adc	r27, r27
    8130:	2a 95       	dec	r18
    8132:	d2 f7       	brpl	.-12     	; 0x8128 <__pack_f+0x94>
    8134:	01 97       	sbiw	r24, 0x01	; 1
    8136:	a1 09       	sbc	r26, r1
    8138:	b1 09       	sbc	r27, r1
    813a:	8e 21       	and	r24, r14
    813c:	9f 21       	and	r25, r15
    813e:	a0 23       	and	r26, r16
    8140:	b1 23       	and	r27, r17
    8142:	00 97       	sbiw	r24, 0x00	; 0
    8144:	a1 05       	cpc	r26, r1
    8146:	b1 05       	cpc	r27, r1
    8148:	21 f0       	breq	.+8      	; 0x8152 <__pack_f+0xbe>
    814a:	81 e0       	ldi	r24, 0x01	; 1
    814c:	90 e0       	ldi	r25, 0x00	; 0
    814e:	a0 e0       	ldi	r26, 0x00	; 0
    8150:	b0 e0       	ldi	r27, 0x00	; 0
    8152:	9a 01       	movw	r18, r20
    8154:	ab 01       	movw	r20, r22
    8156:	28 2b       	or	r18, r24
    8158:	39 2b       	or	r19, r25
    815a:	4a 2b       	or	r20, r26
    815c:	5b 2b       	or	r21, r27
    815e:	da 01       	movw	r26, r20
    8160:	c9 01       	movw	r24, r18
    8162:	8f 77       	andi	r24, 0x7F	; 127
    8164:	90 70       	andi	r25, 0x00	; 0
    8166:	a0 70       	andi	r26, 0x00	; 0
    8168:	b0 70       	andi	r27, 0x00	; 0
    816a:	80 34       	cpi	r24, 0x40	; 64
    816c:	91 05       	cpc	r25, r1
    816e:	a1 05       	cpc	r26, r1
    8170:	b1 05       	cpc	r27, r1
    8172:	39 f4       	brne	.+14     	; 0x8182 <__pack_f+0xee>
    8174:	27 ff       	sbrs	r18, 7
    8176:	09 c0       	rjmp	.+18     	; 0x818a <__pack_f+0xf6>
    8178:	20 5c       	subi	r18, 0xC0	; 192
    817a:	3f 4f       	sbci	r19, 0xFF	; 255
    817c:	4f 4f       	sbci	r20, 0xFF	; 255
    817e:	5f 4f       	sbci	r21, 0xFF	; 255
    8180:	04 c0       	rjmp	.+8      	; 0x818a <__pack_f+0xf6>
    8182:	21 5c       	subi	r18, 0xC1	; 193
    8184:	3f 4f       	sbci	r19, 0xFF	; 255
    8186:	4f 4f       	sbci	r20, 0xFF	; 255
    8188:	5f 4f       	sbci	r21, 0xFF	; 255
    818a:	e0 e0       	ldi	r30, 0x00	; 0
    818c:	f0 e0       	ldi	r31, 0x00	; 0
    818e:	20 30       	cpi	r18, 0x00	; 0
    8190:	a0 e0       	ldi	r26, 0x00	; 0
    8192:	3a 07       	cpc	r19, r26
    8194:	a0 e0       	ldi	r26, 0x00	; 0
    8196:	4a 07       	cpc	r20, r26
    8198:	a0 e4       	ldi	r26, 0x40	; 64
    819a:	5a 07       	cpc	r21, r26
    819c:	10 f0       	brcs	.+4      	; 0x81a2 <__pack_f+0x10e>
    819e:	e1 e0       	ldi	r30, 0x01	; 1
    81a0:	f0 e0       	ldi	r31, 0x00	; 0
    81a2:	79 01       	movw	r14, r18
    81a4:	8a 01       	movw	r16, r20
    81a6:	27 c0       	rjmp	.+78     	; 0x81f6 <__pack_f+0x162>
    81a8:	60 38       	cpi	r22, 0x80	; 128
    81aa:	71 05       	cpc	r23, r1
    81ac:	64 f5       	brge	.+88     	; 0x8206 <__pack_f+0x172>
    81ae:	fb 01       	movw	r30, r22
    81b0:	e1 58       	subi	r30, 0x81	; 129
    81b2:	ff 4f       	sbci	r31, 0xFF	; 255
    81b4:	d8 01       	movw	r26, r16
    81b6:	c7 01       	movw	r24, r14
    81b8:	8f 77       	andi	r24, 0x7F	; 127
    81ba:	90 70       	andi	r25, 0x00	; 0
    81bc:	a0 70       	andi	r26, 0x00	; 0
    81be:	b0 70       	andi	r27, 0x00	; 0
    81c0:	80 34       	cpi	r24, 0x40	; 64
    81c2:	91 05       	cpc	r25, r1
    81c4:	a1 05       	cpc	r26, r1
    81c6:	b1 05       	cpc	r27, r1
    81c8:	39 f4       	brne	.+14     	; 0x81d8 <__pack_f+0x144>
    81ca:	e7 fe       	sbrs	r14, 7
    81cc:	0d c0       	rjmp	.+26     	; 0x81e8 <__pack_f+0x154>
    81ce:	80 e4       	ldi	r24, 0x40	; 64
    81d0:	90 e0       	ldi	r25, 0x00	; 0
    81d2:	a0 e0       	ldi	r26, 0x00	; 0
    81d4:	b0 e0       	ldi	r27, 0x00	; 0
    81d6:	04 c0       	rjmp	.+8      	; 0x81e0 <__pack_f+0x14c>
    81d8:	8f e3       	ldi	r24, 0x3F	; 63
    81da:	90 e0       	ldi	r25, 0x00	; 0
    81dc:	a0 e0       	ldi	r26, 0x00	; 0
    81de:	b0 e0       	ldi	r27, 0x00	; 0
    81e0:	e8 0e       	add	r14, r24
    81e2:	f9 1e       	adc	r15, r25
    81e4:	0a 1f       	adc	r16, r26
    81e6:	1b 1f       	adc	r17, r27
    81e8:	17 ff       	sbrs	r17, 7
    81ea:	05 c0       	rjmp	.+10     	; 0x81f6 <__pack_f+0x162>
    81ec:	16 95       	lsr	r17
    81ee:	07 95       	ror	r16
    81f0:	f7 94       	ror	r15
    81f2:	e7 94       	ror	r14
    81f4:	31 96       	adiw	r30, 0x01	; 1
    81f6:	87 e0       	ldi	r24, 0x07	; 7
    81f8:	16 95       	lsr	r17
    81fa:	07 95       	ror	r16
    81fc:	f7 94       	ror	r15
    81fe:	e7 94       	ror	r14
    8200:	8a 95       	dec	r24
    8202:	d1 f7       	brne	.-12     	; 0x81f8 <__pack_f+0x164>
    8204:	05 c0       	rjmp	.+10     	; 0x8210 <__pack_f+0x17c>
    8206:	ee 24       	eor	r14, r14
    8208:	ff 24       	eor	r15, r15
    820a:	87 01       	movw	r16, r14
    820c:	ef ef       	ldi	r30, 0xFF	; 255
    820e:	f0 e0       	ldi	r31, 0x00	; 0
    8210:	6e 2f       	mov	r22, r30
    8212:	67 95       	ror	r22
    8214:	66 27       	eor	r22, r22
    8216:	67 95       	ror	r22
    8218:	90 2f       	mov	r25, r16
    821a:	9f 77       	andi	r25, 0x7F	; 127
    821c:	d7 94       	ror	r13
    821e:	dd 24       	eor	r13, r13
    8220:	d7 94       	ror	r13
    8222:	8e 2f       	mov	r24, r30
    8224:	86 95       	lsr	r24
    8226:	49 2f       	mov	r20, r25
    8228:	46 2b       	or	r20, r22
    822a:	58 2f       	mov	r21, r24
    822c:	5d 29       	or	r21, r13
    822e:	b7 01       	movw	r22, r14
    8230:	ca 01       	movw	r24, r20
    8232:	1f 91       	pop	r17
    8234:	0f 91       	pop	r16
    8236:	ff 90       	pop	r15
    8238:	ef 90       	pop	r14
    823a:	df 90       	pop	r13
    823c:	08 95       	ret

0000823e <__unpack_f>:
    823e:	fc 01       	movw	r30, r24
    8240:	db 01       	movw	r26, r22
    8242:	40 81       	ld	r20, Z
    8244:	51 81       	ldd	r21, Z+1	; 0x01
    8246:	22 81       	ldd	r18, Z+2	; 0x02
    8248:	62 2f       	mov	r22, r18
    824a:	6f 77       	andi	r22, 0x7F	; 127
    824c:	70 e0       	ldi	r23, 0x00	; 0
    824e:	22 1f       	adc	r18, r18
    8250:	22 27       	eor	r18, r18
    8252:	22 1f       	adc	r18, r18
    8254:	93 81       	ldd	r25, Z+3	; 0x03
    8256:	89 2f       	mov	r24, r25
    8258:	88 0f       	add	r24, r24
    825a:	82 2b       	or	r24, r18
    825c:	28 2f       	mov	r18, r24
    825e:	30 e0       	ldi	r19, 0x00	; 0
    8260:	99 1f       	adc	r25, r25
    8262:	99 27       	eor	r25, r25
    8264:	99 1f       	adc	r25, r25
    8266:	11 96       	adiw	r26, 0x01	; 1
    8268:	9c 93       	st	X, r25
    826a:	11 97       	sbiw	r26, 0x01	; 1
    826c:	21 15       	cp	r18, r1
    826e:	31 05       	cpc	r19, r1
    8270:	a9 f5       	brne	.+106    	; 0x82dc <__unpack_f+0x9e>
    8272:	41 15       	cp	r20, r1
    8274:	51 05       	cpc	r21, r1
    8276:	61 05       	cpc	r22, r1
    8278:	71 05       	cpc	r23, r1
    827a:	11 f4       	brne	.+4      	; 0x8280 <__unpack_f+0x42>
    827c:	82 e0       	ldi	r24, 0x02	; 2
    827e:	37 c0       	rjmp	.+110    	; 0x82ee <__unpack_f+0xb0>
    8280:	82 e8       	ldi	r24, 0x82	; 130
    8282:	9f ef       	ldi	r25, 0xFF	; 255
    8284:	13 96       	adiw	r26, 0x03	; 3
    8286:	9c 93       	st	X, r25
    8288:	8e 93       	st	-X, r24
    828a:	12 97       	sbiw	r26, 0x02	; 2
    828c:	9a 01       	movw	r18, r20
    828e:	ab 01       	movw	r20, r22
    8290:	67 e0       	ldi	r22, 0x07	; 7
    8292:	22 0f       	add	r18, r18
    8294:	33 1f       	adc	r19, r19
    8296:	44 1f       	adc	r20, r20
    8298:	55 1f       	adc	r21, r21
    829a:	6a 95       	dec	r22
    829c:	d1 f7       	brne	.-12     	; 0x8292 <__unpack_f+0x54>
    829e:	83 e0       	ldi	r24, 0x03	; 3
    82a0:	8c 93       	st	X, r24
    82a2:	0d c0       	rjmp	.+26     	; 0x82be <__unpack_f+0x80>
    82a4:	22 0f       	add	r18, r18
    82a6:	33 1f       	adc	r19, r19
    82a8:	44 1f       	adc	r20, r20
    82aa:	55 1f       	adc	r21, r21
    82ac:	12 96       	adiw	r26, 0x02	; 2
    82ae:	8d 91       	ld	r24, X+
    82b0:	9c 91       	ld	r25, X
    82b2:	13 97       	sbiw	r26, 0x03	; 3
    82b4:	01 97       	sbiw	r24, 0x01	; 1
    82b6:	13 96       	adiw	r26, 0x03	; 3
    82b8:	9c 93       	st	X, r25
    82ba:	8e 93       	st	-X, r24
    82bc:	12 97       	sbiw	r26, 0x02	; 2
    82be:	20 30       	cpi	r18, 0x00	; 0
    82c0:	80 e0       	ldi	r24, 0x00	; 0
    82c2:	38 07       	cpc	r19, r24
    82c4:	80 e0       	ldi	r24, 0x00	; 0
    82c6:	48 07       	cpc	r20, r24
    82c8:	80 e4       	ldi	r24, 0x40	; 64
    82ca:	58 07       	cpc	r21, r24
    82cc:	58 f3       	brcs	.-42     	; 0x82a4 <__unpack_f+0x66>
    82ce:	14 96       	adiw	r26, 0x04	; 4
    82d0:	2d 93       	st	X+, r18
    82d2:	3d 93       	st	X+, r19
    82d4:	4d 93       	st	X+, r20
    82d6:	5c 93       	st	X, r21
    82d8:	17 97       	sbiw	r26, 0x07	; 7
    82da:	08 95       	ret
    82dc:	2f 3f       	cpi	r18, 0xFF	; 255
    82de:	31 05       	cpc	r19, r1
    82e0:	79 f4       	brne	.+30     	; 0x8300 <__unpack_f+0xc2>
    82e2:	41 15       	cp	r20, r1
    82e4:	51 05       	cpc	r21, r1
    82e6:	61 05       	cpc	r22, r1
    82e8:	71 05       	cpc	r23, r1
    82ea:	19 f4       	brne	.+6      	; 0x82f2 <__unpack_f+0xb4>
    82ec:	84 e0       	ldi	r24, 0x04	; 4
    82ee:	8c 93       	st	X, r24
    82f0:	08 95       	ret
    82f2:	64 ff       	sbrs	r22, 4
    82f4:	03 c0       	rjmp	.+6      	; 0x82fc <__unpack_f+0xbe>
    82f6:	81 e0       	ldi	r24, 0x01	; 1
    82f8:	8c 93       	st	X, r24
    82fa:	12 c0       	rjmp	.+36     	; 0x8320 <__unpack_f+0xe2>
    82fc:	1c 92       	st	X, r1
    82fe:	10 c0       	rjmp	.+32     	; 0x8320 <__unpack_f+0xe2>
    8300:	2f 57       	subi	r18, 0x7F	; 127
    8302:	30 40       	sbci	r19, 0x00	; 0
    8304:	13 96       	adiw	r26, 0x03	; 3
    8306:	3c 93       	st	X, r19
    8308:	2e 93       	st	-X, r18
    830a:	12 97       	sbiw	r26, 0x02	; 2
    830c:	83 e0       	ldi	r24, 0x03	; 3
    830e:	8c 93       	st	X, r24
    8310:	87 e0       	ldi	r24, 0x07	; 7
    8312:	44 0f       	add	r20, r20
    8314:	55 1f       	adc	r21, r21
    8316:	66 1f       	adc	r22, r22
    8318:	77 1f       	adc	r23, r23
    831a:	8a 95       	dec	r24
    831c:	d1 f7       	brne	.-12     	; 0x8312 <__unpack_f+0xd4>
    831e:	70 64       	ori	r23, 0x40	; 64
    8320:	14 96       	adiw	r26, 0x04	; 4
    8322:	4d 93       	st	X+, r20
    8324:	5d 93       	st	X+, r21
    8326:	6d 93       	st	X+, r22
    8328:	7c 93       	st	X, r23
    832a:	17 97       	sbiw	r26, 0x07	; 7
    832c:	08 95       	ret

0000832e <__fpcmp_parts_f>:
    832e:	1f 93       	push	r17
    8330:	dc 01       	movw	r26, r24
    8332:	fb 01       	movw	r30, r22
    8334:	9c 91       	ld	r25, X
    8336:	92 30       	cpi	r25, 0x02	; 2
    8338:	08 f4       	brcc	.+2      	; 0x833c <__fpcmp_parts_f+0xe>
    833a:	47 c0       	rjmp	.+142    	; 0x83ca <__fpcmp_parts_f+0x9c>
    833c:	80 81       	ld	r24, Z
    833e:	82 30       	cpi	r24, 0x02	; 2
    8340:	08 f4       	brcc	.+2      	; 0x8344 <__fpcmp_parts_f+0x16>
    8342:	43 c0       	rjmp	.+134    	; 0x83ca <__fpcmp_parts_f+0x9c>
    8344:	94 30       	cpi	r25, 0x04	; 4
    8346:	51 f4       	brne	.+20     	; 0x835c <__fpcmp_parts_f+0x2e>
    8348:	11 96       	adiw	r26, 0x01	; 1
    834a:	1c 91       	ld	r17, X
    834c:	84 30       	cpi	r24, 0x04	; 4
    834e:	99 f5       	brne	.+102    	; 0x83b6 <__fpcmp_parts_f+0x88>
    8350:	81 81       	ldd	r24, Z+1	; 0x01
    8352:	68 2f       	mov	r22, r24
    8354:	70 e0       	ldi	r23, 0x00	; 0
    8356:	61 1b       	sub	r22, r17
    8358:	71 09       	sbc	r23, r1
    835a:	3f c0       	rjmp	.+126    	; 0x83da <__fpcmp_parts_f+0xac>
    835c:	84 30       	cpi	r24, 0x04	; 4
    835e:	21 f0       	breq	.+8      	; 0x8368 <__fpcmp_parts_f+0x3a>
    8360:	92 30       	cpi	r25, 0x02	; 2
    8362:	31 f4       	brne	.+12     	; 0x8370 <__fpcmp_parts_f+0x42>
    8364:	82 30       	cpi	r24, 0x02	; 2
    8366:	b9 f1       	breq	.+110    	; 0x83d6 <__fpcmp_parts_f+0xa8>
    8368:	81 81       	ldd	r24, Z+1	; 0x01
    836a:	88 23       	and	r24, r24
    836c:	89 f1       	breq	.+98     	; 0x83d0 <__fpcmp_parts_f+0xa2>
    836e:	2d c0       	rjmp	.+90     	; 0x83ca <__fpcmp_parts_f+0x9c>
    8370:	11 96       	adiw	r26, 0x01	; 1
    8372:	1c 91       	ld	r17, X
    8374:	11 97       	sbiw	r26, 0x01	; 1
    8376:	82 30       	cpi	r24, 0x02	; 2
    8378:	f1 f0       	breq	.+60     	; 0x83b6 <__fpcmp_parts_f+0x88>
    837a:	81 81       	ldd	r24, Z+1	; 0x01
    837c:	18 17       	cp	r17, r24
    837e:	d9 f4       	brne	.+54     	; 0x83b6 <__fpcmp_parts_f+0x88>
    8380:	12 96       	adiw	r26, 0x02	; 2
    8382:	2d 91       	ld	r18, X+
    8384:	3c 91       	ld	r19, X
    8386:	13 97       	sbiw	r26, 0x03	; 3
    8388:	82 81       	ldd	r24, Z+2	; 0x02
    838a:	93 81       	ldd	r25, Z+3	; 0x03
    838c:	82 17       	cp	r24, r18
    838e:	93 07       	cpc	r25, r19
    8390:	94 f0       	brlt	.+36     	; 0x83b6 <__fpcmp_parts_f+0x88>
    8392:	28 17       	cp	r18, r24
    8394:	39 07       	cpc	r19, r25
    8396:	bc f0       	brlt	.+46     	; 0x83c6 <__fpcmp_parts_f+0x98>
    8398:	14 96       	adiw	r26, 0x04	; 4
    839a:	8d 91       	ld	r24, X+
    839c:	9d 91       	ld	r25, X+
    839e:	0d 90       	ld	r0, X+
    83a0:	bc 91       	ld	r27, X
    83a2:	a0 2d       	mov	r26, r0
    83a4:	24 81       	ldd	r18, Z+4	; 0x04
    83a6:	35 81       	ldd	r19, Z+5	; 0x05
    83a8:	46 81       	ldd	r20, Z+6	; 0x06
    83aa:	57 81       	ldd	r21, Z+7	; 0x07
    83ac:	28 17       	cp	r18, r24
    83ae:	39 07       	cpc	r19, r25
    83b0:	4a 07       	cpc	r20, r26
    83b2:	5b 07       	cpc	r21, r27
    83b4:	18 f4       	brcc	.+6      	; 0x83bc <__fpcmp_parts_f+0x8e>
    83b6:	11 23       	and	r17, r17
    83b8:	41 f0       	breq	.+16     	; 0x83ca <__fpcmp_parts_f+0x9c>
    83ba:	0a c0       	rjmp	.+20     	; 0x83d0 <__fpcmp_parts_f+0xa2>
    83bc:	82 17       	cp	r24, r18
    83be:	93 07       	cpc	r25, r19
    83c0:	a4 07       	cpc	r26, r20
    83c2:	b5 07       	cpc	r27, r21
    83c4:	40 f4       	brcc	.+16     	; 0x83d6 <__fpcmp_parts_f+0xa8>
    83c6:	11 23       	and	r17, r17
    83c8:	19 f0       	breq	.+6      	; 0x83d0 <__fpcmp_parts_f+0xa2>
    83ca:	61 e0       	ldi	r22, 0x01	; 1
    83cc:	70 e0       	ldi	r23, 0x00	; 0
    83ce:	05 c0       	rjmp	.+10     	; 0x83da <__fpcmp_parts_f+0xac>
    83d0:	6f ef       	ldi	r22, 0xFF	; 255
    83d2:	7f ef       	ldi	r23, 0xFF	; 255
    83d4:	02 c0       	rjmp	.+4      	; 0x83da <__fpcmp_parts_f+0xac>
    83d6:	60 e0       	ldi	r22, 0x00	; 0
    83d8:	70 e0       	ldi	r23, 0x00	; 0
    83da:	cb 01       	movw	r24, r22
    83dc:	1f 91       	pop	r17
    83de:	08 95       	ret

000083e0 <__udivmodhi4>:
    83e0:	aa 1b       	sub	r26, r26
    83e2:	bb 1b       	sub	r27, r27
    83e4:	51 e1       	ldi	r21, 0x11	; 17
    83e6:	07 c0       	rjmp	.+14     	; 0x83f6 <__udivmodhi4_ep>

000083e8 <__udivmodhi4_loop>:
    83e8:	aa 1f       	adc	r26, r26
    83ea:	bb 1f       	adc	r27, r27
    83ec:	a6 17       	cp	r26, r22
    83ee:	b7 07       	cpc	r27, r23
    83f0:	10 f0       	brcs	.+4      	; 0x83f6 <__udivmodhi4_ep>
    83f2:	a6 1b       	sub	r26, r22
    83f4:	b7 0b       	sbc	r27, r23

000083f6 <__udivmodhi4_ep>:
    83f6:	88 1f       	adc	r24, r24
    83f8:	99 1f       	adc	r25, r25
    83fa:	5a 95       	dec	r21
    83fc:	a9 f7       	brne	.-22     	; 0x83e8 <__udivmodhi4_loop>
    83fe:	80 95       	com	r24
    8400:	90 95       	com	r25
    8402:	bc 01       	movw	r22, r24
    8404:	cd 01       	movw	r24, r26
    8406:	08 95       	ret

00008408 <__prologue_saves__>:
    8408:	2f 92       	push	r2
    840a:	3f 92       	push	r3
    840c:	4f 92       	push	r4
    840e:	5f 92       	push	r5
    8410:	6f 92       	push	r6
    8412:	7f 92       	push	r7
    8414:	8f 92       	push	r8
    8416:	9f 92       	push	r9
    8418:	af 92       	push	r10
    841a:	bf 92       	push	r11
    841c:	cf 92       	push	r12
    841e:	df 92       	push	r13
    8420:	ef 92       	push	r14
    8422:	ff 92       	push	r15
    8424:	0f 93       	push	r16
    8426:	1f 93       	push	r17
    8428:	cf 93       	push	r28
    842a:	df 93       	push	r29
    842c:	cd b7       	in	r28, 0x3d	; 61
    842e:	de b7       	in	r29, 0x3e	; 62
    8430:	ca 1b       	sub	r28, r26
    8432:	db 0b       	sbc	r29, r27
    8434:	0f b6       	in	r0, 0x3f	; 63
    8436:	f8 94       	cli
    8438:	de bf       	out	0x3e, r29	; 62
    843a:	0f be       	out	0x3f, r0	; 63
    843c:	cd bf       	out	0x3d, r28	; 61
    843e:	19 94       	eijmp

00008440 <__epilogue_restores__>:
    8440:	2a 88       	ldd	r2, Y+18	; 0x12
    8442:	39 88       	ldd	r3, Y+17	; 0x11
    8444:	48 88       	ldd	r4, Y+16	; 0x10
    8446:	5f 84       	ldd	r5, Y+15	; 0x0f
    8448:	6e 84       	ldd	r6, Y+14	; 0x0e
    844a:	7d 84       	ldd	r7, Y+13	; 0x0d
    844c:	8c 84       	ldd	r8, Y+12	; 0x0c
    844e:	9b 84       	ldd	r9, Y+11	; 0x0b
    8450:	aa 84       	ldd	r10, Y+10	; 0x0a
    8452:	b9 84       	ldd	r11, Y+9	; 0x09
    8454:	c8 84       	ldd	r12, Y+8	; 0x08
    8456:	df 80       	ldd	r13, Y+7	; 0x07
    8458:	ee 80       	ldd	r14, Y+6	; 0x06
    845a:	fd 80       	ldd	r15, Y+5	; 0x05
    845c:	0c 81       	ldd	r16, Y+4	; 0x04
    845e:	1b 81       	ldd	r17, Y+3	; 0x03
    8460:	aa 81       	ldd	r26, Y+2	; 0x02
    8462:	b9 81       	ldd	r27, Y+1	; 0x01
    8464:	ce 0f       	add	r28, r30
    8466:	d1 1d       	adc	r29, r1
    8468:	0f b6       	in	r0, 0x3f	; 63
    846a:	f8 94       	cli
    846c:	de bf       	out	0x3e, r29	; 62
    846e:	0f be       	out	0x3f, r0	; 63
    8470:	cd bf       	out	0x3d, r28	; 61
    8472:	ed 01       	movw	r28, r26
    8474:	08 95       	ret

00008476 <_exit>:
    8476:	f8 94       	cli

00008478 <__stop_program>:
    8478:	ff cf       	rjmp	.-2      	; 0x8478 <__stop_program>
